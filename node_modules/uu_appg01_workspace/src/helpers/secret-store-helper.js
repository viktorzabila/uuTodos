"use strict";
const Crypto = require("crypto");
const ITERATION_NUMBER = 100000;
const KEY_LENGTH = 256 / 8;
const VECTOR_LENGTH = 96 / 8;
const DEFAULT_HASH_ALGORITHM = "sha3-256";
const BASE64_ENCODING = "base64";
const UTF8_ENCODING = "utf8";
const DEFAULT_AEAD_ALGORITHM = "aes-256-gcm";

class SecretStoreHelper {
  /**
   * Creates and returns an hash that uses the given algorithm, salt and key
   * @param {String} algorithm
   * @param {String} salt
   * @param {String} key
   * @returns {String}
   */
  createHash(algorithm = DEFAULT_HASH_ALGORITHM, salt = "", key = "") {
    return Crypto.createHmac(algorithm, salt).update(key).digest(BASE64_ENCODING);
  }

  /**
   * Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)
   * @param {String} salt
   * @param {String} masterKey1
   * @param {String} masterKey2
   * @param {Number} iterations
   * @param {Number} keyLength
   * @param {Number} vectorLength
   * @param {String} digest
   * @returns {Promise<*>}
   */
  createPbkdf2(
    salt,
    masterKey1,
    masterKey2,
    iterations = ITERATION_NUMBER,
    keyLength = KEY_LENGTH,
    vectorLength = VECTOR_LENGTH,
    digest = DEFAULT_HASH_ALGORITHM
  ) {
    if (!salt) {
      return Promise.reject("salt must be given");
    }
    if (!masterKey1 || !masterKey2) {
      return Promise.reject("masterKey1 and masterKey2 must be given");
    }
    const masterKey = masterKey1 + masterKey2;
    const derivedMasterKey = this.createHash(DEFAULT_HASH_ALGORITHM, salt, masterKey);
    return new Promise((resolve, reject) => {
      Crypto.pbkdf2(derivedMasterKey, salt, iterations, keyLength + vectorLength, digest, (e, key) => {
        if (e) {
          reject(e);
        } else {
          resolve({
            generatedKey: key.slice(0, keyLength),
            generatedVector: key.slice(keyLength, keyLength + vectorLength),
          });
        }
      });
    });
  }

  /**
   * Generates salt (cryptographically strong pseudo-random data)
   * @param {Number} bytesSize
   * @returns {String}
   */
  generateSalt(bytesSize) {
    return Crypto.randomBytes(bytesSize).toString("base64").slice(0, bytesSize);
  }

  /**
   * Creates and returns a Cipher object, with the given algorithm, key and initialization vector
   * @param {String} algorithm
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView | KeyObject} key
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView} iv
   * @returns {Object}
   */
  createCipheriv(algorithm = DEFAULT_AEAD_ALGORITHM, key, iv) {
    return Crypto.createCipheriv(algorithm, key, iv);
  }

  /**
   * Creates and returns Decipher object that uses the given algorithm, key and initialization vector
   * @param {String} algorithm
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView | KeyObject} key
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView}  iv
   * @returns {Object}
   */
  createDecipheriv(algorithm = DEFAULT_AEAD_ALGORITHM, key, iv) {
    return Crypto.createDecipheriv(algorithm, key, iv);
  }

  /**
   * Encrypts data using a given key and initialization vector
   * @param {String | Buffer | TypedArray | DataView} data
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView}  key
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView} iv
   * @returns {string}
   */
  encrypt(data, key, iv) {
    const cipher = this.createCipheriv(DEFAULT_AEAD_ALGORITHM, key, iv);
    const encrypted = Buffer.concat([cipher.update(data, UTF8_ENCODING), cipher.final()]);
    const tag = cipher.getAuthTag();
    return Buffer.concat([tag, encrypted]).toString(BASE64_ENCODING);
  }

  /**
   * Decrypts data using a given key and initialization vector
   * @param {String | Buffer | TypedArray | DataView} data
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView} key
   * @param {String | ArrayBuffer | Buffer | TypedArray | DataView} iv
   * @returns {string}
   */
  decrypt(data, key, iv) {
    const bufferData = Buffer.from(data, BASE64_ENCODING);
    const tag = bufferData.slice(0, 16);
    data = bufferData.slice(16);
    const decipher = this.createDecipheriv(DEFAULT_AEAD_ALGORITHM, key, iv);
    decipher.setAuthTag(tag);
    return decipher.update(data, BASE64_ENCODING, UTF8_ENCODING) + decipher.final(UTF8_ENCODING);
  }
}

module.exports = new SecretStoreHelper();
