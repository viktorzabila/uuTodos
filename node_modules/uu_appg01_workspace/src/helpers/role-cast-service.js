"use strict";
const { Mutex, LruCache } = require("uu_appg01_core-utils");
const { Uri, UriBuilder } = require("uu_appg01_core-uri");
const { LoggerFactory } = require("uu_appg01_core-logging");
const UuOs8UriHelper = require("./uu-os8-uri-helper.js");
const UuOs8CmdAdapter = require("./uu-os8-cmd-adapter.js");
const UuOs9CmdAdapter = require("./uu-os9-cmd-adapter.js");

const ROLE_SERVICE_URI = "ues/core/role/UESCast";
const UC_VERIFY_OS8_CAST_EXISTENCE = "verifyCastExistence";
const UC_VERIFY_OS9_CAST_EXISTENCE = "verifyMyCastExistence";
const UU8_CACHE_KEY = 1;
const UU9_CACHE_KEY = 2;

let verifyCastMutex = new Mutex();

class RoleCastService {

  constructor(uuOS8BaseUrl, castCacheTTL) {
    this._castCache = new LruCache({ maxAge: castCacheTTL });
    this._os8CastAdapter = new UuOs8CmdAdapter(uuOS8BaseUrl, ROLE_SERVICE_URI);
    this._os9CastAdapter = new UuOs9CmdAdapter();
    this._logger = LoggerFactory.get("UuApp.AppWorkspace.RoleCastService");
  }

  /**
   * Verify cast existence
   * @param {Object} session
   * @param {Array} roleList
   * @param {String} uuId
   * @returns {Promise<Array>}
   */
  async verifyCastExistence(session, roleList, uuId = null) {
    return verifyCastMutex.runOneAtTime(this._verifyCastExistence.bind(this), session, roleList, uuId);
  }

  /**
   * Verify cast existence
   * @param {Object} session
   * @param {Array} roleList
   * @param {String} uuId
   * @returns {Promise<Array>}
   */
  async _verifyCastExistence(session, roleList, uuId = null) {
    let preparedResult = [];
    let removedUris = [];
    let resultComplete = true;

    if (!uuId) {
      uuId = session.getIdentity().getUuIdentity();
    }

    roleList.forEach(subjectUri => {
      let key = `${uuId}_${subjectUri}`;
      let cachedEntry = this._castCache.get(key);
      if (cachedEntry === UU8_CACHE_KEY) {
        preparedResult.push({ uuOS9: false, role: subjectUri });
      } else if (cachedEntry === UU9_CACHE_KEY) {
        preparedResult.push({ uuOS9: true, role: subjectUri });
      } else if (cachedEntry === false) {
        removedUris.push(subjectUri);
      }
    });

    roleList = roleList.filter(x => !preparedResult.find(y => y.role === x));
    roleList = roleList.filter(x => removedUris.indexOf(x) < 0);

    if (roleList.length !== 0) {
      let { uuOS9RoleUris, uuOS8RoleUris } = this._splitRoleUris(roleList);
      //check cast to uuOS9
      const rolesPerTerritory = this._splitRolesPerUuOs9Territory(uuOS9RoleUris);

      const verificationPromises = [];
      rolesPerTerritory.forEach((roleGroupIfcs, territoryUri) => {
        verificationPromises.push(this.verifyUuOS9CastExistence(territoryUri, roleGroupIfcs, uuId, session));
      });
      const verifiedUuOS9Roles = await Promise.all(verificationPromises);

      uuOS9RoleUris.forEach((roleGroupUri, role) => {
        const territoryUri = roleGroupUri.getBaseUri().toString();
        const territoryCasts = verifiedUuOS9Roles.find(result => {
          resultComplete = resultComplete && result.resultComplete;
          if (result.error) {
            preparedResult.error = result.error;
          }
          return result.territoryUri === territoryUri;
        });
        let cacheKey = `${uuId}_${role}`;
        if (territoryCasts) {
          const rgi = territoryCasts.roleGroupIfcList.find(r => r.id === roleGroupUri.getParameters().id || r.code === roleGroupUri.getParameters().code);
          if (rgi) {
            preparedResult.push({ uuOS9: true, role });
            this._castCache.set(cacheKey, UU9_CACHE_KEY);
            return;
          }
        }
        this._castCache.set(cacheKey, false);
      });

      //check cast to uuOS8
      let subjectUrisTerritories = {};
      uuOS8RoleUris.forEach(subjectUri => this._handleTerritories(subjectUri, subjectUrisTerritories));

      let keys = Object.keys(subjectUrisTerritories);
      for (let i = 0; i < keys.length; i += 1) {
        let territoryUri = keys[i];
        let territoryArray = subjectUrisTerritories[territoryUri];
        let castVerifyResult = await this.verifyUuOS8CastExistence(territoryArray, territoryUri, uuId, session);
        resultComplete = resultComplete && castVerifyResult.resultComplete;
        preparedResult = preparedResult.concat(
          castVerifyResult.map(x => {
            return { uuOS9: false, role: x };
          })
        );
      }
    }

    preparedResult.resultComplete = resultComplete;
    return preparedResult;
  }

  _splitRolesPerUuOs9Territory(uuOS9RoleUris) {
    const rolesPerTerritory = new Map();
    for (let role of uuOS9RoleUris.values()) {
      const territory = role.getBaseUri().toString();
      if (!rolesPerTerritory.has(territory)) {
        rolesPerTerritory.set(territory, []);
      }
      const territoryRoles = rolesPerTerritory.get(territory);
      const roleId = role.getParameters().id;
      const roleCode = role.getParameters().code;
      if (!territoryRoles.some(r => (roleId && roleId == r.id) || (roleCode && roleCode == r.code))) { // role is unique
        territoryRoles.push({ id: roleId, code: roleCode });
      }
    }
    return rolesPerTerritory;
  }

  /**
   * Verify uuOS9 cast existence
   * @param roleGroupUri
   * @param preparedResult
   * @param uuId
   * @param session
   * @returns {Promise<*>}
   */
  async verifyUuOS9CastExistence(territoryUri, roleGroupIfcs, uuId, session) {
    let uri = new UriBuilder().parse(territoryUri).setUseCase(UC_VERIFY_OS9_CAST_EXISTENCE).clearParameters().toUri();
    let rolesSliced = [];
    let result = { territoryUri, roleGroupIfcList: [], resultComplete: true };

    this._eachSlice(roleGroupIfcs, 32, r => {
      rolesSliced.push(r);
    });

    const verifiedRoles = await Promise.all(rolesSliced.map(async roles => {
      const dtoIn = { roleGroupIfcList: roles };
      try {
        return await this._os9CastAdapter.get(uri, dtoIn, session);
      } catch (e) {
        if (e.status === 403 || e.code === "uu-businessterritory-maing01/authorization/accessDenied"
          || e.code === "uu-appg01/authorization/accessDenied"
          || e.code === "uu-myterritory-maing01/authorization/accessDenied") {
          this._logger.debug(`User ${session.getIdentity().getUuIdentity()} is not authorized for roles: ${JSON.stringify(roles)} in territory ${uri}.`, e);
        } else {
          this._logger.error(`Unable to verify cast existence of uuIdentity ${session.getIdentity().getUuIdentity()} in territory ${uri} for roles: ${JSON.stringify(roles)}`, e);
          result.resultComplete = false;
          result.error = e;
        }
      }
    }));

    verifiedRoles.forEach(r => {
      if (r && r.roleGroupIfcList) {
        result.roleGroupIfcList = result.roleGroupIfcList.concat(r.roleGroupIfcList);
      }
    });

    return result;
  }

  /**
   * Cast subject Uris with Territory
   * @param subjectUri
   * @param subjectUrisTerritories
   */
  _handleTerritories(subjectUri, subjectUrisTerritories) {
    let territoryUri;

    if (UuOs8UriHelper.isOidSet(subjectUri)) {
      let territoryId = UuOs8UriHelper.getTerritoryId(subjectUri);
      territoryUri = `ues:[${territoryId}]:[${territoryId}]:`;
    } else {
      let territoryCode = UuOs8UriHelper.getTerritoryCode(subjectUri);
      if (!territoryCode) {
        return;
      }
      territoryUri = `ues:${territoryCode}:${territoryCode}:`;
    }

    if (!subjectUrisTerritories[territoryUri]) {
      subjectUrisTerritories[territoryUri] = [];
    }
    subjectUrisTerritories[territoryUri].push(subjectUri);
  }

  /**
   * Verify uuOS8 cast existence
   * @param territoryArray
   * @param territoryUri
   * @param uuId
   * @param session
   * @returns {Promise<*>}
   * @private
   */
  async verifyUuOS8CastExistence(territoryArray, territoryUri, uuId, session) {
    let eachSliced = [];
    let preparedResult = [];
    let resultComplete = true;

    this._eachSlice(territoryArray, 10, territorySliced => {
      eachSliced.push(territorySliced);
    });

    for (let i = 0; i < eachSliced.length; i += 1) {
      let territorySliced = eachSliced[i];

      let addendum = "";
      for (let l = 0; l < territorySliced.length; l += 1) {
        let subjectUri = territorySliced[l];
        addendum += `&subjectUris=${subjectUri}`;
      }

      let params = { castSubjectUniverseId: `${uuId}${addendum}` };
      let result;
      let cacheErrorResult = false;

      try {
        let response = await this._os8CastAdapter.get(UC_VERIFY_OS8_CAST_EXISTENCE, territoryUri, params, session);
        result = response.data;
      } catch (e) {
        this._logger.warn(`Unable to verify cast existence of uuIdentity ${uuId} in territory ${territoryUri} for roles: ${territorySliced}`, e);
        if (e.message && (e.message.includes("UU.OS/E05303") || e.message.includes("UU.OS/E05300"))) { // territory is not registred or no access to the territory
          cacheErrorResult = true;
        } else {
          resultComplete = false;
        }
      }

      if (result) {
        preparedResult = result;
      }

      territorySliced.forEach(subjectUri => {
        let symbol = `${uuId}_${subjectUri}`;
        if (result) {
          let tmp = result.find(uri => UuOs8UriHelper.equalUris(uri, subjectUri));
          this._castCache.set(symbol, tmp ? UU8_CACHE_KEY : false);
        } else if (cacheErrorResult) {
          this._castCache.set(symbol, false);
        }
      });
    }

    preparedResult.resultComplete = resultComplete;
    return preparedResult;
  }

  /**
   * Reset whole cast cache
   */
  clearCache() {
    this._castCache.clear();
  }

  /**
   * Split roleList to uuOS8 and uuOS9
   * @param roleList
   * @returns {{uu0S9RolesUris, uuoS8roleUris: Array}}
   * @private
   */
  _splitRoleUris(roleList) {
    let uuOS9RoleUris = new Map();
    let uuOS8RoleUris = [];

    roleList.forEach(function(entry) {
      try {
        uuOS9RoleUris.set(entry, Uri.parse(entry));
      } catch (e) {
        // roleUri was not parsed, pretend it is uuOS8 roleUri
        uuOS8RoleUris.push(entry);
      }
    });

    return {
      uuOS9RoleUris,
      uuOS8RoleUris
    };
  }

  /**
   *
   * @param {Array} arr
   * @param {Number} size
   * @param {function} callback
   */
  _eachSlice(arr, size, callback) {
    for (let i = 0, l = arr.length; i < l; i += size) {
      callback.call(arr, arr.slice(i, i + size));
    }
  }

}

module.exports = RoleCastService;
