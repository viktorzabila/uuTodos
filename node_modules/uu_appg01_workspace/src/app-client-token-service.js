"use strict";

const SysAppClientTokenAbl = require("./abl/sys-app-client-token-abl");
const SysAppSecretStoreAbl = require("./abl/sys-app-secret-store-abl.js");
const JsonWebToken = require("jsonwebtoken");
const PemJwk = require("pem-jwk");
const Crypto = require("crypto");
const { UriBuilder } = require("uu_appg01_core-uri");
const Errors = require("./api/errors/sys-app-client-token-errors").AppClientService;
const util = require("util");
const promisifiedVerify = util.promisify(JsonWebToken.verify);
const { AppClient } = require("uu_appg01_core-appclient");
const { Config } = require("uu_appg01_core-utils");
const AppClientToken = require("./app-client-token");
const { UuAppKey } = require("uu_appg01_core-authentication");

const { LoggerFactory } = require("uu_appg01_core-logging");
const logger = LoggerFactory.get("AppClientTokenService");

const TOKEN_ALG = "RS256";
const DEFAULT_TOKEN_TTL = 5 * 60;
const MAX_TOKEN_TTL = 60 * 60 * 24; // 24 hours
const LEEWAY = 60;
const PUBLIC_KEY_UC = "sys/appClientToken/listKeys";
const VALIDATION_SECRET_SET = "uuAppClientTokenValidation";

/**
 * Service serves for verifying application calls. The verification is done using JWT token sent in the header during remote application call. Basic scenario:
 * <pre>
 * 1. Application A creates a token using {@link AppClientTokenService#createToken(Uri, Uri)}.
 * 2. Application A sets the token to uuAppClient call options using {@link AppClientTokenService#setToken(AppClientOptions, String)}.
 * 3. Application A makes the call to application B using prepared call options.
 * 4. Application B retrieves the token using {@link AppClientTokenService#getToken(ServletWebRequest)}.
 * 5. Using {@link AppClientTokenService#isTokenValid(Uri, AppClientToken, Uri)} application B verifies that the token is valid and is signed by application A.
 * </pre>
 */
class AppClientTokenService {
  constructor() {
    this._publicKeyCache = {};
    this._tokenTtl = Config.get("uu_app_client_token_ttl") || DEFAULT_TOKEN_TTL;
  }

  /**
   * Creates a signed JWT token containing an awid claim.
   *
   * @param {Uri} baseUri canonical base uri of the caller (client).
   * @param {Uri} callUri the uri to be called with the token (server).
   * @param {number} tokenTtl of created token in seconds. The maximum allowed value is 86 400 (~24 hours). This will overload the global uuAppClientToken ttl which is by default set to 300 (5 min).
   * @return {Promise<string>} signed JWT token.
   */
  async createToken(baseUri, callUri, tokenTtl = this._tokenTtl) {
    let { kid, privateKey } = await SysAppClientTokenAbl.getPrivateKey(baseUri.getAwid());
    let uuAppKey = UuAppKey.valueOf(
      baseUri.getVendor(),
      baseUri.getApp(),
      baseUri.getSubApp(),
      Config.get("asid"),
      baseUri.getAwid()
    );
    if (tokenTtl > MAX_TOKEN_TTL) {
      logger.warn(
        `The specified ttl (${tokenTtl}) is greater than the maximum allowed value (${MAX_TOKEN_TTL}). The maximum allowed value will be used.`
      );
      tokenTtl = MAX_TOKEN_TTL;
    }
    let opts = {
      algorithm: TOKEN_ALG,
      expiresIn: tokenTtl,
      keyid: kid,
      audience: UriBuilder.parse(callUri)
        .setParameters({})
        .toUri()
        .toString(),
      issuer: baseUri.getBaseUri().toString(),
      subject: uuAppKey.toString(),
      jwtid: Crypto.randomBytes(Math.ceil(32 / 2))
        .toString("hex")
        .slice(0, 32)
    };
    return JsonWebToken.sign({}, privateKey, opts);
  }

  /**
   * Sets the app client token to uuAppClient call options.
   *
   * @param {Object} callOpts uuAppClient call options.
   * @param {string} appClientToken the app client token.
   * @return {Object} uuAppClient call options..
   */
  setToken(callOpts, appClientToken) {
    let headers = callOpts.headers;
    if (!headers) {
      headers = {};
      callOpts.headers = headers;
    }
    headers["X-uuApp-Client-Token"] = appClientToken;
    return callOpts;
  }

  /**
   * Retrieves the app client token from the ucEnv.
   *
   * @param {UseCaseEnvironment} ucEnv Use Case Environment
   * @return {AppClientToken} the app client token.
   */
  getToken(ucEnv) {
    let token = ucEnv.getRequest().getHeaders()["x-uuapp-client-token"];
    if (!token) {
      return null;
    }
    let parsed = new AppClientToken(token);
    if (!parsed._getJwt()) throw new Errors.InvalidFormat();
    return parsed;
  }

  /**
   * Validates that the app client token was signed by specified application.
   * Also validates AppKey, which is obtained from token's sub claim (if appKey parameter provided).
   *
   * @param {Uri} uri Uri of the currently called endpoint which is validating the token. Should be taken from {@link UseCaseEnvironment}
   * @param {AppClientToken} appClientToken the app client token.
   * @param {Uri} clientAppBaseUri base uri of the client application to validate the token.
   * @param {UuAppKey} appKey AppKey used for validation of the token. Only non-null parts of this token are compared with the one obtained from the token.
   * @return {Promise<boolean>} true if the token is signed by specified client app and AppKey matches.
   */
  async isTokenValid(uri, appClientToken, clientAppBaseUri, appKey) {
    if (!appClientToken) {
      return false;
    }

    if (appKey) {
      let valid = this._validateAppKey(appClientToken, appKey);
      if (!valid) {
        logger.warn("AppToken's appKey is different from the expected appKey.");
        return false;
      }
    }

    clientAppBaseUri = clientAppBaseUri.getBaseUri(); // just to be sure
    let publicKeyUri = UriBuilder.parse(clientAppBaseUri)
      .setUseCase(PUBLIC_KEY_UC)
      .toUri();
    logger.info(`Validating uuAppClientToken, uri: ${uri}, clientAppBaseUri: ${clientAppBaseUri}`);

    // cache check
    let cacheKey = `${publicKeyUri.getBaseUri().toString()}_${appClientToken._getJwt().header.kid}`;
    let cachedPublicKey = this._publicKeyCache[cacheKey];
    if (cachedPublicKey) {
      try {
        await promisifiedVerify(appClientToken._getTokenOrigin(), cachedPublicKey, { clockTolerance: LEEWAY });
        return true;
      } catch (e) {
        logger.error("Verifying by cached public key failed", e);
      }
    }

    // database check
    let storedPublicKey = await SysAppSecretStoreAbl.getSecret(uri.getAwid(), VALIDATION_SECRET_SET, cacheKey);
    if (storedPublicKey) {
      try {
        await promisifiedVerify(appClientToken._getTokenOrigin(), storedPublicKey, { clockTolerance: LEEWAY });
        this._publicKeyCache[cacheKey] = storedPublicKey;
        return true;
      } catch (e) {
        logger.error("Verifying by persisted public key failed", e);
      }
    }

    // endpoint check
    let keys, publicKey;
    try {
      keys = await AppClient.get(publicKeyUri);
    } catch (e) {
      let message = `The public keys for token validation are not available for provided issuer: ${publicKeyUri}`;
      throw new Errors.UnexpectedError(message, e);
    }

    // update key store and chache
    for (const key of keys.keys) {
      let pem = PemJwk.jwk2pem(key);
      if (key.kid === appClientToken._getJwt().header.kid) publicKey = pem;
      cacheKey = `${publicKeyUri.getBaseUri().toString()}_${key.kid}`;
      await SysAppSecretStoreAbl.putSecret(uri.getAwid(), VALIDATION_SECRET_SET, cacheKey, pem);
      this._publicKeyCache[cacheKey] = pem;
    }

    // there is no public key with token's kid
    if (!publicKey) {
      logger.warn("There is no public key with appToken's kid");
      return false;
    }

    //
    try {
      await promisifiedVerify(appClientToken._getTokenOrigin(), publicKey, { clockTolerance: LEEWAY });
      return true;
    } catch (e) {
      logger.error("Verifying by public key failed", e);
      return false;
    }
  }

  /**
   * Generates RSA key pair (public and private). Already existing key pair is updated instead of initializing another one.
   *
   * @param {string} awid
   * @returns {Promise<Object>} key structure as defined by rfc - standard
   */
  async initKeys(awid) {
    return await SysAppClientTokenAbl.initKeys(awid);
  }

  /**
   * Obtains a list of public keys in JWK format.
   *
   * @param {string} awid
   * @returns {Promise<Object>} array of keys
   */
  async listKeys(awid) {
    return await SysAppClientTokenAbl.listKeys(awid);
  }

  _validateAppKey(appClientToken, expectedAppKey) {
    expectedAppKey = UuAppKey.parse(expectedAppKey);
    try {
      let tokenAppKey = UuAppKey.parse(appClientToken.getSubject());
      return expectedAppKey.compareNonNullParts(tokenAppKey);
    } catch (e) {
      logger.error("Unable to parse appKey from the subject claim: " + appClientToken.getSubject(), e);
      return false;
    }
  }
}

module.exports = new AppClientTokenService();
