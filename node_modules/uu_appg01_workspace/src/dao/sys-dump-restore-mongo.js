"use strict";
const { UuObjectDao } = require("uu_appg01_objectstore");
const { DbConnection } = require("uu_appg01_datastore");
const Mongodb = require("mongodb");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");
const logger = LoggerFactory.get("UuApp.Workspace.Daos.SysDumpRestoreMongo");

class SysDumpRestoreMongo extends UuObjectDao {

  /**
   * Override parent method - no default indexes needed for importExport
   * @return {Promise<void>}
   * @private
   */
  async _createDefaultIndexes() {
  }

  async deleteMany(filter) {
    let db = await DbConnection.get(this.customUri);
    return db.collection(this.collectionName).deleteMany(filter);
  }

  async deleteManyByAwid(awid) {
    return await this.deleteMany({ awid });
  }

  async deleteBinary(filter, schema, toDeleteFileIdList) {
    let db = await DbConnection.get(this.customUri);
    let bucket = new Mongodb.GridFSBucket(db, { bucketName: schema });
    let newDeletedFileIdList = [];

    let findResult = await db
      .collection(schema)
      .find(filter)
      .toArray();
    if (findResult) {
      let promises = findResult.map(async item => {
        if (!toDeleteFileIdList || toDeleteFileIdList.get(item.fileId.toString()) == null) {
          await db.collection(schema).deleteOne({ _id: item._id });
          try {
            await bucket.delete(item.fileId);
          } catch (e) {
            logger.error(`Error during deleting the file "${item.fileId}" from gridFS.`, e);
          }
          newDeletedFileIdList.push(item.fileId.toString());
        }
      });
      await Promise.all(promises);
      return newDeletedFileIdList;
    }
  }

  async getIndexes() {
    let db = await DbConnection.get(this.customUri);
    return db.collection(this.collectionName).listIndexes();
  }

  async find(filter) {
    let db = await DbConnection.get(this.customUri);
    return db.collection(this.collectionName).find(filter);
  }

  async insertOne(uuObject) {
    let db = await DbConnection.get(this.customUri);
    return await db.collection(this.collectionName).insertOne(uuObject);
  }

  static async dropAllDatabases() {
    let promises = Object.keys(DbConnection._connectionsMap).map(async connectionString => {
      let db = await DbConnection.get(connectionString);
      // db.drop doesn't work in uuCloud due limited permissions -> using collection.drop insted
      let collections = await db.collections();
      collections = collections.map(async col => {
        await col.drop();
      });
      await Promise.all(collections);
    });
    return Promise.all(promises);
  }

  async calculateDatabaseStats() {
    let totalDumpSize = 0;
    let promises = Object.keys(DbConnection._connectionsMap).map(async connectionString => {
      let db = await DbConnection.get(connectionString);
      let stats = await db.stats();
      totalDumpSize += stats.dataSize;
    });
    await Promise.all(promises);
    return totalDumpSize;
  }

  async count(filter) {
    let db = await DbConnection.get(this.customUri);
    return db.collection(this.collectionName).countDocuments(filter);
  }

  async binaryCount(fileIdList) {
    let db = await DbConnection.get(this.customUri);
    let result = await db.collection(this.collectionName).countDocuments({ files_id: { $in: fileIdList } });
    return result;
  }

  async createIndexes(indexSpecs, isAvid, schema, uuAppErrorMap) {
    let db = await DbConnection.get(this.customUri);
    indexSpecs.forEach(async index => {
      delete index["ns"];

      try {
        await db.collection(this.collectionName).createIndexes([index]);
      } catch (e) {
        if (isAvid) {
          await db.collection(this.collectionName).dropIndex(index.name);
          await db.collection(this.collectionName).createIndexes([index]);
        } else {
          let invalidRow = { schema, index, cause: e };
          if (!uuAppErrorMap["indexRestoreFailed"]) {
            ValidationHelper.addWarning(
              uuAppErrorMap,
              "indexRestoreFailed",
              "Create index by DAO failed. See the cause for more details.",
              { rows: [invalidRow] }
            );
          } else {
            uuAppErrorMap["indexRestoreFailed"].paramMap.rows.push(invalidRow);
          }
        }
      }
    });
  }

  async importIndexes(indexSpecs) {
    let mishaps = [];
    for (let index of indexSpecs) {
      delete index.ns;
      try {
        let db = await DbConnection.get(this.customUri);
        await db.collection(this.collectionName).createIndexes([index]);
      } catch (e) {
        mishaps.push({ cause: e.message, index });
      }
    }
    return mishaps;
  }

  async getFileIdList(filter) {
    let db = await DbConnection.get(this.customUri);
    let cursor = await db.collection(this.collectionName.substr(0, this.collectionName.lastIndexOf("."))).find(filter);
    await cursor.project({ fileId: 1, _id: 0 });
    return await cursor.toArray();
  }

  async insertMany(bulkQueue) {
    let bulkInserts = [];
    bulkQueue.forEach(document => {
      bulkInserts.push({
        insertOne: {
          document: document.data
        }
      });
    });
    let db = await DbConnection.get(this.customUri);
    if (bulkInserts.length > 0) {
      return db.collection(this.collectionName).bulkWrite(bulkInserts, { ordered: true });
    }
  }

}

module.exports = SysDumpRestoreMongo;
