"use strict";

const { Config, OptsReader, Mutex, LruCache, Json, Digest } = require("uu_appg01_core-utils");
const { AuthorizationService, AuthorizationError } = require("uu_appg01_core-authorization");
const { UriBuilder } = require("uu_appg01_core-uri");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { AppClient } = require("uu_appg01_server-client");
const { Validator } = require("uu_appg01_core-validation");
const { ValidationHelper } = require("uu_appg01_core-appserver");

let UseCaseContext = null;
try {
  UseCaseContext = require("uu_appg01_core-appserver").UseCaseContext;
} catch (e) {
  UseCaseContext = null;
}

const AppInstanceComponent = require("./api/components/app-instance");
const WorkspaceAuthorizationResult = require("./workspace-authorization-result.js");
const ProfileConfig = require("./helpers/profile-config.js");
const SysAppWorkspaceAbl = require("./abl/sys-app-workspace-abl.js");
const SysPermissionAbl = require("./abl/sys-permission-abl.js");
const SysProfileAbl = require("./abl/sys-profile-abl.js");
const RoleCastService = require("./helpers/role-cast-service.js");
const UuOs8UriHelper = require("./helpers/uu-os8-uri-helper.js");
const WorkspaceAuthorizationErrors = require("./api/errors/authorization-errors.js");

const logger = LoggerFactory.get("WorkspaceAuthorizationService");

const PARAM_ROLE_MANAGEMENT_BASE_URI = "uu_app_workspace_role_management_uri";
const PARAM_USER_PROFILE_CACHE_TTL = "uu_app_workspace_user_profile_cache_ttl";
const PARAM_USER_PROFILE_CACHE_MAX_SIZE = "uu_app_workspace_user_profile_cache_max_size";
const PARAM_USER_PROFILE_NEGATIVE_CACHE_TTL = "uu_app_workspace_user_profile_negative_cache_ttl";

const PARAM_OBJECT_USER_PROFILE_CACHE_TTL = "uu_app_workspace_object_user_profile_cache_ttl";
const PARAM_OBJECT_USER_PROFILE_CACHE_MAX_SIZE = "uu_app_workspace_object_user_profile_cache_max_size";
const PARAM_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL = "uu_app_workspace_object_user_profile_negative_cache_ttl";

const PARAM_AUTHORIZATION_TIMEOUT = "uu_app_workspace_authorization_timeout";
const DEFAULT_AUTHORIZATION_TIMEOUT = 5 * 1000;

const PARAM_ROLE_CAST_CACHE_TTL = "uu_app_workspace_role_cast_cache_ttl";

const DEFAULT_SERVICE_NAME = "uu_appg01_workspace";
const DEFAULT_ROLE_MANAGEMENT_BASE_URI = "https://api.plus4u.net";
const DEFAULT_USER_PROFILE_CACHE_TTL = 5 * 60 * 1000;
const DEFAULT_USER_PROFILE_CACHE_MAX_SIZE = 100_000;
const DEFAULT_USER_PROFILE_NEGATIVE_CACHE_TTL = 60 * 1000;
const DEFAULT_OBJECT_USER_PROFILE_CACHE_TTL = 5 * 60 * 1000;
const DEFAULT_OBJECT_USER_PROFILE_CACHE_MAX_SIZE = 100_000;
const DEFAULT_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL = 60 * 1000;
const DEFAULT_AUTHZ_STRATEGY = "roleGroupInterface";
const DEFAULT_ASID_AUTHZ_STRATEGY = DEFAULT_AUTHZ_STRATEGY;

const GGALL = "urn:uu:GGALL";
const GGPLUS4U = "urn:uu:GGPLUS4U";
const ANONYMOUS_USER = "0-0";

const PUBLIC_PROFILE = "Public";
const AUTHENTICATED_PROFILE = "Authenticated";
const CREATED_SYS_STATE = "created";

class WorkspaceAuthorizationService {
  /**
   * Checks whether identity represented by the session is authorized to access resources at given uri. In case identity
   * is not authorized, error is not directly raised, but unauthorized authorization context is returned as result.
   * Logic which is performing authorization is then responsible to raise AccessDenied error in case there is no
   * alternative flow to handle unauthorized access.
   * @param {Session} session Instance of session representing authenticated user
   * @param {uri} uri Address of the use case
   * @returns {Promise<AuthorizationResult>} Authorization result
   */
  static async authorize(session, uri) {
    return await AuthorizationService.get(DEFAULT_SERVICE_NAME).authorize(session, uri);
  }

  /**
   * Creates new instance of uuAppWorkspace authorization service and registers it
   * as authorization service with given name.
   * @param {String} name Service name
   * @param {Object|null} options Service options
   */
  static create(name, options = {}) {
    let authService = new WorkspaceAuthorizationService(options);
    AuthorizationService._register(name, authService);
  }

  /**
   * Creates new instance of uuAppWorkspace authorization service.
   * @param options Service options
   * @private
   */
  constructor(options = {}) {
    let opts = new OptsReader(options, Config);
    let userProfileCacheTtl = opts.getNumber(PARAM_USER_PROFILE_CACHE_TTL);
    if (userProfileCacheTtl == null) {
      userProfileCacheTtl = opts.getNumber(PARAM_ROLE_CAST_CACHE_TTL);
      userProfileCacheTtl = userProfileCacheTtl == null ? DEFAULT_USER_PROFILE_CACHE_TTL : userProfileCacheTtl * 1000;
    }
    let userProfileCacheMaxSize = opts.getNumber(PARAM_USER_PROFILE_CACHE_MAX_SIZE, DEFAULT_USER_PROFILE_CACHE_MAX_SIZE);
    this._userProfileNegativeCacheTtl = opts.getNumber(PARAM_USER_PROFILE_NEGATIVE_CACHE_TTL, DEFAULT_USER_PROFILE_NEGATIVE_CACHE_TTL);
    this._userProfileCache = new LruCache({ maxAge: userProfileCacheTtl, maxSize: userProfileCacheMaxSize });

    let objectUserProfileCacheMaxSize = opts.getNumber(PARAM_OBJECT_USER_PROFILE_CACHE_MAX_SIZE, DEFAULT_OBJECT_USER_PROFILE_CACHE_MAX_SIZE);
    let objectUserProfileCacheTtl = opts.getNumber(PARAM_OBJECT_USER_PROFILE_CACHE_TTL, DEFAULT_OBJECT_USER_PROFILE_CACHE_TTL);
    this._objectUserProfileNegativeCacheTtl = opts.getNumber(PARAM_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL, DEFAULT_OBJECT_USER_PROFILE_NEGATIVE_CACHE_TTL);
    this._objectUserProfileCache = new LruCache({ maxAge: objectUserProfileCacheTtl, maxSize: objectUserProfileCacheMaxSize });

    this._mutex = new Mutex();
    let uu0S8CastServiceBaseUrl = opts.get(PARAM_ROLE_MANAGEMENT_BASE_URI, DEFAULT_ROLE_MANAGEMENT_BASE_URI);
    this._castService = new RoleCastService(uu0S8CastServiceBaseUrl, 0); // do not use internal cast cache
    this._authTimeout = opts.getNumber(PARAM_AUTHORIZATION_TIMEOUT, DEFAULT_AUTHORIZATION_TIMEOUT) / 1000;
    this._asid = Config.get("asid");
    ProfileConfig.loadProfilesConfig();
    this.validator = Validator.load();
  }

  async authorize(session, uri, authorizationStrategy = null) {
    let identity = session.getIdentity();
    let uuIdentity = (identity ? identity.getUuIdentity() : ANONYMOUS_USER) || ANONYMOUS_USER;
    let awid = uri.getAwid();
    let useCaseName = uri.getUseCase();

    let ucProfiles;
    let allProfiles;
    if (ProfileConfig.isPrivilegedCall(awid)) {
      ucProfiles = ProfileConfig.getPrivilegedUseCaseProfiles(awid, useCaseName);
      allProfiles = ProfileConfig.getPrivilegedProfiles(awid);
    } else {
      ucProfiles = ProfileConfig.getUseCaseProfiles(useCaseName);
      allProfiles = ProfileConfig.getProfiles();
    }

    if (ucProfiles.length === 0) {
      return new WorkspaceAuthorizationResult({ uuIdentity, isAuthorized: false });
    }
    if (ucProfiles.length === 1 && ucProfiles.includes(PUBLIC_PROFILE)) {
      return new WorkspaceAuthorizationResult({ uuIdentity, isAuthorized: true });
    }

    const isAuthenticated = uuIdentity !== ANONYMOUS_USER;
    if (isAuthenticated && ucProfiles.length === 1 && ucProfiles.includes(AUTHENTICATED_PROFILE)) {
      return new WorkspaceAuthorizationResult({ uuIdentity, isAuthorized: true });
    }

    let { userProfiles, authorizationTime, authorizationStrategy: resultAuthorizationStrategy } = await this._getUserProfiles(awid, uuIdentity, session, authorizationStrategy);
    let authorizedProfiles = ucProfiles.filter(profile => userProfiles.has(profile));

    if (authorizedProfiles.length === 0 && !ucProfiles.includes(PUBLIC_PROFILE)) {
      // check negative authorization cache
      if (Date.now() - authorizationTime > this._userProfileNegativeCacheTtl) {
        let result = await this._getUserProfiles(awid, uuIdentity, session, authorizationStrategy, false);
        userProfiles = result.userProfiles;
      } else {
        // In case authorized profiles are empty, try to re-load explicit permissions
        // which are often used to provide immediate temporary access and might not yet
        // be cached
        let result = await this._loadProfilesByPermissions(awid, uuIdentity);
        // Push additional profiles to existing result, so that cached result is updated
        result.userProfiles.forEach(profile => userProfiles.add(profile));
      }
      authorizedProfiles = ucProfiles.filter(profile => userProfiles.has(profile));
    }

    let contextData = {
      uuIdentity,
      useCase: useCaseName,
      authorizationStrategy: resultAuthorizationStrategy,
      profileList: allProfiles.filter(p => ![PUBLIC_PROFILE, AUTHENTICATED_PROFILE].includes(p)),
      authorizedProfileList: authorizedProfiles,
      uuIdentityProfileList: [...userProfiles],
      useCaseProfileList: ucProfiles
    };
    if (ucProfiles.includes(PUBLIC_PROFILE) || (isAuthenticated && ucProfiles.includes(AUTHENTICATED_PROFILE))) {
      contextData.isAuthorized = true;
    }
    return new WorkspaceAuthorizationResult(contextData);
  }

  async authorizeObject(session, useCase, authorizationData = {}) {
    if (!useCase || !useCase.name) {
      throw new AuthorizationError(`Unable to authorize object. Use case name must be defined.`);
    }

    let result;
    switch (authorizationData.authorizationStrategy) {
      case "artifact":
        result = await this._authorizeObjectArtifact(session, useCase, authorizationData);
        break;
      case "boundArtifact":
        result = await this._authorizeObjectBoundArtifact(session, useCase, authorizationData);
        break;
      case "roleGroupInterface":
        result = await this._authorizeObjectRoleGroupInterface(session, useCase, authorizationData);
        break;
      case "uuIdentityList":
        result = await this._authorizeObjectUuIdentityList(session, useCase, authorizationData);
        break;
      default:
        throw new AuthorizationError(`Object authorization failed. Unknown authorization strategy: ${authorizationData.authorizationStrategy}.`);
    }

    return result;
  }

  async _authorizeObjectArtifact(session, useCase, authorizationData) {
    this._validateAuthorizationData(authorizationData, "authorizeObjectArtifactType");

    let awid;
    if (UseCaseContext && UseCaseContext.getUri()) {
      awid = UseCaseContext.getUri().getAwid();
    }
    if (!awid || awid === this._asid) {
      throw new AuthorizationError(`Unable to authorize object. Cannot use artifact authorization out of request scope or within asid request.`);
    }
    const uuIdentity = session.getIdentity().getUuIdentity();

    const cacheKey = `${awid}|${uuIdentity}|${authorizationData.artifactId}|${authorizationData.artifactCode}|${useCase.name}`;
    let artifactUri;
    let result = await this._useObjectCacheWrapper(cacheKey,
      async () => {
        let appWorkspace = await SysAppWorkspaceAbl.get(awid);
        const awscArtifactUri = appWorkspace.artifactUri;
        if (!awscArtifactUri) {
          throw new AuthorizationError(`Unable to authorize object. Cannot use artifact authorization because the current awid (${awid}) is not connected to uuBT.`);
        }
        artifactUri = this._buildArtifactUri(awscArtifactUri, authorizationData.artifactId, authorizationData.artifactCode);
        return this._loadUserProfilesByArtifact(session, uuIdentity, artifactUri, useCase.name);
      },
      (r) => r.authorizedAppTypeProfiles.length > 0
    );

    if (!result.resultComplete) {
      throw new AuthorizationError(`Artifact authorization failed. uuIdentity: ${uuIdentity}, artifactUri=${artifactUri}`, result.error);
    }
    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: result.authorizedAppTypeProfiles,
      uuIdentityObjectProfileList: result.userAppTypeProfiles,
      useCaseObjectProfileList: result.ucAppTypeProfiles
    });
  }

  async _authorizeObjectBoundArtifact(session, useCase, authorizationData) {
    if (!useCase.objectProfileList) {
      throw new AuthorizationError(`Unable to authorize object. Use case profiles must be defined.`);
    }
    if (authorizationData.uuTerritoryBaseUri && !(authorizationData.uuTerritoryBaseUri instanceof String)) {
      authorizationData.uuTerritoryBaseUri = authorizationData.uuTerritoryBaseUri.toString();
    }
    this._validateAuthorizationData(authorizationData, "authorizeObjectBoundArtifactType");

    const uuIdentity = session.getIdentity().getUuIdentity();
    const artifactUri = this._buildArtifactUri(authorizationData.uuTerritoryBaseUri, authorizationData.boundArtifactId, authorizationData.boundArtifactCode);

    const cacheKey = `${artifactUri.getAwid()}|${uuIdentity}|${authorizationData.boundArtifactId}|${authorizationData.boundArtifactCode}`;
    let result = await this._useObjectCacheWrapper(cacheKey,
      async () => {
        return this._loadUserProfilesByArtifact(session, uuIdentity, artifactUri);
      },
      (result) => {
        const { authorizedProfiles } = this._evaluateboundArtifactProfileMap(result, authorizationData.boundArtifactProfileMap, useCase.objectProfileList);
        return authorizedProfiles && authorizedProfiles.length > 0;
      });

    if (!result.resultComplete) {
      throw new AuthorizationError(`Bound artifact authorization failed. uuIdentity: ${uuIdentity}, boundArtifactUri=${artifactUri}`, result.error);
    }

    const { authorizedProfiles, identityProfiles } = this._evaluateboundArtifactProfileMap(result, authorizationData.boundArtifactProfileMap, useCase.objectProfileList);

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: authorizedProfiles,
      uuIdentityObjectProfileList: identityProfiles,
      useCaseObjectProfileList: useCase.objectProfileList
    })
  }

  async _authorizeObjectRoleGroupInterface(session, useCase, authorizationData) {
    if (!useCase.objectProfileList) {
      throw new AuthorizationError(`Unable to authorize object. Use case profiles must be defined.`);
    }
    this._validateAuthorizationData(authorizationData, "authorizeObjectRoleGroupInterfaceType");

    const uuIdentity = session.getIdentity().getUuIdentity();

    const profilesToAuthorize = Object.entries(authorizationData.roleGroupUriMap).map(e => ({ profile: e[0], roleGroupUri: e[1] }))
      .sort((a, b) => a.profile.localeCompare(b.profile));

    const cacheKey = `${uuIdentity}|${Digest.sha1(Json.stringify(profilesToAuthorize))}`; // possible optimization - cache each role separately.
    const result = await this._useObjectCacheWrapper(cacheKey,
      async () => {
        return this._loadUserProfilesByRoleGroupInterface("", session, uuIdentity, null, profilesToAuthorize);
      },
      (r) => useCase.objectProfileList.some(p => r.userProfiles.includes(p)));

    const identityProfiles = result.userProfiles;
    const authorizedProfiles = useCase.objectProfileList.filter((useCaseProfile) => identityProfiles.includes(useCaseProfile));

    if (authorizedProfiles.length < 1 && !result.resultComplete) {
      throw new AuthorizationError(`Role group interface authorization failed. uuIdentity: ${uuIdentity}, roleGroupUriMap=${JSON.stringify(authorizationData.roleGroupUriMap)}`, result.error);
    }

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: authorizedProfiles,
      uuIdentityObjectProfileList: identityProfiles,
      useCaseObjectProfileList: useCase.objectProfileList
    })
  }

  async _authorizeObjectUuIdentityList(session, useCase, authorizationData) {
    if (!useCase.objectProfileList) {
      throw new AuthorizationError(`Unable to authorize object. Use case profiles must be defined.`);
    }
    this._validateAuthorizationData(authorizationData, "authorizeObjectUuIdentityListType");

    const uuIdentity = session.getIdentity().getUuIdentity();
    const identityProfiles = authorizationData.permissionMap[uuIdentity] || [];
    const authorizedProfiles = useCase.objectProfileList.filter((useCaseProfile) => identityProfiles.includes(useCaseProfile));

    return new WorkspaceAuthorizationResult({
      uuIdentity,
      useCase: useCase.name,
      objectAuthorizationStrategy: authorizationData.authorizationStrategy,
      authorizedObjectProfileList: authorizedProfiles,
      uuIdentityObjectProfileList: identityProfiles,
      useCaseObjectProfileList: useCase.objectProfileList
    });
  }

  _evaluateboundArtifactProfileMap(authorizationResult, permissionMatrix, objectProfileList) {
    const authorizedProfiles = new Set();
    const identityProfiles = new Set();

    authorizationResult.userAppTypeProfiles.forEach((uuAppTypeProfile) => {
      if (Object.prototype.hasOwnProperty.call(permissionMatrix, uuAppTypeProfile)) {
        if (!(permissionMatrix[uuAppTypeProfile] instanceof Array)) {
          return;
        }

        permissionMatrix[uuAppTypeProfile].forEach((boundProfile) => {
          identityProfiles.add(boundProfile);

          if (objectProfileList.includes(boundProfile)) {
            authorizedProfiles.add(boundProfile);
          }
        });
      }
    });

    return { authorizedProfiles: Array.from(authorizedProfiles), identityProfiles: Array.from(identityProfiles) };
  }

  async _getUserProfiles(awid, uuIdentity, session, authorizationStrategy, useCache = true) {
    let cacheKey = `${awid}|${uuIdentity}`;
    let result = this._userProfileCache.get(cacheKey);
    if (!useCache || !result) {
      let authorizationResult = await this._mutex.runOneAtTime(cacheKey, this._loadUserProfiles.bind(this), awid, uuIdentity, session, authorizationStrategy);
      result = { userProfiles: new Set(authorizationResult.userProfiles), authorizationStrategy: authorizationResult.authorizationStrategy, authorizationTime: Date.now() };
      if (authorizationResult.resultComplete && authorizationResult.doCache) {
        this._userProfileCache.set(cacheKey, result);
      } else if (!authorizationResult.resultComplete && result.userProfiles.size === 0) {
        throw new AuthorizationError(`Unable to load profiles of user ${uuIdentity}`);
      }
    }
    return result;
  }

  async _loadUserProfiles(awid, uuIdentity, session, authorizationStrategy = null) {
    let userProfiles = [];
    let resultComplete = true;
    let doCache = true;
    let authzArtifactUri = null;

    // Load system profiles and authorization type
    if (ProfileConfig.isPrivilegedCall(awid)) {
      // Cache result only in case asid exists
      try {
        await AppInstanceComponent.get(awid);
      } catch (e) {
        doCache = false;
      }
      userProfiles.push(...ProfileConfig.getPrivilegedUserProfiles(awid, uuIdentity));
      authorizationStrategy = DEFAULT_ASID_AUTHZ_STRATEGY;
    } else {
      let appWorkspace = await SysAppWorkspaceAbl.get(awid);
      if (appWorkspace["awidLicenseOwnerList"] && appWorkspace["awidLicenseOwnerList"].includes(uuIdentity)) {
        userProfiles.push("AwidLicenseOwner");
      }
      authorizationStrategy = authorizationStrategy || appWorkspace["authorizationStrategy"] || DEFAULT_AUTHZ_STRATEGY;
      authzArtifactUri = appWorkspace["artifactUri"];
      // Cache result only in case workspace is not in created state
      doCache = appWorkspace.sysState && appWorkspace.sysState !== CREATED_SYS_STATE;
    }

    // Load profiles from permissions
    let result = await this._loadProfilesByPermissions(awid, uuIdentity);
    userProfiles.push(...result.userProfiles);
    resultComplete = resultComplete && result.resultComplete;

    // Load profiles based on authorization type
    result = null;
    switch (authorizationStrategy) {
      case "roleGroupInterface":
        try {
          result = await this._loadUserProfilesByRoleGroupInterface(awid, session, uuIdentity, userProfiles);
        } catch (e) {
          logger.error(`RoleGroupInterface authorization of user ${uuIdentity} failed.`, e);
          resultComplete = false;
        }
        break;
      case "artifact":
        try {
          result = await this._loadUserProfilesByArtifact(session, uuIdentity, authzArtifactUri);
        } catch (e) {
          logger.error(`Artifact authorization of user ${uuIdentity} failed.`, e);
          resultComplete = false;
        }
        break;
      case "boundArtifact":
        //TODO: boundArtifact authorization strategy
        break;
    }
    if (result) {
      userProfiles.push(...result.userProfiles);
      resultComplete = resultComplete && result.resultComplete;
    }

    return { userProfiles, resultComplete, doCache, authorizationStrategy };
  }

  async _loadProfilesByPermissions(awid, uuIdentity) {
    let userProfiles = [];
    let resultComplete = true;

    try {
      let permissionProfiles = await SysPermissionAbl.getProfileCodesForUser(awid, uuIdentity);
      if (permissionProfiles && permissionProfiles.length > 0) {
        userProfiles.push(...permissionProfiles[0]["profileList"]);
      }
    } catch (e) {
      logger.error(`Loading of permissions for for user ${uuIdentity} failed.`, e);
      resultComplete = false;
    }

    return { userProfiles, resultComplete };
  }

  async _loadUserProfilesByRoleGroupInterface(awid, session, uuIdentity, knownUserProfiles, loadedProfiles) {
    let userProfiles = [];
    let resultComplete = true;

    if (!loadedProfiles) {
      let allProfiles = await SysProfileAbl.getAppProfileListByAwid(awid);
      let remainingProfiles = allProfiles.filter(profile => !knownUserProfiles.includes(profile));
      loadedProfiles = (await SysProfileAbl.getAppProfileList(awid, remainingProfiles)).itemList;
    }

    let roleGroupProfileMap = {};
    loadedProfiles.forEach(({ profile, roleGroupUri }) => {
      if (!roleGroupUri) {
        return;
      }
      if (roleGroupUri === GGALL) {
        userProfiles.push(profile);
        return;
      }
      if (roleGroupUri === GGPLUS4U && uuIdentity !== ANONYMOUS_USER) {
        userProfiles.push(profile);
        return;
      }
      let personalRoleUri = this._getPersonalRoleUri(roleGroupUri, uuIdentity);
      if (personalRoleUri && roleGroupUri === personalRoleUri) {
        userProfiles.push(profile);
        return;
      }
      let profileCodes = roleGroupProfileMap[roleGroupUri];
      if (profileCodes) {
        profileCodes.push(profile);
      } else {
        profileCodes = [profile];
        roleGroupProfileMap[roleGroupUri] = profileCodes;
      }
    });

    let profileGroups = Object.keys(roleGroupProfileMap);
    if (uuIdentity === ANONYMOUS_USER || profileGroups.length === 0) {
      return { userProfiles, resultComplete }
    }

    let error;
    try {
      let result = await this._castService.verifyCastExistence(session, profileGroups);
      resultComplete = resultComplete && result.resultComplete;
      error = result.error;
      result.forEach(resultEntry => {
        profileGroups.forEach(profileGroup => {
          if (profileGroup === resultEntry.role || UuOs8UriHelper.equalUris(profileGroup, resultEntry.role)) {
            userProfiles.push(...roleGroupProfileMap[profileGroup]);
          }
        });
      });
    } catch (e) {
      logger.error(`Loading of profiles for for user ${uuIdentity} failed.`, e);
      resultComplete = false;
      error = e;
    }

    return { userProfiles, resultComplete, error };
  }

  _getPersonalRoleUri(roleUri, uuIdentity) {
    let personalRole = null;
    if (roleUri.indexOf("ues:") === 0) {
      let terrCode = UuOs8UriHelper.getTerritoryCode(roleUri);
      personalRole = `ues:${terrCode}:${uuIdentity}`;
    }

    return personalRole;
  }

  async _loadUserProfilesByArtifact(session, uuIdentity, authzArtifactUri, useCase) {
    let userProfiles = [];
    let userAppTypeProfiles = [];
    let authorizedAppTypeProfiles = [];
    let ucAppTypeProfiles = [];
    let resultComplete = true;
    let error;

    if (!authzArtifactUri) {
      logger.error("Artifact authorization: Trying to use artifact authorization when artifactUri is not set.");
      return { userProfiles, resultComplete };
    }

    let uriBuilder;
    try {
      uriBuilder = UriBuilder.parse(authzArtifactUri);
      uriBuilder.setUseCase("uuArtifactIfc/authorizeMe");
      uriBuilder.setParameter("type", "full");
      if (useCase) {
        uriBuilder.setParameter("useCase", useCase);
      }
      let result = await AppClient.get(uriBuilder.toUri(), null, { session, requestTimeout: this._authTimeout });
      if (result.userUuAppProfileList) {
        userProfiles.push(...result.userUuAppProfileList);
      }
      if (result.userUuAppTypeProfileList) {
        userAppTypeProfiles.push(...result.userUuAppTypeProfileList);
      }
      if (result.uuAppTypeProfileList) {
        authorizedAppTypeProfiles.push(...result.uuAppTypeProfileList);
      }
      if (result.ucUuAppTypeProfileList) {
        ucAppTypeProfiles.push(...result.ucUuAppTypeProfileList);
      }
    } catch (e) {
      if (e.status === 403 || e.code === "uu-businessterritory-maing01/authorization/accessDenied"
        || e.code === "uu-appg01/authorization/accessDenied"
        || e.code === "uu-myterritory-maing01/authorization/accessDenied") {
        logger.debug(`User ${uuIdentity} has no profile for artifact (authorization uri: ${uriBuilder}).`, e);
      } else {
        logger.error(`Loading of profiles for user ${uuIdentity} failed (authorization uri: ${uriBuilder}).`, e);
        resultComplete = false;
        error = e;
      }
    }

    return { userProfiles, userAppTypeProfiles, authorizedAppTypeProfiles, ucAppTypeProfiles, resultComplete, error };
  }

  _validateAuthorizationData(authorizationData, validationType) {
    let validationResult = this.validator.validate(validationType, authorizationData);

    try {
      ValidationHelper.processValidationResult(
        authorizationData,
        validationResult,
        `${WorkspaceAuthorizationErrors.UC_CODE}/unsupportedKeys`,
        WorkspaceAuthorizationErrors.InvalidAuthorizationDataError
      );
    } catch (e) {
      throw new AuthorizationError(`Unable to authorize object. Authorization data are not valid. (paramMap: ${Json.stringify(e.paramMap)})`)
    }
  }

  _buildArtifactUri(awscArtifactUri, id, code) {
    const artifactUriBuilder = UriBuilder.parse(awscArtifactUri).clearParameters();
    if (id) {
      artifactUriBuilder.setParameter("id", id);
    } else {
      artifactUriBuilder.setParameter("code", code);
    }
    return artifactUriBuilder.toUri();
  }

  async _useObjectCacheWrapper(cacheKey, getResultFn, isPositiveResultFn) {
    let cacheResult = this._objectUserProfileCache.get(cacheKey);

    let authorizationResult;
    // resolve negative cache -> use cache only if its age is lower than negative ttl or it is positive result
    if (cacheResult && ((Date.now() - cacheResult.authorizationTime < this._objectUserProfileNegativeCacheTtl) || isPositiveResultFn(cacheResult.authorizationResult))) { // resolve negative cache
      authorizationResult = cacheResult.authorizationResult;
    }
    if (!authorizationResult) {
      authorizationResult = await this._mutex.runOneAtTime(cacheKey, getResultFn);
      if (authorizationResult.resultComplete) {
        this._objectUserProfileCache.set(cacheKey, { authorizationResult, authorizationTime: Date.now() });
      }
    }

    return authorizationResult;
  }

}

// Register default uuAppWorkspace authorization service
WorkspaceAuthorizationService.create(DEFAULT_SERVICE_NAME);

module.exports = WorkspaceAuthorizationService;
