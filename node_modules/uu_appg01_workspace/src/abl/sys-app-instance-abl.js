"use strict";

const { LruCache, Config } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ObjectStoreError, ObjectNotFound, Lock, ObjectLocked } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AppClient } = require("uu_appg01_server-client");
const UuCmdHelper = require("../helpers/uu-cmd-helper");

const Errors = require("../api/errors/sys-app-instance-errors");
const OidcClientHelper = require("../helpers/oidc-client-helper");
const AppClientTokenService = require("../app-client-token-service");
const ProfileConfig = require("../helpers/profile-config.js");
const SysProfile = require("./sys-profile-abl");
const SysAppClientTokenAbl = require("./sys-app-client-token-abl");
const SysAppPermission = require("./sys-permission-abl");
const SysDataStoreStats = require("./sys-app-data-store-stats-abl");

const LOCK_CODE = "sysAppInstanceInitLock";
const LOCK_DURATION = 60 * 5;
const APP_INSTANCE_CACHE_TTL_CONFIG_NAME = "uu_app_workspace_app_instance_cache_ttl";
const APP_INSTANCE_CACHE_TTL_DEFAULT_VALUE = 1000 * 60 * 5;

const SYS_APP_INSTANCE_VERSION = "3.0";

const WARNINGS = {
  sysAppInstanceNotProperlyCreated: {
    code: `${Errors.Init.UC_CODE}sysAppInstanceNotProperlyCreated`,
    message: "The uuAppInstance has not been created properly."
  }
};

/**
 * represent sysAppConfig collection in the database
 * and store configuration of the workspace
 */
class SysAppInstanceAbl {
  constructor() {
    // Initialize cache with TTL 5 minutes if is not configured, configuration is in seconds
    let maxAge =
      Config.get(APP_INSTANCE_CACHE_TTL_CONFIG_NAME) != null
        ? Config.get(APP_INSTANCE_CACHE_TTL_CONFIG_NAME) * 1000
        : APP_INSTANCE_CACHE_TTL_DEFAULT_VALUE;
    this.configCache = new LruCache({ maxAge });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysUuSubAppInstance");
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppInstanceAbl");

    this.SYS_STATES = {
      CREATED: "created",
      ACTIVE: "active",
      RESTRICTED: "restricted",
    }
  }

  /**
   * Initializes system schemas (SysAppInstance) of application server.
   *
   * @param {Object} params
   * @param {String} params.asid
   * @param {Object} params.dtoIn
   * @param {Object} params.ucUri
   * @param {Object} params.authorizationResult
   * @param {String} params.uuIdentity
   * @param {Object} params.appClientToken
   * @returns {Promise<Object>} uuObject sysAppInstance
   */
  async init({ asid, dtoIn, ucUri, authorizationResult, uuIdentity, appClientToken }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceInitDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Init.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.Init.InvalidDtoInError // A2 - failed dtoIn validation
    );

    // HDS 1.4. - Keys that are missing from dtoIn and a default value is required for them (see default values table),

    if (!dtoIn.sysState) {
      // set default value
      dtoIn.sysState = this.SYS_STATES.RESTRICTED;
    }
    dtoIn.version = SYS_APP_INSTANCE_VERSION;

    // HDS 2. - Checks if the caller has rights to initialize an appInstance. One of the following conditions must be met:
    // HDS 2.1. - The caller is the AsidLicenseOwner.
    // HDS 2.2. - baseRegistryUri is loaded from deployment config and uuAppClientToken is validated (using baseRegistryUri).
    const configBaseRegistryUri = Config.get("base_registry_uri");

    if (authorizationResult.isAuthorizationEnabled()) {
      if (authorizationResult.getAuthorizedProfiles().length === 0) {
        let isValid = false;
        if (appClientToken) {
          if (!configBaseRegistryUri) {
            // A4
            throw new Errors.Init.ApplicationIsNotAuthorized({ uuAppErrorMap });
          } else {
            try {
              isValid = await AppClientTokenService.isTokenValid(
                ucUri,
                appClientToken,
                UriBuilder.parse(configBaseRegistryUri).toUri()
              );
            } catch (e) {
              // A5
              throw new Errors.Init.ApplicationSignatureCheckFailed(
                { uuAppErrorMap },
                {
                  uuAppClientToken: appClientToken._original
                    .split(".")
                    .slice(0, 2)
                    .join(".")
                },
                e
              );
            }
          }
        }

        if (!isValid) {
          let paramMap = {
            uuIdentity
          };

          if (appClientToken) {
            paramMap.appClientToken = appClientToken._original
              .split(".")
              .slice(0, 2)
              .join(".");
          }
          // A3
          throw new Errors.Init.UserIsNotAuthorized({ uuAppErrorMap }, paramMap);
        }
      }
    }

    // HDS 3. - System initializes a new key pair using AppComponent method AppClientToken.initKeys.
    await SysAppClientTokenAbl.initKeys(asid);

    // HDS 4. - If dtoIn contains baseRegistryUri, system calls sys/appClientToken/listKeys to verify that baseRegistryUri is valid.
    if (dtoIn.baseRegistryUri) {
      let baseUri = UriBuilder.parse(dtoIn.baseRegistryUri)
        .toUri()
        .getBaseUri();
      let uri = UriBuilder.parse(baseUri).setUseCase("sys/appClientToken/listKeys");
      try {
        await AppClient.get(uri.toString());
      } catch (e) {
        // A6
        throw new Errors.Init.BaseRegistryUriVerificationFailed(
          { uuAppErrorMap },
          { baseRegistryUri: dtoIn.baseRegistryUri },
          e
        );
      }
    }

    // HDS 5. - Verifies, that there is no uuObject sysAppInstance with given asid in uuAppObject store.
    let appInstance = await this.dao.getByAsid(asid);

    if (appInstance) {
      if (appInstance.sysState !== this.SYS_STATES.CREATED) {
        // A7
        throw new Errors.Init.SysUuSubAppInstanceIsAlreadyInitialized({ uuAppErrorMap }, { asid });
      } else {
        try {
          let lock = new Lock(LOCK_CODE, LOCK_DURATION);
          await this.dao.lockOne(asid, lock);
        } catch (e) {
          // A8
          if (e instanceof ObjectLocked) {
            throw new Errors.Init.SysAppInstanceAlreadyCreatedAndLocked({ uuAppErrorMap }, { asid });
          }
          throw e;
        }
        // A9
        ValidationHelper.addWarning(
          uuAppErrorMap,
          WARNINGS.sysAppInstanceNotProperlyCreated.code,
          WARNINGS.sysAppInstanceNotProperlyCreated.message
        );

        let lock = new Lock(LOCK_CODE, LOCK_DURATION);
        await this.dao.unlockOne(asid, lock);
        await this.dao.deleteByAsid(asid);
        await SysProfile.deleteAllAppProfiles(asid);
      }
    }

    //HDS 6. - Creates schemas and indexes for uuAppInstance and uuAppWorkSpace and uuAppClientToken -
    // SysAppInstance, SysAppWorkspace, SysProfile, SysPermission, SysUuAppSecret. (dao method createSchema).
    await this.dao.createSchema();
    const schemas = [
      "sysUuSubAppInstance",
      "sysUuAppWorkspace",
      "sysProfile",
      "sysPermission",
      "sysUuAppSecret",
      "sysUuAppDataStoreStats",
      "sysImportMapping"
    ];
    let schemaCreateResults = schemas.map(async schema => {
      try {
        return await DaoFactory.getDao(schema).createSchema();
      } catch (e) {
        // A9
        throw new Errors.Init.CreateSchemaDaoFailed({ uuAppErrorMap }, e);
      }
    });
    await Promise.all(schemaCreateResults);

    // HDS 7. - BaseRegistryUri value is loaded from dtoIn. If the value is missing, it is loaded from deployment configuration.
    let baseRegistryUri = dtoIn.baseRegistryUri || configBaseRegistryUri;

    // HDS 8. - In case name, description are missing in dtoIn, the values are loaded from uuBaseRegistry
    // through its interface uuSubAppInstance/get with asid parameter. (A10)
    // TODO HDS 8

    dtoIn.asid = asid;
    // HDS 9. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 10. - DtoIn is verified, stored into uuObject sysAppInstance in uuAppObjectStore with sysState.state set to "created" and this uuObject is locked.
    let lock = new Lock(LOCK_CODE, LOCK_DURATION);
    let uuObjectCreate = { ...dtoIn };
    uuObjectCreate.baseRegistryUri = baseRegistryUri;
    delete uuObjectCreate.uuAppProfileAsidAuthorities;
    uuObjectCreate.sysState = this.SYS_STATES.CREATED;
    try {
      await this.dao.create(uuObjectCreate, lock);
    } catch (e) {
      // A12
      if (e instanceof ObjectStoreError) {
        throw new Errors.Init.SysUuSubAppInstanceDaoCreateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // HDS 11. - Creates uuObject sysProfile for each profile defined in asid profileList in profiles.json.
    const profileCodes = ProfileConfig.getPrivilegedProfiles(asid);
    try {
      await SysProfile.initProfiles(asid, profileCodes);
    } catch (e) {
      // A13
      throw new Errors.Init.SysProfileDaoCreateFailed({ uuAppErrorMap }, e);
    }

    // HDS 12. - Sets roleGroupUri in AsidAuthorities profile (uuObject sysProfile).
    // Value from dtoIn.uuAppProfileAsidAuthorities is used and uuObject is updated.
    if (dtoIn.uuAppProfileAsidAuthorities.startsWith("urn:uuIdentity:")) {
      let uuIdentity = dtoIn.uuAppProfileAsidAuthorities.replace("urn:uuIdentity:", "");
      await SysAppPermission.create(asid, { profile: "AsidAuthorities", uuIdentityList: [uuIdentity] });
    } else {
      try {
        const asidAuthoritiesProfile = await SysProfile.getProfileByCode(asid, "AsidAuthorities");
        asidAuthoritiesProfile.roleGroupUri = dtoIn.uuAppProfileAsidAuthorities;
        await SysProfile.update(asidAuthoritiesProfile);
      } catch (e) {
        // A14
        throw new Errors.Init.SysProfileDaoUpdateFailed({ uuAppErrorMap }, e);
      }
    }

    // Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
    try {
      await SysDataStoreStats.create(asid);
    } catch (e) {
      // A14
      throw new Errors.Init.SysUuAppInstanceDataStoreStatsDaoCreateFailed({ uuAppErrorMap }, e);
    }

    // HDS 14. - Updates state in uuBaseRegistry to "active" using uuBaseRegistryinterface uuSubAppInstance/activate. (A15, A16)
    // TODO HDS 14

    // HDS 15. - Sets sysState.state of uuObject sysAppInstance to dtoIn.sysState.state value and unlocks it.
    let uuObjectUpdate = { asid, sysState: dtoIn.sysState };
    let dtoOut;
    try {
      await this.dao.update(uuObjectUpdate, lock);
      dtoOut = await this.dao.unlockOne(asid, lock);
    } catch (e) {
      // A18
      throw new Errors.Init.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, e);
    }

    // HDS 13. - If the application is running in production mode,
    // the OIDC client is initialized via uuCmd oidc/initOidcClient.
    await OidcClientHelper.initOidcClient(asid, uuAppErrorMap, this.logger); // A15

    // HDS 16. - Returns properly filled out dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *
   Sets one key of SysAppInstance uuObject to given value.
   Avoid setting the system attributes (described on SysAppInstance schema page).
   It might break functionality of uuAppWorkspace library.
   * @param {string} asid
   * @param {string} key
   * @param {string} value
   * @returns {Promise<*>}
   */

  async setConfigParameter(asid, key, value) {
    const dtoIn = {
      asid,
      key
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("setConfigInstanceParameterDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetConfigParameter.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.SetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - Updates sysAppInstance uuObject in uuAppObjectStore (sysAppInstance DAO update) (A2, A3)
    let appInstance;
    let uuOject = { asid };
    uuOject[key] = value;
    try {
      appInstance = await this.dao.update(uuOject);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A2
        throw new Errors.SetConfigParameter.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e instanceof ObjectStoreError) {
        // A3
        throw new Errors.SetConfigParameter.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCacheByAsid(appInstance);

    // HDS 3. - Returns properly filled dtoOut.
    appInstance.uuAppErrorMap = uuAppErrorMap;
    return appInstance;
  }

  /**
   *
   Gets a value of SysAppInstance uuObject for given key.
   * @param {string} asid
   * @param {string} key
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */

  async getConfigParameter(asid, key, uuAppErrorMap = {}) {
    const dtoIn = {
      asid,
      key: key
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("getConfigInstanceParameterDtoInType", dtoIn);
    ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      Errors.GetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - System loads asid from application configuration.
    // HDS 3. - System loads uuObject sysAppInstance from cache. (A2)
    // HDS 4. - System reads value of attribute given in dtoIn.key. (A4)
    let dtoOut = (await this.get(asid))[key]; // A2, A4

    // HDS 5. - Returns properly filled dtoOut.
    return dtoOut === undefined ? null : dtoOut;
  }

  /**
   * Returns application instance.
   *
   * @param {String} asid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async get(asid, uuAppErrorMap = {}) {
    // HDS 1. - System loads uuObject sysAppInstance from cache.
    let appInstance = this.configCache.get(asid);

    // HDS 1.1. - If cache doesn't exist,
    // loads uuObject sysAppInstance from uuAppObjectStore by uuAppInstance DAO getByAsid.
    if (!appInstance) {
      // A1
      appInstance = await this.dao.getByAsid(asid);
      if (!appInstance) {
        // A2
        throw new Errors.Get.SysUuSubAppInstanceDoesNotExistError({ uuAppErrorMap }, { asid });
      }

      // HDS 1.2. - Adds uuObject to the cache.
      this._updateCacheByAsid(appInstance);
    }

    // HDS 2. - Returns properly filled dtoOut.
    appInstance.uuAppErrorMap = uuAppErrorMap;
    return appInstance;
  }

  /**
   * Sets basic properties of uuSubAppInstance like name and description.
   * It does not allow to change properties connected with business logic as version/capacity/licenseOwner etc.
   *
   * @param {String} asid
   * @param {Object} dtoIn
   * @param {Object} uuIdentity
   * @returns {Promise<*>}
   */
  async set(asid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      // A1, A2
      dtoIn,
      validationResult,
      `${Errors.Set.UC_CODE}unsupportedKeys`,
      Errors.Set.InvalidDtoIn
    );

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    // HDS 3. - Verified dtoIn is saved to the uuAppObjectStore.
    let dtoOut;
    dtoIn.asid = asid;
    try {
      dtoOut = await this.dao.update(dtoIn);
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        // A3
        throw new Errors.Set.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e.cause instanceof ObjectStoreError) {
        // A4
        throw new Errors.Set.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCacheByAsid(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppInstance.
   *
   * @param {String} asid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setActiveSysState(asid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetActiveSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetActiveSysState.UC_CODE}unsupportedKeys`, // A1
      Errors.SetActiveSysState.InvalidDtoIn // A2
    );

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity
    // and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppInstance.sysState to active, updates sysAppInstance uuObject
    // (sysAppInstance DAO update) and updates cache. (TTL set to 5 minutes) (A3, A4)
    let dtoOut;
    try {
      let appInstance = { ...dtoIn };
      appInstance.asid = asid;
      appInstance.sysState = this.SYS_STATES.ACTIVE;
      dtoOut = await this.dao.update(appInstance);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetActiveSysState.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetActiveSysState.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCacheByAsid(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set uuAppInstance sysState to restricted.
   *
   * @param {String} asid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setRestrictedSysState(asid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuSubAppInstanceSetRestrictedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetRestrictedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetRestrictedSysState.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. -
    // System sets sysAppInstance.sysState to restricted, updates sysAppInstance uuObject
    // (sysAppInstance DAO update) and updates cache. (TTL set to 5 minutes) (A3, A4)
    let dtoOut;
    try {
      let appInstance = { ...dtoIn };
      appInstance.asid = asid;
      appInstance.sysState = this.SYS_STATES.RESTRICTED;
      dtoOut = await this.dao.update(appInstance);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetRestrictedSysState.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetRestrictedSysState.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCacheByAsid(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Return appInstance object by given asid.
   *
   * @param {String} asid
   * @returns {Promise<*>}
   */
  async getByAsid(asid) {
    return await this.dao.getByAsid(asid);
  }

  /**
   * update appInstance with asid in the cache.
   *
   * @param {Object} appInstance
   */
  _updateCacheByAsid(appInstance) {
    if (this.SYS_STATES.CREATED !== appInstance.sysState) {
      this.configCache.set(appInstance.asid, appInstance);
    }
  }

  /**
   * reset cache
   */
  clearCache() {
    this.configCache.clear();
  }
}

module.exports = new SysAppInstanceAbl();
