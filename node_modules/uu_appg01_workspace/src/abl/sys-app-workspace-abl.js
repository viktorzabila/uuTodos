"use strict";

const { Config, LruCache } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { DaoFactory, ObjectStoreError, ObjectNotFound, Lock, ObjectLocked } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { AppClient } = require("uu_appg01_core-appclient");
const { UriBuilder } = require("uu_appg01_core-uri");
const { AuthorizationService } = require("uu_appg01_core-authorization");

const SysProfile = require("./sys-profile-abl");
const SysPermission = require("./sys-permission-abl");
const SysAppInstance = require("./sys-app-instance-abl");
const SysAppClientTokenAbl = require("./sys-app-client-token-abl");
const SysDataStoreStats = require("./sys-app-data-store-stats-abl");
const ProfileConfig = require("../helpers/profile-config.js");
const AppClientTokenService = require("../app-client-token-service");
const Errors = require("../api/errors/sys-app-workspace-errors.js");
const AppClientTokenErrors = require("../api/errors/sys-app-client-token-errors");
const OidcClientHelper = require("../helpers/oidc-client-helper");
const UuCmdHelper = require("../helpers/uu-cmd-helper");

const DEFAULT_SERVICE_NAME = "uu_appg01_workspace";
const DEFAULT_AUTHORIZATION_STRATEGY = "roleGroupInterface";
const ART_AUTHZ_TYPE = "artifact";
const APP_WORKSPACE_CACHE_TTL_CONFIG_NAME = "uu_app_workspace_app_workspace_cache_ttl";
const APP_WORKSPACE_CACHE_TTL_DEFAULT_VALUE = 1000 * 60 * 5;
const SYS_APP_WORKSPACE_VERSION = "3.0";
const DEFAULT_MAX_NOA = 1000;

/**
 * represent sysAppWorkspace collection in the database
 * and store information about workspace
 */
class SysAppWorkspaceAbl {
  constructor() {
    // Initialize cache with TTL 5 minutes if is not configured, configuration is in seconds
    let maxAge =
      Config.get(APP_WORKSPACE_CACHE_TTL_CONFIG_NAME) != null
        ? Config.getNumber(APP_WORKSPACE_CACHE_TTL_CONFIG_NAME) * 1000
        : APP_WORKSPACE_CACHE_TTL_DEFAULT_VALUE;
    this.sysAppCache = new LruCache({ maxAge });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysUuAppWorkspace");
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppWorkspaceAbl");
    this.LOCK_CODE = "sysAppInstanceInitLock";
    this.LOCK_DURATION = 60 * 5;

    this.SYS_STATES = {
      REGISTERED: "registered",
      CREATED: "created",
      ACTIVE: "active",
      RESTRICTED: "restricted",
      READ_ONLY: "readOnly",
      SUSPENDED: "suspended",
      CLOSED: "closed"
    };
  }

  /**
   * create empty collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  /**
   * creates new workspace
   * create sysAppWorkspace, sysAppWorkspaceConfig, sysPermission and sysProfile collections
   * and fill them with initialize values like profiles from profiles.json
   * @param {Object} ucUri
   * @param {Object} dtoIn
   * @param {Object} authzResult
   * @param {Object} uuIdentity
   * @param {Object} appClientToken
   * @returns {Promise<{}>}
   */
  async create({ ucUri, dtoIn, authzResult, uuIdentity, appClientToken }) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceCreateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Create.UC_CODE}unsupportedKeys`,
      Errors.Create.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - Loads SysAppInstance and checks whether its sysState.state is set to "active" state.
    let asid = Config.get("asid");
    let sysAppInstance = await SysAppInstance.getByAsid(asid);
    if (!sysAppInstance) {
      // A3
      throw new Errors.Create.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
    }

    // HDS 3. - Checks if the caller has rights to create an appWorkspace. One of the following conditions must be met:
    // HDS 3.1. - The caller belongs to AsidAuthorities profile.
    // HDS 3.2. - baseRegistryUri is loaded from SysAppInstance uuObject and uuAppClientToken is validated (using baseRegistryUri).
    const baseRegistryUri = sysAppInstance.baseRegistryUri;
    if (authzResult.isAuthorizationEnabled()) {
      if (authzResult.getAuthorizedProfiles().length === 0) {
        let isValid = false;
        if (appClientToken && baseRegistryUri) {
          try {
            isValid = await AppClientTokenService.isTokenValid(
              ucUri,
              appClientToken,
              UriBuilder.parse(baseRegistryUri).toUri()
            );
          } catch (e) {
            // A6
            throw new Errors.Create.ApplicationSignatureCheckFailed(
              { uuAppErrorMap },
              {
                uuAppClientToken: appClientToken._original
                  .split(".")
                  .slice(0, 2)
                  .join(".")
              },
              e
            );
          }
        }

        if (!isValid) {
          // A5
          throw new Errors.Create.UserIsNotAuthorized(
            { uuAppErrorMap },
            {
              uuIdentity
            }
          );
        }
      }
    }

    let awid = dtoIn.awid;

    // HDS 4. - Validates whether a value of given awid differs from the asid.
    if (asid === dtoIn.awid) {
      // A7
      throw new Errors.Create.AwidConflictsWithAsid(
        { uuAppErrorMap },
        {
          awid: dtoIn.awid,
          asid: asid
        }
      );
    }

    // HDS 5.- Checks whether there is no other SysAppWorkspace with the given awid already created.
    let appWorkspace = await this.dao.getByAwid(awid);

    if (appWorkspace) {
      if (appWorkspace.sysState !== this.SYS_STATES.REGISTERED) {
        // A8
        throw new Errors.Create.SysUuAppWorkspaceAlreadyCreated({ uuAppErrorMap }, { awid });
      }

      let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);
      try {
        await this.dao.lockOne(awid, lock);
      } catch (e) {
        if (e instanceof ObjectLocked) {
          // A9
          throw new Errors.Create.SysUuAppWorkspaceCreationInProgress({ uuAppErrorMap }, { awid });
        }
        throw e;
      }
      ValidationHelper.addWarning(
        // A10
        uuAppErrorMap,
        `${Errors.Create.UC_CODE}sysAppWorkspaceNotProperlyRegistered`,
        "SysAppWorkspace was not properly registered."
      );

      await this.dao.unlockOne(awid, lock);
      await this.deleteAppWorkspace(awid);
      await SysPermission.deleteByAwid(awid);
      await SysProfile.deleteAllAppProfiles(awid);
    }

    // HDS 6. - In case uuBaseRegistryUri is configured on SysAppInstance and name, description are missing in dtoIn,
    // the values are loaded through uuBaseRegistry uuAppWorkspace/get interface with awid parameter. (A11)
    // TODO impl. missing step

    // HDS 7. - If there is dtoIn.adviceNote, system adds additional information:
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 8. - Verified dtoIn is saved into uuObject sysAppWorkspace in uuAppObjectStore with sysState.state set to "registered" and this uuObject is locked.
    let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);
    let uuObject = dtoIn;

    try {
      uuObject.sysState = this.SYS_STATES.REGISTERED;
      uuObject.authorizationStrategy = DEFAULT_AUTHORIZATION_STRATEGY;
      uuObject.version = SYS_APP_WORKSPACE_VERSION;
      appWorkspace = await this.createUuObject(uuObject, lock);
    } catch (e) {
      // A12
      if (e instanceof ObjectStoreError) {
        throw new Errors.Create.SysUuAppWorkspaceDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // HDS 9. -  Creates the SysProfile uuObject for each profile from the profileList defined in profiles.json.
    let profileCodes = ProfileConfig.getProfiles();
    try {
      await SysProfile.initProfiles(awid, profileCodes);
    } catch (e) {
      // A13
      if (e instanceof ObjectStoreError) {
        throw new Errors.Create.SysProfileDaoCreateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // HDS 10. - Creates the sysDataStoreStats uuObject in the uuAppObjectStore.
    try {
      await SysDataStoreStats.create(awid);
    } catch (e) {
      // A14
      throw new Errors.Create.SysUuAppWorkspaceDataStoreStatsDaoCreateFailedError({ uuAppErrorMap }, e);
    }

    // HDS 11. - Initializes a new key pair using AppComponent method AppClientToken.initKeys.
    await SysAppClientTokenAbl.initKeys(awid); // A16

    // HDS 12. - In case uuBaseRegistryUri is configured on SysAppInstance,
    // updates state in uuBaseRegistry using uuAppWorkspace/setCreated uuBaseRegistry interface.
    //TODO impl. missing step

    // HDS 13. - Sets sysState.state of SysAppWorkspace uuObject to "created" and unlocks it.
    // (through DAO method update) (A16)
    let dtoOut;
    try {
      appWorkspace.sysState = this.SYS_STATES.CREATED;
      await this.dao.update(appWorkspace, lock);
      dtoOut = await this.dao.unlockOne(awid, lock);
    } catch (e) {
      // A16
      if (e instanceof ObjectStoreError) {
        throw new Errors.Create.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
      }
      throw e;
    }

    // HDS 14. - If the application is started in production mode, the OIDC client is initialized using the uuCmd oidc/initOidcClient
    await OidcClientHelper.initOidcClient(awid, uuAppErrorMap, this.logger); // A17

    // HDS 15. - Returns properly filled out dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * return licenseOwner information
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async getLicenseOwner(awid, uuAppErrorMap = {}) {
    // HDS 1. - Loads sysAppWorkspace from cache. (sysAppWorkspace DAO getByAwid) (A1, A2)
    let appWorkspace;
    try {
      appWorkspace = await this.get(awid, uuAppErrorMap);
    } catch (e) {
      // A2
      throw new Errors.SysGetLicenseOwner.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
    }

    // HDS 2. - Returns properly filled dtoOut.
    let license = {};

    license.awidLicenseOwnerList = appWorkspace["awidLicenseOwnerList"];
    license.uuAppErrorMap = uuAppErrorMap;

    return license;
  }

  /**
   * return workspace information from database
   * @param {Object} dtoIn
   * @returns {Promise<{}>}
   */

  async delete(dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysDeleteAppWorkspaceDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Delete.UC_CODE}unsupportedKeys`,
      Errors.Delete.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - System loads sysAppWorkspace from cache. (A3)
    let awid = dtoIn.awid;
    let sysAppWorkspace;
    try {
      sysAppWorkspace = await this.get(awid); // A3
    } catch (e) {
      if (e instanceof Errors.Get.SysUuAppWorkspaceDoesNotExistError) {
        // A4
        throw new Errors.Delete.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
      throw e;
    }

    // HDS 3. - System checks that sysAppWorkspace is in "closed" state. (A5)
    if (sysAppWorkspace.sysState !== this.SYS_STATES.CLOSED) {
      // A5
      throw new Errors.Delete.SysUuAppWorkspaceNotInProperState(
        { uuAppErrorMap },
        { awid, state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System checks that there is no uuBT artifact connected to the sysAppWorkspace
    // - sysAppWorkspace.uuAWSC is empty. (A6)
    if (sysAppWorkspace.uuAWSC) {
      // A6
      throw new Errors.Delete.UuAwscConnectedToTheSysUuAppWorkspace(
        { uuAppErrorMap },
        {
          awid,
          uuAWSC: sysAppWorkspace.uuAWSC
        }
      );
    }

    // HDS 5. - Gets a list of all uuAppDataStore schemas
    // HDS 6. - System does these steps for each uuAppDataStore schema
    // HDS 6.1. - Gets DAO method according to the schema name.
    for (let [schema, dao] of DaoFactory._daos.entries()) {
      // HDS 6.2. - Creates query and searches for the records according to awid attribute
      let filter = { awid };
      let isBinary = Object.getPrototypeOf(dao.constructor).name === "UuBinaryDao";

      // HDS 6.3 - Based on DAO ancestor the type of schema is determined.
      if (isBinary) {
        // HDS 6.3.2 - uuBinary: gets a list of all uuBinary using DAO find and deletes
        // every uuBinary form that list using DAO deleteOne (including even the locked ones)
        await this._executeDeleteBinary(dao, schema, filter);
      } else {
        // HDS 6.3.1 - uuObject: deletes all records using DAO deleteMany (including even the locked ones)
        await this._executeDeleteMany(dao, schema, filter);
      }
    }

    // HDS 7. - Deletes all uuAppWorkspace cache.
    this.deleteFromCache(awid);

    // HDS 8. - Returns properly filled dtoOut.
    return { uuAppErrorMap };
  }

  async setAuthorizationStrategy(uri, dtoIn, session) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysSetAuthTypeDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAuthorizationStrategy.UC_CODE}unsupportedKeys`,
      Errors.SetAuthorizationStrategy.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - Gets uuIdentity of uuCmd caller and checks, if the uuIdentity has rights to run
    // usecase sys/uuAppWorkspace/setAuthorizationStrategy in given dtoIn.authorizationStrategy. (A3)
    let authzError;
    let authzResult;
    try {
      let authzSvc = AuthorizationService.get(DEFAULT_SERVICE_NAME);
      authzResult = await authzSvc.authorize(session, uri, dtoIn["authorizationStrategy"]);
    } catch (e) {
      authzError = e;
    }

    if (authzError || !authzResult.isAuthorized()) {
      // A3
      throw new Errors.SetAuthorizationStrategy.UserIsNotAuthorizedToChangeAuthStrategy(
        { uuAppErrorMap },
        {
          uuIdentity: session.getIdentity().getUuIdentity(),
          authorizationStrategy: dtoIn["authorizationStrategy"]
        },
        authzError
      );
    }

    // HDS 3. - Sets new sysAppWorkspace.authorizationStrategy to dtoIn.authorizationStrategy value.
    // (sysAppWorkspace DAO update) (A4, A5)
    let appWorkspace = {};
    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, { authorizationStrategy: dtoIn["authorizationStrategy"] });
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        // A4
        throw new Errors.SetAuthorizationStrategy.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid: uri.awid });
      } else if (e.cause instanceof ObjectStoreError) {
        // A5
        throw new Errors.SetAuthorizationStrategy.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(appWorkspace);

    appWorkspace.uuAppErrorMap = uuAppErrorMap;

    // HDS 4. - Returns properly filled dtoOut.
    return appWorkspace;
  }

  async connectArtifact(uri, dtoIn, session) {
    //HDS 1.1, 1.2, 1.3
    let validationResult = this.validator.validate("sysConnectArtifactDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.ConnectArtifact.UC_CODE}unsupportedKeys`,
      Errors.ConnectArtifact.InvalidDtoInError
    );

    //HDS 2
    let appWorkspace = await this.dao.getByAwid(uri.awid);
    if (appWorkspace.sysState === this.SYS_STATES.REGISTERED || appWorkspace.sysState === this.SYS_STATES.CLOSED) {
      throw new Errors.ConnectArtifact.UuAppWorkspaceIsNotInProperStateError(
        { uuAppErrorMap },
        { state: appWorkspace.sysState }
      );
    }

    //HDS 3
    let callUriBuilder = UriBuilder.parse(dtoIn["artifactUri"]);
    callUriBuilder.setUseCase("uuAwsc/connectAppWorkspace");
    const callUri = callUriBuilder.toUri();

    let appClientToken;
    try {
      appClientToken = await AppClientTokenService.createToken(uri, callUri);
    } catch (e) {
      if (e instanceof AppClientTokenErrors.GetPrivateKey.KeysNotInitialized) {
        throw new Errors.ConnectArtifact.TokenCreateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }

    //HDS 4
    if (dtoIn.synchronizeArtifactBasicAttributes == null) {
      dtoIn.synchronizeArtifactBasicAttributes = false;
    }

    let parameters = {
      id: callUri.getParameters().id,
      code: callUri.getParameters().code,
      uuAppWorkspaceUri: UriBuilder.parse(uri)
        .setUseCase(null)
        .toString(),
      synchronizeArtifactBasicAttributes: dtoIn.synchronizeArtifactBasicAttributes
    };

    let scope;
    if (typeof session.getCallTokenScope === "function") {
      scope = await session.getCallTokenScope(callUri);
    } else {
      scope = callUri.toString().split("?")[0];
    }
    let headers = {};
    headers["Authorization"] = await session.getCallToken(scope);

    const callOpts = AppClientTokenService.setToken({ headers }, appClientToken);

    try {
      await AppClient.post(callUri, parameters, callOpts);
    } catch (e) {
      throw new Errors.ConnectArtifact.UuCmdConnectAppWorkspaceCallFailedError({ uuAppErrorMap }, e);
    }

    //HDS 5
    let workspace = {
      artifactUri: dtoIn["artifactUri"],
      authorizationStrategy: ART_AUTHZ_TYPE
    };

    try {
      appWorkspace = await this.dao.updateByAwid(uri.awid, workspace);
    } catch (e) {
      throw new Errors.ConnectArtifact.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, e);
    }

    this._updateCache(appWorkspace);

    appWorkspace = { ...appWorkspace, ...{ uuAppErrorMap } };

    //HDS 6
    return appWorkspace;
  }

  /**
   * Provides information about an application workspace.
   *
   * @param {String} awid
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async get(awid, uuAppErrorMap = {}) {
    // HDS 1. - System loads uuObject sysAppWorkspace from cache
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 1. A1.1 - If cache doesn't exist, loads uuObject sysAppWorkspace from uuAppObjectStore by sysAppWorkspace DAO getByAwid.
    if (!sysAppWorkspace) {
      sysAppWorkspace = await this.dao.getByAwid(awid);

      if (!sysAppWorkspace) {
        // A2
        throw new Errors.Get.SysUuAppWorkspaceDoesNotExistError({ uuAppErrorMap }, { awid });
      }
      // HDS 1. A1.2 - Adds uuObject to the cache.
      this._updateCache(sysAppWorkspace);
    }

    // HDS 2. - Returns properly filled dtoOut.
    let dtoOut = { ...sysAppWorkspace };
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Set information about an application workspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async set(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Set.UC_CODE}unsupportedKeys`,
      Errors.Set.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    if (dtoIn.adviceNote) {
      dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);
    }

    // HDS 3. - Verified dtoIn is saved to the uuAppObjectStore (sysAppWorkspace DAO update)
    // and uuObject is updated in cache. (A3, A4)
    let dtoOut = {};
    try {
      let sysAppWorkspace = dtoIn;
      sysAppWorkspace.awid = awid;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.Set.SysUuAppWorkspaceDoesNotExistError({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.Set.SysUuAppWorkspaceDaoUpdateFailedError({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *
   Sets one key of SysAppWorkspace uuObject to given value.
   * @param {string} awid
   * @param {string} key
   * @param {string} value
   * @returns {Promise<*>}
   */

  async setConfigParameter(awid, key, value) {
    const dtoIn = {
      awid,
      key
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("setConfigWorkspaceParameterDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetConfigParameter.UC_CODE}unsupportedKeys`, // A1 - dtoIn contains keys beyond the scope of dtoInType
      Errors.SetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - Updates sysAppWorkspace uuObject in uuAppObjectStore (sysAppWorkspace DAO update) (A2, A3)
    let appWorkspace;
    let uuOject = { awid };
    uuOject[key] = value;
    try {
      appWorkspace = await this.dao.update(uuOject);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A2
        throw new Errors.SetConfigParameter.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A3
        throw new Errors.SetConfigParameter.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    // Update cache
    this._updateCache(appWorkspace);

    // HDS 3. - Returns properly filled dtoOut.
    appWorkspace.uuAppErrorMap = uuAppErrorMap;
    return appWorkspace;
  }

  /**
   *
   Gets a value of SysAppWorkspace uuObject for given key.
   * @param {string} awid
   * @param {string} key
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */

  async getConfigParameter(awid, key, uuAppErrorMap = {}) {
    const dtoIn = {
      awid,
      key: key
    };
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("getConfigWorkspaceParameterDtoInType", dtoIn);
    ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      Errors.GetConfigParameter.InvalidDtoIn // A1 - failed dtoIn validation
    );

    // HDS 2. - System loads awid from application configuration.
    // HDS 3. - System loads uuObject sysAppInstance from cache. (A2)
    // HDS 4. - System reads value of attribute given in dtoIn.key. (A4)
    let dtoOut = (await this.get(awid))[key]; // A2, A4

    // HDS 5. - Returns properly filled dtoOut.
    return dtoOut === undefined ? null : dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the closed state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async close(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceCloseDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Close.UC_CODE}unsupportedKeys`,
      Errors.Close.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("closed") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Close.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (sysAppWorkspace.sysState === this.SYS_STATES.CLOSED) {
      // A5
      throw new Errors.Close.SysUuAppWorkspaceAlreadyClosed(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets the state of uuAppWorkspace to "closed" (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      sysAppWorkspace.sysState = this.SYS_STATES.CLOSED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Close.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.CLOSED
          },
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 5. - System sets the state of uuAppWorkspace to "closed" in uuBaseRegistry.
    // (using uuBaseRegistry/close interface). (A7)
    // TODO impl. missing uuCMD step

    // HDS 6. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the suspended state.
   * Can be called only if uuAppWorkspace is in the active state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async suspend(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSuspendTypeDtoIn", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Suspend.UC_CODE}unsupportedKeys`,
      Errors.Suspend.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("active", "restricted", "readOnly") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Suspend.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (
      !(
        sysAppWorkspace.sysState === this.SYS_STATES.ACTIVE ||
        sysAppWorkspace.sysState === this.SYS_STATES.RESTRICTED ||
        sysAppWorkspace.sysState === this.SYS_STATES.READ_ONLY
      )
    ) {
      // A5
      throw new Errors.Suspend.SysUuAppWorkspaceNotInProperState(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets sysAppWorkspace.previousSysState to current sysAppWorkspace state.
    sysAppWorkspace.previousSysState = sysAppWorkspace.sysState;

    // HDS 5. - System sets the state of uuAppWorkspace to "suspended" (sysAppWorkspace DAO update). (A5)
    let dtoOut;
    try {
      sysAppWorkspace.sysState = this.SYS_STATES.SUSPENDED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Suspend.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.SUSPENDED
          }
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 6. - System sets the state of uuAppWorkspace to "suspended" in uuBaseRegistry. (using uuBaseRegistry/suspend interface). (A6)
    // TODO impl. missing uuCMD step

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Sets uuAppWorkspace to the active state.
   * Can be called only if uuAppWorkspace is in the suspended state.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async resume(dtoIn, uuAppErrorMap) {
    // HDS - 1. Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceResumeTypeDtoIn", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.Resume.UC_CODE}unsupportedKeys`,
      Errors.Resume.InvalidDtoIn
    ); // A1, A2

    // HDS 2. System loads sysAppWorkspace from cache.
    let awid = dtoIn.awid;
    let sysAppWorkspace = this.sysAppCache.get(awid);

    // HDS 3. - System checks whether the state of uuAppWorkspace is set to one of active states
    // ("suspended") (sysAppWorkspace DAO get)
    if (!sysAppWorkspace) {
      // A3
      sysAppWorkspace = await this.dao.getByAwid(awid);
      if (!sysAppWorkspace) {
        // A4
        throw new Errors.Resume.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    if (sysAppWorkspace.sysState !== this.SYS_STATES.SUSPENDED) {
      // A5
      throw new Errors.Resume.sysUuAppWorkspaceNotInSuspendedState(
        { uuAppErrorMap },
        { state: sysAppWorkspace.sysState }
      );
    }

    // HDS 4. - System sets the state of uuAppWorkspace to sysAppWorkspace.previousSysState
    // and deletes this attribute from the uuObject. (A6)
    sysAppWorkspace.sysState = sysAppWorkspace.previousSysState;

    if (!sysAppWorkspace.previousSysState) {
      // A6
      sysAppWorkspace.sysState = this.SYS_STATES.ACTIVE;
    }

    delete sysAppWorkspace.previousSysState;

    // HDS 5. - System sets the state of uuAppWorkspace to "active" (sysAppWorkspace DAO update).
    // and updates cache. (TTL set to 5 minutes) (A7)

    let dtoOut;
    try {
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectStoreError) {
        // A6
        throw new Errors.Suspend.SysUuAppWorkspaceDaoUpdateFailed(
          { uuAppErrorMap },
          {
            awid,
            state: this.SYS_STATES.SUSPENDED
          },
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 6. - System sets the state of uuAppWorkspace to "active" in uuBaseRegistry. (using uuBaseRegistry/activate interface). (A8)
    // TODO impl. missing uuCMD step

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setActiveSysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetActiveSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetActiveSysState.UC_CODE}unsupportedKeys`,
      Errors.SetActiveSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to active and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.ACTIVE;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetActiveSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetActiveSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setRestrictedSysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetRestrictedSysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetRestrictedSysState.UC_CODE}unsupportedKeys`,
      Errors.SetRestrictedSysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity
    // and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to active
    // and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update).
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.RESTRICTED;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetRestrictedSysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetRestrictedSysState.SysUuAppWorkspaceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Allows to set one of the active System States of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {String} uuIdentity
   * @returns {Promise<*>}
   */
  async setReadOnlySysState(awid, dtoIn, uuIdentity) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceSetReadOnlySysStateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetReadOnlySysState.UC_CODE}unsupportedKeys`,
      Errors.SetReadOnlySysState.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - If there is dtoIn.adviceNote, system also sets adviceNote.uuIdentity to caller uuIdentity and adviceNote.startTime to current time.
    dtoIn = UuCmdHelper.fillAdviceNote(dtoIn, uuIdentity);

    // HDS 3. - System sets sysAppWorkspace.sysState to readOnly and updates sysAppWorkspace uuObject (sysAppWorkspace DAO update)
    let dtoOut;
    try {
      let sysAppWorkspace = { ...dtoIn };
      sysAppWorkspace.awid = awid;
      sysAppWorkspace.sysState = this.SYS_STATES.READ_ONLY;
      dtoOut = await this.dao.update(sysAppWorkspace);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        // A3
        throw new Errors.SetReadOnlySysState.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { awid });
      } else if (e instanceof ObjectStoreError) {
        // A4
        throw new Errors.SetReadOnlySysState.SysUuAppWorkspaceDaoUpdateFailedError(
          { uuAppErrorMap },
          {},
          e
        );
      }
      throw e;
    }

    this._updateCache(dtoOut);

    // HDS 4. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * List information about uuAppWorkspaces provided in dtoIn. If dtoIn is empty,
   * command returns every uuAppWorkspace stored in uuAppObjectStore.
   *
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async list(dtoIn, uuAppErrorMap) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppWorkspaceListDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.List.UC_CODE}unsupportedKeys`,
      Errors.List.InvalidDtoIn
    ); // A1, A2

    // HDS 2. - Loads each sysAppWorkspace uuObject (sysAppWorkspace DAO listByStateAndAwidList) from the uuAppObjectStore
    // that corresponds to dtoIn.awidList. In case dtoIn.awidList is empty, system loads every sysAppWorkspace from uuAppObjectStore.
    let list = await this.dao.listByStateListAndAwidList(dtoIn.sysStateList, dtoIn.awidList, dtoIn.pageInfo);

    // HDS 3. - Returns properly filled out dtoOut.
    list.uuAppErrorMap = uuAppErrorMap;
    return list;
  }

  /**
   * update appWorkspace in the cache.
   *
   * @param {Object} appWorkspace
   */
  _updateCache(appWorkspace) {
    if (![this.SYS_STATES.REGISTERED, this.SYS_STATES.CREATED].includes(appWorkspace.sysState)) {
      this.sysAppCache.set(appWorkspace.awid, appWorkspace);
    }
  }

  /**
   * reset whole cache
   */
  clearCache() {
    this.sysAppCache.clear();
  }

  /**
   * deletes item from cache
   */
  deleteFromCache(item) {
    this.sysAppCache.delete(item);
  }

  /**
   * check for NoaLimit and store workspace to the database
   * @param {Object} uuObject
   * @param {Object} lock
   * @returns {Promise<*>}
   */
  async createUuObject(uuObject, lock) {
    await this._checkNoa();
    return await this.dao.create(uuObject, lock);
  }

  /**
   * delete workspace by awid and reset the cache
   * @param {String} awid
   * @returns {Promise<*>}
   */
  async deleteAppWorkspace(awid) {
    this.clearCache();
    return await this.dao.deleteByAwid(awid);
  }

  /**
   * Internal command for retrieving workspaces not in given state but with given awids.
   *
   * @param excludedStateList {Array}
   * @param awidList {Array} - when falsy, list all awids
   * @returns {Array}
   */
  async listByExcludedStateListAndAwidList(excludedStateList, awidList) {
    let appWorkspaces = [];
    let pageIndex = 0;
    let loadedWorkspaces;

    do {
      loadedWorkspaces = await this.dao.listByExcludedStateListAndAwidList(excludedStateList, awidList, {
        pageIndex
      });
      appWorkspaces = appWorkspaces.concat(loadedWorkspaces.itemList);
      pageIndex += 1;
    } while (loadedWorkspaces && appWorkspaces.length < loadedWorkspaces.pageInfo.total);

    return appWorkspaces;
  }

  /**
   * check for Noa limit
   * @returns {Promise<void>}
   * @private
   */
  async _checkNoa() {
    let maxNoa = DaoFactory.getMaxNoa() || DEFAULT_MAX_NOA;
    let awidsCount = await this.dao.getCount();

    if (awidsCount >= maxNoa) {
      throw new Errors.MaximumNumberAwidsError(maxNoa);
    }
  }

  async _executeDeleteMany(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreAbl = require("./sys-dump-restore-abl");
    let dumbDao = SysDumpRestoreAbl._getDumpDao(dao, schema);
    await dumbDao.deleteMany(filter);
  }

  async _executeDeleteBinary(dao, schema, filter) {
    // to avoid circular dependency
    const SysDumpRestoreAbl = require("./sys-dump-restore-abl");
    let dumbDao = SysDumpRestoreAbl._getDumpDao(dao, schema);
    await dumbDao.deleteBinary(filter, schema);
  }
}

module.exports = new SysAppWorkspaceAbl();
