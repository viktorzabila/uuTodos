"use strict";

const { Validator } = require("uu_appg01_core-validation");
const { DaoFactory, ObjectStoreError } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const SysProfile = require("./sys-profile-abl.js");
const InstanceErrors = require("../api/errors/sys-app-instance-errors");
const WorkspaceErrors = require ("../api/errors/sys-app-workspace-errors");
const ErrorHelper = require("../helpers/asid-error-helper");


/**
 * represent sysPermission collection in the database
 * and store created permissions
 */
class SysPermissionAbl {

  constructor() {
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysPermission");
  }

  /**
   * create empty collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  /**
   * Create a new permission for given uuIdentity and application profile.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async create(awid, dtoIn, uuAppErrorMap = {}) {

    // HDS 1. - Performs a logical check of dtoIn.
    let errorClass = ErrorHelper.getErrorClass(awid, InstanceErrors.PermissionCreate, WorkspaceErrors.PermissionCreate);
    let validationResult = this.validator.validate("sysPermissionCreateDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${errorClass.UC_CODE}unsupportedKeys`,
      errorClass["InvalidDtoInError"]
    ); // A1, A2

    // HDS 2. - Checks if given sysProfile with dtoIn.profile exists in uuObjectStore.
    // (using DAO method getByProfile) (A3)
    let profile = await SysProfile.getByAppProfile(awid, dtoIn.profile);

    if (!profile) { // A3
      throw new errorClass["SysProfileDoesNotExistError"]({ uuAppErrorMap }, { profile: dtoIn.profile });
    }

    // HDS 3. - Checks if there are no sysPermissions for uuIdentites from dtoIn.uuIdentityList already created.
    // (sysPremission DAO listByUuIdentityAndAppProfile) (A4)
    let timeNow = new Date();
    let newPermissionList = [];
    let permissionList = await this.dao.listByUuIdentityAndAppProfile(awid, { profileList: [dtoIn.profile] });

    if (typeof dtoIn["uuIdentityList"] === "string") {
      dtoIn["uuIdentityList"] = [dtoIn["uuIdentityList"]];
    }

    dtoIn["uuIdentityList"].forEach(function(uuId) {

      let permission = permissionList["itemList"].find(function(permission) {
        return permission["uuIdentity"] === uuId;
      });

      if (permission) { // A4
        return;
      }

      let newPermission = {
        awid: awid,
        uuIdentity: uuId,
        profile: dtoIn.profile
      };

      // HDS 5. - If there is dtoIn.ttl value,
      // sysPermission.expireAt value must be set to current time plus dtoIn.ttl.
      if (dtoIn["ttl"]) {
        newPermission["expireAt"] = new Date(timeNow.getTime() + dtoIn["ttl"] * 1000);
      }

      newPermissionList.push(newPermission);
    });

    // HDS 4. - Checks that the current count of sysPermission instances (DAO getCount) plus count of newly created permissions (count of uuIdentityList)
    // would be less than or equal to sysPermission.maxNoi
    let actualPermissionsCount = await this.getCount(awid);
    let newCount = actualPermissionsCount + newPermissionList.length;
    if (newCount >= this.dao.maxNoi) { // A5
      throw new errorClass["SysPermissionMaxNumberExceeded"]({ uuAppErrorMap },
        {
        maxNoi: this.dao.maxNoi,
        newNumber: newCount
        });
    }

    // HDS 6. - Creates new sysPermissions for every uuIdentity from edited dtoIn.uuIdentityList.
    let dtoOut = {};

    if (newPermissionList.length === 0) {
      dtoOut["itemList"] = [];
    } else {
      try {
        dtoOut["itemList"] = await this.dao.create(newPermissionList);
      } catch (e) { // A6
        if (e instanceof ObjectStoreError) {
          throw new errorClass["SysPermissionDaoCreateFailedError"]({ uuAppErrorMap }, e);
        }
        throw e;
      }
    }

    // HDS 7. - Returns properly filled dtoOut.
    dtoOut["uuAppErrorMap"] = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Return list of all created permissions.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<*>}
   */
  async listPermissions(awid, dtoIn, uuAppErrorMap = {}) {

    // HDS 1. - Performs a logical check of dtoIn.
    let errorClass = ErrorHelper.getErrorClass(awid, InstanceErrors.PermissionList, WorkspaceErrors.PermissionList);
    let validationResult = this.validator.validate("sysPermissionsListDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${errorClass.UC_CODE}unsupportedKeys`,
      errorClass["InvalidDtoInError"]
    );

    // HDS 2. - Loads all sysPermission uuObjects from the uuAppObjectStore
    // that have set a uuIdentity to one of the dtoIn.uuIdentityList values and
    // also a profile to one of the dtoIn.profileList values.
    let dtoOut = await this.dao.listByUuIdentityAndAppProfile(awid, dtoIn, dtoIn["pageInfo"]);

    // HDS 3. - Returns properly filled out dtoOut.
    dtoOut["uuAppErrorMap"] = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * return profile code of specific user
   * @param {String} awid
   * @param {String} uuId
   * @returns {Promise<*>}
   */
  async getProfileCodesForUser(awid, uuId) {
    return await this.dao.getProfilesByUuIdentity(awid, uuId);
  }

  /**
   * Remove permissions for uuIdentity and application profile defined in dtoIn.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{uuAppErrorMap: {}}>}
   */
  async deletePermission(awid, dtoIn, uuAppErrorMap = {}) {

    // HDS 1. - Performs a logical check of dtoIn.
    let errorClass = ErrorHelper.getErrorClass(awid, InstanceErrors.PermissionDelete, WorkspaceErrors.PermissionDelete);
    let validationResult = this.validator.validate("sysPermissionDeleteDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult( // A1, A2
      dtoIn,
      validationResult,
      `${errorClass.UC_CODE}unsupportedKeys`,
      errorClass["InvalidDtoInError"]
    );

    // HDS 2. - Removes every set(uuId, profile) of sysPermission given in dtoIn from uuAppObjectStore.
    // (DAO method deleteByUuIdentityAndProfile)
    try {
      await this.dao.deleteByUuIdentityAndProfile(awid, dtoIn["uuIdentityList"], dtoIn.profile);
    } catch (e) { // A3
      if (e instanceof ObjectStoreError) {
        throw new errorClass["SysPermissionDeleteDaoFailedError"]({ uuAppErrorMap }, null, e);
      }
      throw e;
    }

    // HDS 3. - Returns properly filled dtoOut.
    let dtoOut = {};
    dtoOut.uuAppErrorMap = uuAppErrorMap;

    return dtoOut;
  }

  /**
   * Delete all permissions for given awid.
   *
   * @param {String} awid
   */
  async deleteByAwid(awid) {
    await this.dao.delete(awid);
  }

  /**
   * Return count of all permissions for given awid.
   *
   * @param {String} awid
   * @returns {Promise<*>}
   */
  async getCount(awid) {
    return await this.dao.getCount(awid);
  }
}

module.exports = new SysPermissionAbl();
