"use strict";

const Fs = require("fs");
const Path = require("path");
const { Config, OptsReader, Finder } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const SecretStoreHelper = require("../helpers/secret-store-helper.js");
const { DaoFactory, ObjectStoreError, Lock, ObjectNotFound } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");
const Errors = require("../api/errors/sys-app-secret-store-errors.js");

const CONFIG_FOLDER = "config";
const CONFIG_FILE = "secretstore.json";

const MIN_KEY_LENGTH = 32;
const ITERATION_NUMBER = 100000;
const KEY_LENGTH = 256 / 8;
const VECTOR_LENGTH = 96 / 8;
const DEFAULT_ACTIVE_SLOT = "slot1";
const DEFAULT_KEY_COUNT = 64;
const DEFAULT_TIMEOUT = 45000;

const DTO_OUT_COMPLETED = {
  state: "Completed",
  message: "Rotate of master keys has been successfully completed.",
};

const DTO_OUT_COMPLETED_WITH_WARNING = {
  state: "CompletedWithWarning",
  message: "Rotate of master keys has been completed with warning.",
};

const DTO_OUT_STARTED = {
  state: "Started",
  message:
    "Rotate of master keys has been started in an asynchronous thread. Please wait until the rotate is completed. You can check rotate status using uucmd sys/uuAppSecretStore/getStatus.",
};

const WARNINGS = {
  putSecret: {
    unsupportedKeys: {
      code: `${Errors.PutSecret.UC_CODE}unsupportedKeys`,
    },
  },
  getSecret: {
    unsupportedKeys: {
      code: `${Errors.GetSecret.UC_CODE}unsupportedKeys`,
    },
  },
  listSecretCodes: {
    unsupportedKeys: {
      code: `${Errors.ListCodes.UC_CODE}unsupportedKeys`,
    },
  },
  removeSecret: {
    unsupportedKeys: {
      code: `${Errors.RemoveSecret.UC_CODE}unsupportedKeys`,
    },
  },
  rotateMasterKey: {
    unsupportedKeys: {
      code: `${Errors.RotateMasterKey.UC_CODE}unsupportedKeys`,
    },
    itemListContainsMoreSecrets: {
      code: `${Errors.RotateMasterKey.UC_CODE}itemListContainsMoreSecrets`,
      message: (secretCount) =>
        `List contains more than ${secretCount} uuObjects sysUuAppSecret. To rotate more secrets, please run uuCmd sys/uuAppSecretStore/rotateMasterKey again.`,
    },
    daoUpdateFailed: {
      code: `${Errors.RotateMasterKey.UC_CODE}daoUpdateFailed`,
      message: "Updating of sysUuAppSecret failed.",
    },
    sysUuAppSecretStoreAlreadyLocked: {
      code: `${Errors.RotateMasterKey.UC_CODE}sysUuAppSecretAlreadyLocked`,
      message: "UuObject sysUuAppSecret already locked.",
    },
    sysUuAppSecretStoreMasterKeyNotFound: {
      code: `${Errors.RotateMasterKey.UC_CODE}masterKeyNotFound`,
      message: "uuAppSecretStore MasterKey not found in configuration. Unable to decrypt secret.",
    },
    sysUuAppSecretStoreEncryptionDisabled: {
      code: `${Errors.RotateMasterKey.UC_CODE}encryptionDisabled`,
      message: "uuAppSecretStore encryption is disabled. Stored secrets are decrypted if corresponding master keys are set.",
    },
  },
};

class SysAppSecretStoreAbl {

  constructor() {
    this.validator = Validator.load();
    this.logger = LoggerFactory.get("uuapp.workspace.SysAppSecretStoreAbl");
    let secretStoreConfig = this._loadSecretStoreConfig();
    this.opts = new OptsReader(secretStoreConfig, Config);
    this.enableEncryption = this.opts.getBoolean("uu_app_secretstore_enable_encryption", false);
    this.activeSlot = this.enableEncryption ? this.opts.getString("uu_app_secretstore_master_key_active_slot", DEFAULT_ACTIVE_SLOT) : null;
    let { masterKey1, masterKey2 } = this._resolveMasterKeys(this.activeSlot);
    this.masterKey1 = masterKey1;
    this.masterKey2 = masterKey2;
    this.dao = DaoFactory.getDao("sysUuAppSecret");
    this.uuSubAppInstanceDao = DaoFactory.getDao("sysUuSubAppInstance");
    this.LOCK_CODE = "sysUuAppSecret";
    this.LOCK_DURATION = 30;
  }

  async putSecret(awid, secretSet, code, secret) {
    // HDS 1 Perform a logical check of dtoIn.
    const dtoIn = { awid, secretSet, code, secret };
    let validationResult = this.validator.validate("sysUuAppSecretStorePutSecretDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.putSecret.unsupportedKeys.code,
      Errors.PutSecret.InvalidDtoInError
    );

    // HDS 2 System sets the master keys according to active slot from configuration

    let salt, encrypted;
    if (this.enableEncryption) {
      // HDS 3 System generates salt
      salt = SecretStoreHelper.generateSalt(MIN_KEY_LENGTH);

      // HDS 4 System generates derived master key and initialization vector
      // HDS 5 System calls asynchronous Password-Based Key Derivation Function 2
      const { generatedKey, generatedVector } = await this._createPbkdf2(salt, this.masterKey1, this.masterKey2);

      // HDS 6 System encrypts data
      encrypted = SecretStoreHelper.encrypt(secret, generatedKey, generatedVector);
    } else {
      encrypted = secret;
    }

    // HDS 7 System writes to the database
    let secretStoreEntry = await this.dao.getByAwidAndSecretSetAndCode(awid, secretSet, code);
    if (secretStoreEntry) {
      secretStoreEntry = {
        ...secretStoreEntry,
        masterKeySlot: this.enableEncryption ? this.activeSlot : null,
        secret: this.enableEncryption ? `${salt}.${encrypted}` : encrypted,
      };
      try {
        secretStoreEntry = await this.dao.update(secretStoreEntry);
      } catch (e) {
        if (e instanceof ObjectStoreError) {
          throw new Errors.PutSecret.SysUuAppSecretStoreDaoUpdateFailed();
        }
        throw e;
      }
    } else {
      secretStoreEntry = {
        awid,
        secretSet,
        code,
        masterKeySlot: this.enableEncryption ? this.activeSlot : null,
        secret: this.enableEncryption ? `${salt}.${encrypted}` : encrypted,
      };

      try {
        secretStoreEntry = await this.dao.create(secretStoreEntry);
      } catch (e) {
        if (e instanceof ObjectStoreError) {
          throw new Errors.PutSecret.SysUuAppSecretStoreDaoCreateFailed();
        }
        throw e;
      }
    }

    // HDS 8 System returns filled dtoOut
    secretStoreEntry.uuAppErrorMap = uuAppErrorMap;
    return secretStoreEntry;
  }

  async getSecret(awid, secretSet, code, wholeEntity = false) {
    // HDS 1 Perform a logical check of dtoIn.
    const dtoIn = { awid, secretSet, code };
    let validationResult = this.validator.validate("sysUuAppSecretStoreGetSecretDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.getSecret.unsupportedKeys.code,
      Errors.GetSecret.InvalidDtoInError
    );

    // HDS 2 System gets sysUuAppSecretStore entity using DAO method getByAwidAndSecretSetAndCode
    let secretStoreEntity = await this.dao.getByAwidAndSecretSetAndCode(awid, secretSet, code);
    if (!secretStoreEntity) {
      return null;
    }

    if (secretStoreEntity.masterKeySlot != null) {
      // HDS 3 System sets the master keys
      let activeSlot = secretStoreEntity.masterKeySlot;
      let { masterKey1, masterKey2 } = this._resolveMasterKeys(activeSlot);
      if (!masterKey1 || !masterKey2) {
        throw new Errors.GetSecret.MasterKeyNotFound({ uuAppErrorMap }, { awid, secretSet, code, slot: activeSlot });
      }
      // HDS 4 System generates derived master key and initialization vector
      // HDS 5 System generates PBKDF2
      let [salt, secret] = secretStoreEntity.secret.split(".");
      const { generatedKey, generatedVector } = await this._createPbkdf2(salt, masterKey1, masterKey2);

      // HDS 6 System decrypt data
      secretStoreEntity.secret = SecretStoreHelper.decrypt(secret, generatedKey, generatedVector);
    }

    // HDS 7 Return secret
    return wholeEntity ? secretStoreEntity : secretStoreEntity.secret;
  }

  async listSecretCodes(awid, secretSet) {
    // HDS 1 Perform a logical check of dtoIn.
    const dtoIn = { awid, secretSet };
    let validationResult = this.validator.validate("sysUuAppSecretStoreListCodesDtoInType", dtoIn);
    ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.listSecretCodes.unsupportedKeys.code,
      Errors.ListCodes.InvalidDtoInError
    );

    // HDS 2
    let dtoOut = await this.dao.getUniqueCodeList(awid, secretSet);

    // HDS 3
    return dtoOut.itemList;
  }

  async removeSecret(awid, secretSet, code) {
    // HDS 1 Perform a logical check of dtoIn.
    const dtoIn = { awid, secretSet, code };
    let validationResult = this.validator.validate("sysUuAppSecretStoreRemoveSecretDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.removeSecret.unsupportedKeys.code,
      Errors.RemoveSecret.InvalidDtoInError
    );

    // HDS 2 System remove sysUuAppSecretStore entity from the objectStore using sysUuAppSecretStore DAO delete
    try {
      await this.dao.delete({ awid, secretSet, code });
    } catch (e) {
      throw new Errors.RemoveSecret.SysUuAppSecretStoreDaoDeleteFailed({ uuAppErrorMap }, { awid, secretSet, code });
    }

    // HDS 3
    return { uuAppErrorMap };
  }

  async rotateMasterKey(asid, dtoIn, uuAppErrorMap = {}) {
    // HDS 1 Perform a logical check of dtoIn.
    let validationResult = this.validator.validate("sysUuAppSecretStoreRotateMasterKeyDtoInType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.rotateMasterKey.unsupportedKeys.code,
      Errors.RotateMasterKey.InvalidDtoInError
    );

    if (!dtoIn.secretCount) {
      dtoIn.secretCount = DEFAULT_KEY_COUNT;
    }

    // HDS 2 System checks  in configuration of application attribute uu_app_secretstore_enable_encryption
    if (!this.enableEncryption) {
      ValidationHelper.addWarning(
        uuAppErrorMap,
        WARNINGS.rotateMasterKey.sysUuAppSecretStoreEncryptionDisabled.code,
        WARNINGS.rotateMasterKey.sysUuAppSecretStoreEncryptionDisabled.message,
        {}
      );
    }

    // HDS 3 System gets uuSubAppInstance using getByAsid DAO method
    let uuSubAppInstance = await this.uuSubAppInstanceDao.getByAsid(asid);
    if (!uuSubAppInstance) {
      throw new Errors.RotateMasterKey.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
    }

    if (uuSubAppInstance.uuAppSecretStoreRotateStatus === DTO_OUT_STARTED.state.toLowerCase()) {
      return this._getDtoOut(uuAppErrorMap, false);
    }

    let rotatePromise = new Promise(async (resolve, reject) => {
      let timeoutHandler = setTimeout(() => {
        reject("timeout");
      }, DEFAULT_TIMEOUT);
      try {
        resolve(
          await this._runRotateMasterKey(
            asid,
            uuSubAppInstance.uuAppSecretStoreRotateStatus,
            dtoIn.secretCount,
            uuAppErrorMap
          )
        );
      } catch (e) {
        this.logger.error("Rotate masterKey failed.", e);
        reject(e);
      } finally {
        clearTimeout(timeoutHandler);
      }
    });
    try {
      await rotatePromise;
      return this._getDtoOut(uuAppErrorMap, true);
    } catch (e) {
      if (e === "timeout") {
        // HDS 7
        try {
          await this.uuSubAppInstanceDao.update({
            asid,
            uuAppSecretStoreRotateStatus: DTO_OUT_STARTED.state.toLowerCase(),
          });
        } catch (e) {
          if (e.cause instanceof ObjectNotFound) {
            throw new Errors.RotateMasterKey.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
          } else if (e.cause instanceof ObjectStoreError) {
            throw new Errors.RotateMasterKey.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, {}, e);
          }
          throw e;
        }
        return this._getDtoOut(uuAppErrorMap, false);
      } else {
        throw e;
      }
    }
  }

  async getStatus() {
    // HDS 1 System gets from configuration of application value of attribute uu_app_secretstore_master_key_active_slot
    let dtoOut = { activeSlot: this.activeSlot };

    // HDS 2 System gets the list of slots from sysUuAppSecretStore using sysUuAppSecretStore DAO getDistinct.
    let slots = await this.dao.getDistinctSlot();

    // HDS 3 For each slot system count amount of objects using sysUuAppSecretStore DAO countSlot
    let slotStatus = {};
    if (slots && slots.itemList.length > 0) {
      for (let slot of slots.itemList) {
        if (slot != null) {
          let secretCount = await this.dao.countSlot(slot);
          slotStatus[`${slot}`] = { secretCount };
        }
      }
    }
    let unencryptedSecretCount = await this.dao.countSlot(null);
    if (unencryptedSecretCount > 0) {
      slotStatus[`unencryptedSecrets`] = { secretCount: unencryptedSecretCount };
    }
    dtoOut.slotStatus = slotStatus;

    // HDS 4 Returns properly filled dtoOut.
    return dtoOut;
  }

  _loadSecretStoreConfig() {
    let serverRoot = Config.getString("server_root") || process.cwd();
    let configPath = Finder.findConfigInProject(serverRoot, `{src,app,}/${CONFIG_FOLDER}/${CONFIG_FILE}`);
    if (!configPath) {
      configPath = Path.join(serverRoot, "app", CONFIG_FOLDER, CONFIG_FILE);
    }
    if (Fs.existsSync(configPath)) {
      return JSON.parse(Fs.readFileSync(configPath));
    } else {
      this.logger.warn(`Secret store configuration file ${configPath} not found.`);
      return {};
    }
  }

  async _runRotateMasterKey(asid, uuAppSecretStoreRotateStatus, secretCount, uuAppErrorMap) {
    // HDS 5 System gets sysUuAppSecretStore items using sysUuAppSecretStore DAO
    let pageInfo = { pageSize: secretCount };
    let listByNonActiveSlot = await this.dao.listByNonActiveSlot(this.activeSlot, pageInfo);
    // HDS 5.1
    if (listByNonActiveSlot.itemList && listByNonActiveSlot.itemList.length > 0) {
      // HDS 5.2 System generates derived master key and initialization vector. System generates PBKDF2.
      let previousMasterKey1,
        previousMasterKey2,
        previousGeneratedKey,
        previousGeneratedVector,
        decryptedValue,
        previousSalt,
        previousSecret,
        salt,
        encrypted;

      // HDS 6 For each uuObject sysUuAppSecretStore from HDS 3.1 system gets attributes: activeSlot, awid, secretSet, code.
      // Using this attributes system locks uuObject sysUuAppSecretStore using sysUuAppSecretStore DAO lockOneBySecretSetAndByCode.
      for (let item of listByNonActiveSlot.itemList) {
        // HDS 6.1
        let lock = new Lock(this.LOCK_CODE, this.LOCK_DURATION);
        try {
          await this.dao.lockOneBySecretSetAndByCode(item.awid, item.secretSet, item.code, lock);
        } catch (e) {
          const warningParams = { id: item.id, awid: item.awid, secretSet: item.secretSet, code: item.code, slot: item.masterKeySlot };
          if (uuAppErrorMap[WARNINGS.rotateMasterKey.sysUuAppSecretStoreAlreadyLocked.code]) {
            uuAppErrorMap[WARNINGS.rotateMasterKey.sysUuAppSecretStoreAlreadyLocked.code].paramMap.secretList.push(warningParams);
          } else{
            ValidationHelper.addWarning(
              uuAppErrorMap,
              WARNINGS.rotateMasterKey.sysUuAppSecretStoreAlreadyLocked.code,
              WARNINGS.rotateMasterKey.sysUuAppSecretStoreAlreadyLocked.message,
              { secretList: [warningParams] }
            );
          }
          continue;
        }

        // HDS 6.2
        if (item.masterKeySlot != null) {
          previousMasterKey1 = this.opts.getString(`uu_app_secretstore_master_key1_${item.masterKeySlot}`, null);
          previousMasterKey2 = this.opts.getString(`uu_app_secretstore_master_key2_${item.masterKeySlot}`, null);
          [previousSalt, previousSecret] = item.secret.split(".");
        } else {
          previousSecret = item.secret;
        }

        if ((!previousMasterKey1 || !previousMasterKey2) && item.masterKeySlot != null) {
          const warningParams = { awid: item.awid, secretSet: item.secretSet, code: item.code, slot: item.masterKeySlot };
          if (uuAppErrorMap[WARNINGS.rotateMasterKey.sysUuAppSecretStoreMasterKeyNotFound.code]) {
            uuAppErrorMap[WARNINGS.rotateMasterKey.sysUuAppSecretStoreMasterKeyNotFound.code].paramMap.secretList.push(warningParams);
          } else {
            ValidationHelper.addWarning(
              uuAppErrorMap,
              WARNINGS.rotateMasterKey.sysUuAppSecretStoreMasterKeyNotFound.code,
              WARNINGS.rotateMasterKey.sysUuAppSecretStoreMasterKeyNotFound.message,
              { secretList: [warningParams] }
            );
          }
          await this.dao.unlockOneBySecretSetAndByCode(item.awid, item.secretSet, item.code, lock);
          continue;
        }

        // HDS 6.3 Using masterKey from HDS 4.2 system decrypt data
        if (item.masterKeySlot != null && previousMasterKey1 && previousMasterKey2) {
          ({ generatedKey: previousGeneratedKey, generatedVector: previousGeneratedVector } = await this._createPbkdf2(
            previousSalt,
            previousMasterKey1,
            previousMasterKey2
          ));
          decryptedValue = SecretStoreHelper.decrypt(previousSecret, previousGeneratedKey, previousGeneratedVector);
        }
        if (item.masterKeySlot == null) {
          decryptedValue = item.secret;
        }

        // HDS 6.4 Using masterKey for activeSlot from configuration of application system encrypt sensitive data.
        if (decryptedValue) {
          if (this.enableEncryption) {
            salt = SecretStoreHelper.generateSalt(MIN_KEY_LENGTH);
            const { generatedKey, generatedVector } = await this._createPbkdf2(salt, this.masterKey1, this.masterKey2);
            encrypted = SecretStoreHelper.encrypt(decryptedValue, generatedKey, generatedVector);
          } else {
            encrypted = decryptedValue;
          }
        }

        // HDS 6.5 System updates uuObject sysUuAppSecretStore using sysUuAppSecretStore DAO update.
        // System unlock data
        if (decryptedValue) {
          try {
            item = {
              ...item,
              ...{ secret: this.enableEncryption ? `${salt}.${encrypted}` : encrypted, masterKeySlot: this.activeSlot },
            };
            await this.dao.update(item, lock);
          } catch (e) {
            ValidationHelper.addWarning(
              uuAppErrorMap,
              WARNINGS.rotateMasterKey.daoUpdateFailed.code,
              WARNINGS.rotateMasterKey.daoUpdateFailed.message,
              { awid: item.awid, id: item.id }
            );
          }
        }
        await this.dao.unlockOneBySecretSetAndByCode(item.awid, item.secretSet, item.code, lock);
      }
      // HDS 7
      if (listByNonActiveSlot.pageInfo.total > secretCount) {
        ValidationHelper.addWarning(
          uuAppErrorMap,
          WARNINGS.rotateMasterKey.itemListContainsMoreSecrets.code,
          WARNINGS.rotateMasterKey.itemListContainsMoreSecrets.message(secretCount)
        );
      }
    }
    try {
      await this.uuSubAppInstanceDao.update({ asid, uuAppSecretStoreRotateStatus: DTO_OUT_COMPLETED.state.toLowerCase() });
    } catch (e) {
      if (e.cause instanceof ObjectNotFound) {
        throw new Errors.RotateMasterKey.SysUuSubAppInstanceDoesNotExist({ uuAppErrorMap }, { asid });
      } else if (e.cause instanceof ObjectStoreError) {
        throw new Errors.RotateMasterKey.SysUuSubAppInstanceDaoUpdateFailed({ uuAppErrorMap }, e);
      }
      throw e;
    }
  }

  _getDtoOut(uuAppErrorMap, completed = true) {
    let dtoOut;
    if (completed) {
      dtoOut = { ...(Object.keys(uuAppErrorMap).length > 0 ? DTO_OUT_COMPLETED_WITH_WARNING : DTO_OUT_COMPLETED) };
    } else {
      dtoOut = { ...DTO_OUT_STARTED}
    }
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  _resolveMasterKeys(activeSlot = this.activeSlot) {
    let masterKey1 = this.opts.getString(`uu_app_secretstore_master_key1_${activeSlot}`, null);
    let masterKey2 = this.opts.getString(`uu_app_secretstore_master_key2_${activeSlot}`, null);
    if (activeSlot === DEFAULT_ACTIVE_SLOT && !masterKey1) {
      masterKey1 = this.opts.getString("uu_app_secretstore_master_key1", null);
    }
    if (!masterKey2) { // master key 2 might be the same for multiple slots as it is part of appbox (=> no need to release new version of uuApp for configuration of key rotation)
      masterKey2 = this.opts.getString("uu_app_secretstore_master_key2", null);
    }

    return { activeSlot, masterKey1, masterKey2 };
  }

  async _createPbkdf2(salt, masterKey1 = this.masterKey1, masterKey2 = this.masterKey2) {
    return SecretStoreHelper.createPbkdf2(
      salt,
      masterKey1,
      masterKey2,
      ITERATION_NUMBER,
      KEY_LENGTH,
      VECTOR_LENGTH,
      "sha3-256"
    );
  }
}

module.exports = new SysAppSecretStoreAbl();
