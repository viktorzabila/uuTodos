"use strict";
const { Validator } = require("uu_appg01_core-validation");
const { ValidationHelper, UseCaseContext } = require("uu_appg01_core-appserver");
const { UriBuilder } = require("uu_appg01_core-uri");
const { DaoFactory, Lock } = require("uu_appg01_objectstore");
const { LoggerFactory } = require("uu_appg01_core-logging");
const logger = LoggerFactory.get("SysDataStoreStatsAbl");
const { PersistenceConfig } = require("uu_appg01_datastore");
const { AuditLog } = require("uu_appg01_auditlog");
const { DuplicateKey } = require("uu_appg01_objectstore");
const { Config } = require("uu_appg01_core-utils");

const Errors = require("../api/errors/sys-app-data-store-errors");

const SySDataStoreStatsBsCalcMongoDb = require("../dao/sys-app-data-store-stats-bs-calc-mongo");
const SySDataStoreStatsOsCalcMongoDb = require("../dao/sys-app-data-store-stats-os-calc-mongo");

const UNCALCULATED_DATA_STORE_STATS = {
  dataSize: 0,
  indexSize: 0,
  size: 0,
  count: 0,
  calcStartTs: null,
  calcEndTs: null,
  dataStoreMap: {}
};

class SysAppDataStoreStatsAbl {
  constructor() {
    this.CALCULATE_DEFAULTS = {
      calcLockDurationSec: 60,
      calcWriteLimitSec: 20,
      calcRecalculationLimitMs: 10 * 60 * 1000
    };

    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysUuAppDataStoreStats");
    this.asid = Config.get("asid");
  }

  /**
   * create collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  async create(awid) {
    await this.dao.create(this._getUncalculatedDataStoreStats(awid));
  }

  async get(awid, uuAppErrorMap = {}) {

    // hds 1, A1
    let dtoOut = await this.dao.getByAwid(awid);

    // A1
    if (!dtoOut) {
      throw new Errors.StatsGet.sysDataStoreStatsDoNotExist({ uuAppErrorMap });
    }

    let now = new Date();

    // hds 2.1, 2.2, 2.3, 2.4
    dtoOut["state"] = this._getCalculationState(dtoOut, now);
    dtoOut["uuAppErrorMap"] = uuAppErrorMap;
    return dtoOut;
  }

  async list(dtoIn) {
    //HDS 1.1, 1.2, 1.3 A1 A2
    let validationResult = this.validator.validate("sysStatsListDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.StatsList.UC_CODE}unsupportedKeys`,
      Errors.StatsList.InvalidDtoInError
    );

    let now = new Date();
    let dtoOut;

    //HDS 2.1, 2.2
    if (dtoIn["awidList"]) {
      dtoOut = await this.dao.listByAwids(dtoIn["awidList"], dtoIn["pageInfo"]);
    } else {
      dtoOut = await this.dao.list(dtoIn["pageInfo"]);
    }

    dtoOut["itemList"].forEach(item => {
      item["state"] = this._getCalculationState(item, now);
    });

    dtoOut["uuAppErrorMap"] = uuAppErrorMap;

    //HDS 3
    return dtoOut;
  }

  async privilegedCalculate(asid, dtoIn) {
    //HPS I.1.1, I.1.2, I.1.3 A1, A2
    let validationResult = this.validator.validate("sysStatsPrivilegedCalculateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.StatsPrivilegedCalculate.UC_CODE}unsupportedKeys`,
      Errors.StatsPrivilegedCalculate.InvalidDtoInError
    );

    // lazy upgrade -> create asid dataStoreStats uuObject if it doesn't exist
    try {
      await this.create(asid);
    } catch (e) {
      if (!(e instanceof DuplicateKey)) {
        throw e;
      }
    }

    let recentlyCalculatedAwids = [];
    let recalculationLimitDate;
    if (!dtoIn.force) {
      // checks if no calculation for any provided awid is running
      const runningOrScheduledCalcultations = await this.dao.listRunningOrScheduled(dtoIn.awidList);
      if (runningOrScheduledCalcultations.itemList.length) {
        const awids = runningOrScheduledCalcultations.itemList.map(i => i.awid);
        throw new Errors.StatsPrivilegedCalculate.CalculationAlreadyInProgress({ uuAppErrorMap }, { runningOrScheduledCalcultations: awids });
      }

      // retrieves awid that were recently calculated
      recalculationLimitDate = new Date(Date.now() - this.CALCULATE_DEFAULTS.calcRecalculationLimitMs);
      recentlyCalculatedAwids = (await this.dao.listRecentlyCalculatedByAwidList(dtoIn.awidList, recalculationLimitDate)).itemList;
    }

    // list awids for stats calculation
    let toCalculateAwidList = (await this.dao.listAwidsByAwidList(dtoIn.awidList)).itemList;
    if (dtoIn.awidList && toCalculateAwidList.length !== dtoIn.awidList.length) {
      const nonExistentAwids = dtoIn.awidList.filter((obj) => !toCalculateAwidList.includes(obj));
      throw new Errors.StatsPrivilegedCalculate.SysUuAppWorkspaceDoesNotExist({ uuAppErrorMap }, { nonExistentAwids });
    }

    if (recentlyCalculatedAwids.length) {
      if (recentlyCalculatedAwids.length === toCalculateAwidList.length) { // stats for all awids were recently recalculated => error
        throw new Errors.StatsPrivilegedCalculate.CalculatedRecently({ uuAppErrorMap }, { calculatedAfterDate: recalculationLimitDate.toISOString() });
      } else {
        ValidationHelper.addWarning(
          uuAppErrorMap,
          `${Errors.StatsPrivilegedCalculate.UC_CODE}calculatedRecently`,
          `Some of required awids were calculated recently (after ${recalculationLimitDate.toISOString()}) and wont be recalculated again.`,
          { recentlyCalculatedAwids }
        );
        toCalculateAwidList = toCalculateAwidList.filter(obj => !recentlyCalculatedAwids.includes(obj));
      }
    }

    // Marks datastore stats as scheduled.
    try {
      await this.dao.updateManyByAwidList(toCalculateAwidList, { state: "scheduled" });
    } catch (e) {
      throw new Errors.StatsPrivilegedCalculate.UpdateFailed({ uuAppErrorMap }, e);
    }

    // calculate stats asynchronously
    (async () => {
      for (const awid of toCalculateAwidList) {
        try {
          await this.calculate(awid, { force: dtoIn.force }, true);
        } catch (e) {
          logger.error(`Failed to calculate statistics for awid ${awid}.`, e);
          this.dao.updateByAwid(awid, { $unset: { state: "" } })
        }
      }
    })();

    return { uuAppErrorMap, message: "uuAppDataStore stats calculation started. You can check the status using uuCmd sys/uuAppDataStore/stats/list." };
  }

  async calculate(awid, dtoIn, runSync = false) {
    //HPS I.1.1, I.1.2, I.1.3 A1, A2
    let validationResult = this.validator.validate("sysStatsCalculateDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.StatsCalculate.UC_CODE}unsupportedKeys`,
      Errors.StatsCalculate.InvalidDtoInError
    );

    let limits = this.CALCULATE_DEFAULTS;
    let lock = new Lock("dataStoreStatsCalc", limits.calcLockDurationSec);
    let stats;

    //HDS I.2 A3
    try {
      stats = await this.dao.lockByAwid(awid, lock);
    } catch (e) {
      if (e.code === "uu-app-objectstore/objectLocked") {
        throw new Errors.StatsCalculate.CalculationAlreadyInProgress({ uuAppErrorMap }, e);
      }
    }

    let now = new Date();
    stats["dataStoreMap"] = {};
    stats["awid"] = awid;

    let lastCalcStart = stats["calcStartTs"];
    let lastCalcEnd = stats["calcEndTs"];

    //HDS I.3
    if (lastCalcStart && (!lastCalcEnd || lastCalcStart > lastCalcEnd)) {
      ValidationHelper.addWarning(
        uuAppErrorMap,
        `${Errors.StatsCalculate.PreviousCalculationFailed.code}`,
        Errors.StatsCalculate.PreviousCalculationFailed.message,
        {}
      );
    } else if (lastCalcEnd && now - lastCalcEnd < limits.calcRecalculationLimitMs) {
      if (!dtoIn["force"]) {
        try {
          await this.dao.unlockByAwid(awid, lock);
        } catch (e) {
          //A12
          throw new Errors.StatsCalculate.UnlockByDaoFailed({ uuAppErrorMap }, e);
        }
        throw new Errors.StatsCalculate.CalculatedRecently(
          { uuAppErrorMap },
          {
            calcEndTs: stats["calcEndTs"],
            limitSec: limits["calcRecalculationLimitMs"] / 1000
          }
        );
      }
    }

    //HDS I.4
    stats["calcStartTs"] = now;
    stats["lastCalcError"] = null;
    stats["state"] = null; // state is resolved dynamically based on stats content in get and list commands. The only state that is stored on stats uuObject is scheduled.
    try {
      await this.dao.updateByAwid(awid, stats, lock);
    } catch (e) {
      await this._unlockByAwidLogException(awid, lock);
      throw new Errors.StatsCalculate.UpdateByDaoFailed({ uuAppErrorMap }, e);
    }

    if (runSync) {
      await this._calculateDataStoreStatsAsync(stats, lock, uuAppErrorMap);
    } else {
      this._calculateDataStoreStatsAsync(stats, lock, uuAppErrorMap).catch(e => {
        logger.error(null, e);
      });
    }

    return { uuAppErrorMap };
  }

  removeUnusedStats(stats) {
    Object.keys(stats.dataStoreMap).forEach(dataStoreName => {
      let dataStore = stats.dataStoreMap[dataStoreName];

      Object.keys(dataStore.schemaMap).forEach(schemaName => {
        let schema = dataStore.schemaMap[schemaName];
        if (schema["count"] === 0) {
          delete dataStore.schemaMap[schemaName];
        }
      });
      if (dataStore.schemaMap.size === 0) {
        delete stats.dataStoreMap;
      }
    });
  }

  async _calculateDataStoreStatsAsync(stats, lock, uuAppErrorMap) {
    let limits = this.CALCULATE_DEFAULTS;

    //HDS II.1
    let startTime = new Date();
    let lastWrite = startTime;
    let now = new Date();

    //HDS II.2
    let stores = this._loadDataStoresMap();

    //HDS II.3
    await lock.setExpiration(limits.calcLockDurationSec);

    //HDS II.4
    let promises = Array.from(Object.keys(stores)).map(async dataStoreName => {
      let dataStore = stores[dataStoreName];
      let calcDaoClass;

      //HDS II.4.1
      if (dataStore.type[0] === "uuAppObjectStore" && dataStore.type[1] === "MongoDB") {
        calcDaoClass = SySDataStoreStatsOsCalcMongoDb;
      } else if (dataStore.type[0] === "uuAppBinaryStore" && dataStore.type[1] === "MongoDB") {
        calcDaoClass = SySDataStoreStatsBsCalcMongoDb;
      } else {
        //A7
        throw new Errors.StatsCalculate.UnknownDataStoreType({ uuAppErrorMap }, { type: dataStore.type });
      }

      let calcDao;
      //HDS II.4.2.1
      try {
        calcDao = new calcDaoClass(dataStore.connectionString);
      } catch (e) {
        //throw error
      }

      let dataStoreStats = stats["dataStoreMap"][dataStore.name];

      if (!dataStoreStats) {
        dataStoreStats = {
          type: dataStore.type[0],
          count: 0,
          dataSize: 0,
          indexSize: 0,
          size: 0,
          schemaMap: {}
        };
        stats["dataStoreMap"][dataStore.name] = dataStoreStats;
      }

      if (stats["awid"] === this.asid) {
        const stats = await calcDao.getStats();
        dataStoreStats.dsDataSize = stats.dataSize;
        dataStoreStats.dsStorageSize = stats.storageSize;
        dataStoreStats.dsIndexSize = stats.indexSize;
      }

      //HDS II.4.2
      let promises = await Array.from(dataStore.schemaList).map(async schema => {
        let schemaStats;
        try {
          schemaStats = await calcDao.calculate(stats["awid"], schema);
        } catch (e) {
          throw new Errors.StatsCalculate.CurrentCalculationFailed({ uuAppErrorMap }, { cause: e });
        }

        //HDS II.4.2.1.1
        await lock.setExpiration(limits.calcLockDurationSec);

        //HDS II.4.2.1.2
        now = new Date();
        schemaStats["ts"] = now;

        schemaStats["dataSize"] = Math.ceil(schemaStats["dataSize"]);
        schemaStats["indexSize"] = Math.ceil(schemaStats["indexSize"]);
        schemaStats["size"] = Math.ceil(schemaStats["size"]);
        dataStoreStats["schemaMap"][schema] = schemaStats;
        stats["dataStoreMap"][dataStore.name] = dataStoreStats;

        //HDS II.4.2.1.3
        let lastSchema = schema === dataStore.schemaList[dataStore.schemaList.length - 1];
        if (now - lastWrite > limits["calcWriteLimitSec"] || lastSchema) {
          //HDS II.4.2.1.3.1
          this._recalculateTotals(stats);

          //HDS II.4.2.1.3.2
          await this._updateStats(stats, lock, uuAppErrorMap);

          //HDS II.4.2.1.3.3
          lastWrite = now;
        }
      });

      await Promise.all(promises);

      //HDS II.5, II.6
      this.removeUnusedStats(stats);

      //HDS II.7
      this._recalculateTotals(stats);

      //HDS II.8
      stats["calcEndTs"] = new Date();

      await this._updateStats(stats, lock, uuAppErrorMap);
    });

    try {
      await Promise.all(promises);
    } catch (e) {
      // A10
      logger.error(`${stats["awid"]} - Data store stats calculation finished with error.`, e);
      await this._updateByAwidLogException(
        stats["awid"],
        {
          lastCalcError: {
            msg: e.toString(),
            paramMap: JSON.stringify(e.paramMap)
          }
        },
        lock
      );
    }

    await this._unlockByAwidLogException(stats["awid"], lock);

    if (!stats.lastCalcError) {
      delete stats.lastCalcError;
      logger.info(`${stats["awid"]} - Data store stats calculation finished without any error in ${Math.abs(new Date().getTime() - startTime.getTime()) / 1000} seconds.`);
    }
    delete stats.sys;
    delete stats.id;
    delete stats.state;

    const originalUri = UseCaseContext.getUri();
    const awidUri = UriBuilder.parse(originalUri).setAwid(stats.awid).toUri();
    delete stats.awid;

    UseCaseContext.setUri(awidUri);
    try {
      await AuditLog.log("INFO", "uuApp/dataStoreStats", "UuAppDataStore statistics calculated.", stats);
    } finally {
      UseCaseContext.setUri(originalUri);
    }
  }

  _recalculateTotals(stats) {
    stats["count"] = 0;
    stats["size"] = 0;
    stats["dataSize"] = 0;
    stats["indexSize"] = 0;
    Object.keys(stats.dataStoreMap).forEach(dataStoreName => {
      let dataStore = stats.dataStoreMap[dataStoreName];
      dataStore["count"] = 0;
      dataStore["size"] = 0;
      dataStore["dataSize"] = 0;
      dataStore["indexSize"] = 0;
      Object.keys(dataStore.schemaMap).forEach(schemaName => {
        let schema = dataStore.schemaMap[schemaName];
        dataStore["count"] += schema["count"];
        dataStore["size"] += schema["size"];
        dataStore["dataSize"] += schema["dataSize"];
        dataStore["indexSize"] += schema["indexSize"];
      });

      stats["count"] += dataStore["count"];
      stats["size"] += dataStore["size"];
      stats["dataSize"] += dataStore["dataSize"];
      stats["indexSize"] += dataStore["indexSize"];
    });
  }

  async _updateStats(stats, lock, uuAppErrorMap) {
    try {
      await this.dao.updateByAwid(stats["awid"], stats, lock);
    } catch (e) {
      throw new Errors.StatsCalculate.UpdateByDaoFailed({ uuAppErrorMap }, e);
    }
  }

  /**
   * load data from all persistence.json and schema_realizations files
   * and connection string for these stores for statistics
   * @returns {*[]}
   * @private
   */
  _loadDataStoresMap() {
    const { schemas, dataStores } = PersistenceConfig;

    let realizationStructure = {};

    schemas.forEach((schema, schemaName) => {
      const storeName = schema.dataStore;
      if (!realizationStructure[storeName]) {
        const store = dataStores.get(storeName);
        realizationStructure[storeName] = {
          name: storeName,
          type: [store.type, store.realization],
          connectionString: store.connectionString,
          schemaList: []
        };
      }
      let schemaList = realizationStructure[storeName]["schemaList"];
      realizationStructure[storeName]["schemaList"] = schemaList.concat(schemaName);
    });

    return Object.values(realizationStructure);
  }

  _getCalculationState(stats, now) {
    if (stats.state) {
      return stats.state;
    }
    let lockExpiration = stats["sys"]["lockExpTs"];
    let result;

    if (lockExpiration) {
      result = lockExpiration >= now ? "running" : "failed";
    } else if (stats["calcStartTs"] == null) {
      result = "neverCalculated";
    } else if (stats["calcStartTs"] != null && stats["calcStartTs"] < stats["calcEndTs"]) {
      result = "completed";
    } else {
      result = "failed";
    }

    return result;
  }

  async _unlockByAwidLogException(awid, lock) {
    try {
      await this.dao.unlockByAwid(awid, lock);
    } catch (e) {
      logger.error(null, e);
    }
  }

  async _updateByAwidLogException(awid, stats, lock) {
    try {
      await this.dao.updateByAwid(awid, stats, lock);
    } catch (e) {
      logger.error(null, e);
    }
  }

  _getUncalculatedDataStoreStats(awid) {
    return Object.assign({ awid }, UNCALCULATED_DATA_STORE_STATS);
  }
}

module.exports = new SysAppDataStoreStatsAbl();
