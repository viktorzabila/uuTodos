"use strict";

const Fs = require("fs");
const { Socket } = require("net");
const { MongoClient } = require("mongodb");

const { TestServer } = require("uu_appg01_core-test");
const { TestMongo } = require("uu_appg01_datastore-test");

const { BaseError, Config } = require("uu_appg01_server").Utils;
const { UriBuilder } = require("uu_appg01_server").Uri;
const { AuthenticationService } = require("uu_appg01_server").Authentication;
const { AppClient } = require("uu_appg01_server");

try {
  // Ensure initialization of oidc library if available
  require("uu_appg01_oidc").AuthenticationService;
  Config.set(AuthenticationService.DEFAULT_PROVIDER_PARAM, "uu_appg01_oidc");
} catch (e) {
  console.warn("Library uu_appg01_oidc is not installed, ensure other realization of AuthenticationService is available.", e);
}

/**
 * Helper component for implementation of application tests.
 */
class TestHelper {
  /**
   * Creates new instance of TestHelper.
   * @private
   */
  constructor() {
    this._asid = null;
    this._awid = null;
    this._userMap = {};
    this._awidLicenseOwnerList = null;
    this._awidLicense = null;
    this._awidName = null;
    this._awidDescription = null;
    this._sessions = {};
    this._activeSession = null;
    this._testServer = null;
    this._gatewayUrl = null;
    this._testMongo = null;
    this._binaryg02Dbs = {};
  }

  /**
   * Returns port of running server.
   * @returns {Number} Port of running server
   */
  getPort() {
    return this._testServer ? this._testServer.getPort() : null;
  }

  /**
   * Returns gateway URL of running server.
   * @returns {String} Gateway URL of running server
   */
  getGatewayUrl() {
    return this._testServer ? this._testServer.getGatewayUrl() : null;
  }

  /**
   * Returns ASID of running server.
   * @returns {String} ASID of running server
   */
  getAsid() {
    return this._asid;
  }

  /**
   * Returns default AWID of running server.
   * @returns {String} Default AWID of running server
   */
  getAwid() {
    return this._awid;
  }

  /**
   * Initializes test environment (starts embedded application and database server).
   * @param {String} appPath Path to application configuration file (defaults to "<%cwd%>/app.js")
   * @param {Object} options Additional test options
   * @param {String} options.setupDbScript Path to mongo shell script file or script content to be executed on setup
   * @param {boolean} options.authEnabled Allows disabling of authentication and authorization (defaults to true)
   * @param {boolean} options.verbose If set to false, server logs only error messages (defaults to false)
   * @param {String} options.mongoDbVersion Version of the mongoDB binary.
   */
  async setup(appPath = null, options = {}) {
    if (appPath != null && typeof appPath === "object") {
      options = appPath;
      appPath = null;
    }
    this._loadTestConfiguration();
    this._opts = options;
    if (this._opts.authEnabled == false) {
      Config.set("uu_app_authentication_unprotected_uri_regexp", ".*");
      Config.set("uu_app_authorization_unprotected_uri_regexp", ".*");
    }
    if (this._opts.sysStatesEnabled == false) {
      Config.set("uu_app_workspace_asid_sys_state_verification_enabled", false);
      Config.set("uu_app_workspace_awid_sys_state_verification_enabled", false);
    }
    await this._setCacheTtl();
    await this._startMongoDB();
    await this._startServer(appPath, this._opts.verbose);
    await this.executeDbScript(this._opts.setupDbScript);
  }

  /**
   * Allows initialization or modification of database by running given mongo shell script
   * (script is invoked in scope of primary storage, it is possible to switch database inside
   * script via "use <db>;" instruction).
   * @param {String} script Path to script file or script content
   * @returns {Promise<*>} Mongo result object
   */
  async executeDbScript(script) {
    let connectionString = Config.get("uuSubAppDataStoreMap").primary;
    if (!connectionString || !script) {
      return;
    }
    if (Fs.existsSync(script)) {
      script = Fs.readFileSync(script, "utf8");
    }

    let result = null;
    await this._mongoClientExec(connectionString, async client => {
      result = await client.db().eval(script);
    });
    return result;
  }

  /**
   * Drops all data from testing database.
   */
  async dropDatabase() {
    let dataStoreMap = Config.get("uuSubAppDataStoreMap") || {};

    let promises = [];
    Object.values(dataStoreMap).forEach(testDb => {
      promises.push(this._dropMongoDb(testDb));
    });

    Object.values(this._binaryg02Dbs).forEach(testDb => {
      promises.push(this._dropMongoDb(testDb));
    });

    await Promise.all(promises);
  }

  /**
   * Cleans test environment (stops embedded application and database server).
   */
  async teardown() {
    if (this._opts.authEnabled == false) {
      Config.delete("uu_app_authentication_unprotected_uri_regexp");
      Config.delete("uu_app_authorization_unprotected_uri_regexp");
    }
    await this._testServer.stop();
    this._testServer = null;
    if (this._testMongo) {
      await this._testMongo.stop();
      this._testMongo = null;
    }
    this._binaryg02Dbs = {};
  }

  /**
   * Executes POST HTTP request for logged user.
   * @param {String} useCase Use case name that will be used as the part of uri
   * @param {Object} dtoIn Hash containing request parameters
   * @param {Session} session Instance of session
   * @param {Object} opts call options
   * @param {String} opts.gateway gateway that will be used as a part of called uri
   * @param {String} opts.product product in format "vendor-app-subapp" that will be used as a part of called uri
   * @param {String} opts.spp spp that will be used as a part of called uri
   * @param {String} opts.awid Application workspace id that will be used as a part of called uri (workspace)
   * @returns {Promise<*>} Response including dtoOut
   */
  async executePostCommand(useCase, dtoIn = {}, session = null, opts = {}) {
    if (typeof opts === "string") { // support awid for backward compatibility, TODO remove in the next major version
      console.warn("Using awid as a 4th parameter of executePostCommand method is deprecated. Use object {awid: \"...\"} instead. This method overload is deprecated and is going to be removed!");
      opts = {
        awid: opts
      }
    }
    if (typeof session === "string") {
      opts.awid = session;
      session = null;
    }
    let uri = new UriBuilder()
      .setGateway(opts.gateway || this._gatewayUrl)
      .setProduct(opts.product || "vendor-app-subApp")
      .setSpp(opts.spp || null)
      .setAwid(opts.awid || this._awid)
      .setUseCase(useCase)
      .toUri();
    return await AppClient.post(uri, dtoIn, { session: session || this._activeSession });
  }

  /**
   * Executes GET HTTP request for logged user.
   * @param {String} useCase Use case name that will be used as the part of uri
   * @param {Object} dtoIn Hash containing request parameters
   * @param {Session} session Instance of session
   * @param {Object} opts call options
   * @param {String} opts.gateway gateway that will be used as a part of called uri
   * @param {String} opts.product product in format "vendor-app-subapp" that will be used as a part of called uri
   * @param {String} opts.spp spp that will be used as a part of called uri
   * @param {String} opts.awid Application workspace id that will be used as a part of called uri (workspace)
   * @returns {Promise<*>} Response including dtoOut
   */
  async executeGetCommand(useCase, dtoIn = {}, session = null, opts = {}) {
    if (typeof opts === "string") { // support awid for backward compatibility, TODO remove in the next major version
      console.warn("Using awid as a 4th parameter of executeGetCommand method is deprecated. Use object {awid: \"...\"} instead. This method overload is deprecated and is going to be removed!");
      opts = {
        awid: opts
      }
    }
    if (typeof session === "string") {
      opts.awid = session;
      session = null;
    }
    let uri = new UriBuilder()
      .setGateway(opts.gateway || this._gatewayUrl)
      .setProduct(opts.product || "vendor-app-subApp")
      .setSpp(opts.spp || null)
      .setAwid(opts.awid || this._awid)
      .setUseCase(useCase)
      .toUri();
    return await AppClient.get(uri, dtoIn, { session: session || this._activeSession });
  }

  /**
   * Initializes app and set sysState to active by default.
   * @param dtoIn dtoIn of uuCMD sys/uuSubAppInstance/init
   * @param asid
   * @returns {Promise<void>} initialized uuSubAppInstance
   */
  async initUuSubAppInstance(dtoIn = {}, asid = this._asid) {

    dtoIn = await this._prepareInitAppInstanceDtoIn(dtoIn);
    let session = await this.login("AsidLicenseOwner", false, false);
    await this.executePostCommand("sys/uuSubAppInstance/init", dtoIn, session, { awid: asid });
  }

  /**
   * Creates application workspace. All parameters are optional (if not passed, values from the application
   * configuration are used).
   *
   * @param dtoIn input parameters for uuCMD sys/uuAppWorkspace/create
   * @returns {Promise<*>} Response including dtoOut
   */
  async createUuAppWorkspace(dtoIn = {}) {

    dtoIn = await this._prepareCreateAppWorkspaceDtoIn(dtoIn, dtoIn.awid || this._awid);
    let session = await this.login("AsidAuthorities", false, false);
    let workspace = await this.executePostCommand("sys/uuAppWorkspace/create", dtoIn, session, { awid: this._asid });
    return workspace;
  }

  /**
   * Initialize application workspace. DtoIn depends on the application logic.
   *
   * @param dtoIn dtoIn of uuCMD sys/uuAppWorkspace/init
   * @param awid Application workspace ID
   * @returns {Promise<*>} Response including dtoOut
   */
  async initUuAppWorkspace(dtoIn = {}, awid = this._awid) {
    let session = await this.login("AwidLicenseOwner", false, false);
    let appWorkspace = await this.executePostCommand("sys/uuAppWorkspace/init", dtoIn, session, { awid });

    const user = this._getTestUser("Authorities");
    const createPermissionDtoIn = {
      profile: "Authorities",
      uuIdentityList: [user.uuIdentity]
    };
    await this.executePostCommand("sys/uuAppWorkspace/permission/create", createPermissionDtoIn, session, { awid });
    return appWorkspace;
  }

  /**
   * Initializes application test environment by calling init appInstance (sys/uuSubAppInstance/init), create appWorkspace (sys/uuAppWorkspace/create) and init appWorkspace (sys/uuAppWorkspace/init).
   * This function is intended to be used in most of the test scenarios, where default parameters for sys/uuSubAppInstance/init and sys/uuAppWorkspace/create are used.
   *
   * @param initAppWorkspaceDtoIn dtoIn of uuCMD sys/uuAppWorkspace/init
   * @returns {Promise<void>}
   */
  async prepareApp(initAppWorkspaceDtoIn = {}) {
    await this.initUuSubAppInstance();
    await this.createUuAppWorkspace();
    await this.initUuAppWorkspace(initAppWorkspaceDtoIn);
  }

  /**
   * Login user specified by name.
   * @param {String} userName Name of user for whom login will be processed
   * @param {boolean} createPermission Flag for creating permissions. If is set to true, then permission(s) will be
   *   created for given user.
   * @param {boolean} globalLogin Flag for save session. If is set to true, then session is saved (every next call of request will be authorized under this user).
   *   of request will be authorized under this user).
   * @returns {Promise<Session>} Instance of user session
   */
  async login(userName, createPermission = true, globalLogin = true) {
    if (this._opts.authEnabled == false) {
      return null;
    }
    if (createPermission) {
      await this.createPermission(userName);
    }
    let session = this._sessions[userName];
    if (!session) {
      let user = this._getTestUser(userName);
      if (!user.accessCode1 || !user.accessCode2) {
        throw new BaseError(
          `Login failed. User ${userName} has no defined access code(s) for obtaining authorization token.`
        );
      }
      let credentials = { access_code1: user.accessCode1, access_code2: user.accessCode2 };
      session = await AuthenticationService.authenticate(credentials);
      this._sessions[userName] = session;
    }
    if (globalLogin) {
      this._activeSession = session;
    }
    return session;
  }

  /**
   * Create permission(s) for given user.
   * @param {String} userName Name of user for whom permissions will be created.
   */
  async createPermission(userName) {
    let user = this._userMap[userName];
    if (!user) {
      throw new BaseError(`Creating permission(s) failed. User ${userName} not found`);
    }
    if (!user.profileList) {
      throw new BaseError(`Creating permission(s) failed. User ${userName} has no defined profile list.`);
    }
    if (!user.uuIdentity) {
      throw new BaseError(`Creating permission(s) failed. User ${userName} has no defined uuIdentity.`);
    }
    let session = await this.login("AwidLicenseOwner", false, false);
    let promises = user.profileList.map(async appProfile => {
      let parameters = {
        profile: appProfile,
        uuIdentityList: user.uuIdentity
      };
      await this.executePostCommand("sys/uuAppWorkspace/permission/create", parameters, session);
    });
    await Promise.all(promises);
  }

  /**
   * Load test configuration and initializes variables.
   * @private
   */
  _loadTestConfiguration() {
    this._asid = Config.get("asid");
    this._userMap = Config.get("userMap") || {};
    let sysAppWorkspace = Config.get("sysUuAppWorkspace") || {};
    this._awid = sysAppWorkspace.awid;
    this._awidLicenseOwnerList = sysAppWorkspace.awidLicenseOwnerList;
    this._awidLicense = sysAppWorkspace.awidLicense || "M";
    this._awidName = sysAppWorkspace.name || "uuAppg01Server Test";
    this._awidDescription = sysAppWorkspace.description || "uuAppg01Server Test description";
  }

  /**
   * Starts embedded database server (Uses local database server if it is configured in test.json and running).
   * @private
   */
  async _startMongoDB() {
    let dataStoreMap = this._getDataStoreTestConfiguration();
    for (let dataStore in dataStoreMap) {
      if (!dataStoreMap[dataStore].startsWith("mongo")) {
        continue;
      }

      if (await this._isMongoStarted(dataStoreMap[dataStore])) {
        await this._dropMongoDb(dataStoreMap[dataStore]);
      } else {
        dataStoreMap[dataStore] = (await this._getTestMongo()).getConnectionString(dataStore);
      }
    }
    if (Object.keys(dataStoreMap).length == 0) {
      let testMongo = await this._getTestMongo();
      dataStoreMap["primary"] = testMongo.getConnectionString("primary");
      dataStoreMap["binary"] = testMongo.getConnectionString("binary");
    }

    Config.set("uuSubAppDataStoreMap", dataStoreMap);

    // start embedded db for uuAppBinaryStoreg02 library
    let configObject = Config.toJSON();
    for (let key of Object.keys(configObject)) {
      const binaryStoreUriMatch = /^uu_app_binarystore_?(.*)_uri$/.exec(key);
      if (binaryStoreUriMatch) {
        const binaryStoreUri = configObject[key];
        // use embedded mongo only if uri is configured and empty or it is mongodb uri and the mongodb is not running
        if (binaryStoreUri === null || binaryStoreUri === "" || (binaryStoreUri.startsWith("mongodb") && !(await this._isMongoStarted(binaryStoreUri)))) {
          const dbName = binaryStoreUriMatch[1] || "binary" + Date.now();
          const connectionString = (await this._getTestMongo()).getConnectionString(dbName);
          this._binaryg02Dbs[dbName] = connectionString;
          Config.set(key, connectionString);
        }
      }
    }
  }

  // returns original dataStoreMap from test.json (does not include embedded mongo uris)
  _getDataStoreTestConfiguration() {
    if (!this._testDataStoreMap) {
      this._testDataStoreMap = Config.get("uuSubAppDataStoreMap") || {};
    }
    return { ...this._testDataStoreMap };
  }

  async _dropMongoDb(connectionUri) {
    await this._mongoClientExec(connectionUri, async client => await client.db().dropDatabase());
  }

  async _mongoClientExec(connectionUri, operation) {
    let client = await MongoClient.connect(connectionUri, { useNewUrlParser: true, useUnifiedTopology: true });
    await operation(client);
    await client.close();
  }

  /**
   * Returns instance of the TestMongo. Starts a new one if it does not exist.
   * @return {Object} test MongoDb.
   * @private
   */
  async _getTestMongo() {
    if (!this._testMongo) {
      let options = {};
      if (this._opts.mongoDbVersion) {
        options.version = this._opts.mongoDbVersion;
      }
      if (this._opts.mongoDbStorageEngine) {
        options.storageEngine = this._opts.mongoDbStorageEngine;
      }
      if (this._opts.mongoDbReplSet) {
        options.replSet = this._opts.mongoDbReplSet;
      }
      this._testMongo = new TestMongo(options);
      await this._testMongo.start();
    }
    return this._testMongo;
  }

  /**
   * Starts embedded application server.
   * @param {String} appPath Path to application configuration file
   * @param {boolean} verbose Server verbosity
   * @private
   */
  async _startServer(appPath, verbose) {
    this._testServer = new TestServer(appPath, { verbose });
    await this._testServer.start();
    this._gatewayUrl = this._testServer.getGatewayUrl();
  }

  /**
   * Getter for backward compatibility.
   * @private
   */
  get asid() {
    return this.getAsid();
  }

  /**
   * Getter for backward compatibility.
   * @private
   */
  get awid() {
    return this.getAwid();
  }

  async _isMongoStarted(connectionUri) {
    let match = null;
    if ((match = connectionUri.match(/^mongodb:\/\/([^:\/]+)(:[^\/]+)?(\/[^\?]+)?/))) {
      let host = match[1];
      let port = (match[2] || ":27017").substr(1);

      return new Promise((resolve, reject) => {
        let socket = new Socket();
        socket.on("error", function() {
          resolve(false);
        });
        socket.connect(port, host, function() {
          socket.end();
          resolve(true);
        });
      });
    } else {
      return false;
    }
  }

  /**
   * Returns user by name.
   * @param userName name of the user
   * @returns {{uuIdentity}} user
   * @private
   */
  _getTestUser(userName) {
    const user = this._userMap[userName];
    if (!user) {
      throw new BaseError(`Login failed. User ${userName} not found`);
    }
    if (!user.uuIdentity) {
      throw new BaseError(`Login failed. User ${userName} has no defined uuIdentity to create instance of session.`);
    }
    return user;
  }

  /**
   * Prepares dtoIn for uuCMD sys/uuAppWorkspace/create.
   *
   * @param dtoIn with the input parameters
   * @param awid application workspace ID
   * @returns {Promise<*>} Response including filled dtoIn
   * @private
   */
  async _prepareCreateAppWorkspaceDtoIn(dtoIn, awid) {

    dtoIn.awid = awid;

    if (!dtoIn.awidLicenseOwnerList) {
      dtoIn.awidLicenseOwnerList = this._awidLicenseOwnerList;
    }

    if (!dtoIn.name) {
      dtoIn.name = this._awidName;
    }

    if (!dtoIn.description) {
      dtoIn.description = this._awidDescription;
    }

    if (!dtoIn.awidLicense) {
      dtoIn.awidLicense = this._awidLicense;
    }

    return dtoIn;
  }

  /**
   * Prepares dtoIn for uuCMD sys/uuSubAppInstance/init.
   *
   * @param dtoIn with the input parameters
   * @returns {Promise<*>} Response including filled dtoIn
   * @private
   */
  async _prepareInitAppInstanceDtoIn(dtoIn) {

    if (!dtoIn.sysState) {
      dtoIn.sysState = "active"
    }

    if (!dtoIn.uuAppProfileAsidAuthorities) {
      let user = this._getTestUser("AsidAuthorities");
      dtoIn.uuAppProfileAsidAuthorities = "urn:uuIdentity:" + user.uuIdentity;
    }

    return dtoIn;
  }

  async _setCacheTtl() {
    Config.set("uu_app_workspace_user_profile_cache_ttl", 0);
    Config.set("uu_app_workspace_object_user_profile_cache_ttl", 0);
    Config.set("uu_app_workspace_app_workspace_cache_ttl", 0);
    Config.set("uu_app_workspace_app_instance_cache_ttl", 0);
  }

}

module.exports = new TestHelper();
