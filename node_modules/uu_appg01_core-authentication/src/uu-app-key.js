"use strict";

const Errors = require("./errors/uu-app-key-errors");

const APP_KEY_URN_PREFIX = "urn:uuappkey:";

const IDENTIFIER = "[a-zA-Z0-9_]";
const VENDOR = `(${IDENTIFIER}{1,32})`;
const APP = `(${IDENTIFIER}{1,32})`;
const SUB_APP = `(${IDENTIFIER}{1,32})`;
const ASID = `(${IDENTIFIER}{1,32})`;
const AWID = `(${IDENTIFIER}{1,32})`;

const APP_KEY_REGEXP = new RegExp(
  `^(?:${APP_KEY_URN_PREFIX})?${VENDOR}(?:\\-(?:${APP}(?:\\-(?:${SUB_APP}(?:\\/(?:${ASID}(?:\\-(?:${AWID})?)?)?)?)?)?)?)?$`
);

/**
 * Class is used for designing relations. Holds information about product, asid and awid.
 * The value is entered from the left (right-side parts can be left empty).
 *
 * <pre>Format: {vendor}-{app}-{subApp}/{asid}-{awid}
 *
 * Valid values:
 * {vendor}-{app}-{subApp}/{awid}
 * {vendor}-{app}-{subApp}
 * {vendor}-{app}
 * {vendor}</pre>
 */
class UuAppKey {
  /**
   * New instance of UuAppKey should be created using {@link UuAppKey.parse} or {@link UuAppKey.valueOf}.
   * @private
   */
  constructor(vendor, app = null, subApp = null, asid = null, awid = null) {
    this._vendor = vendor;
    this._product = vendor;
    this._app = app;
    if (app) {
      this._product += `-${app}`;
    }
    this._subApp = subApp;
    if (subApp) {
      this._product += `-${subApp}`;
    }
    this._asid = asid;
    this._awid = awid;

    Object.freeze(this);
  }

  /**
   * Parses a string value to instance.
   *
   * @param {string} value value to be parsed
   * @return {UuAppKey} instance
   */
  static parse(value) {
    if (value instanceof UuAppKey) {
      return value;
    }

    let result = (value || "").match(APP_KEY_REGEXP);
    if (!result) {
      throw new Errors.InvalidAppKey(value);
    }

    let asid, awid;
    if (result[5]) {
      asid = result[4];
      awid = result[5];
    } else {
      awid = result[4];
      asid = null;
    }

    return new UuAppKey(result[1], result[2], result[3], asid, awid);
  }

  /**
   * Creates instance.
   *
   * @param {string} vendor vendor
   * @param {string} app app
   * @param {string} supApp sub application
   * @param {string} asid asid
   * @param {string} awid awid
   * @return {UuAppKey} instance
   */
  static valueOf(vendor, app, supApp, asid, awid) {
    // check consistency
    // vendor is mandatory
    if (!(vendor || "").match(`^${VENDOR}$`)) {
      throw new Errors.InvalidAppKeyPart("vendor", vendor);
    }
    // other parts are optional, but they has to be entered from the left
    let partialAppKey = false;
    [[APP, app, "app"], [SUB_APP, supApp, "subApp"], [AWID, awid, "awid"], [ASID, asid, "asid"]].forEach(
      ([regexp, partValue, partName]) => {
        if (!partValue) {
          partialAppKey = true;
        } else {
          if (partialAppKey) {
            throw new Errors.InconsistentAppKey(partName, partValue);
          }
          if (!partValue.match(`^${regexp}$`)) {
            throw new Errors.InvalidAppKeyPart(partName, partValue);
          }
        }
      }
    );

    const appKey = new UuAppKey(vendor, app, supApp, asid, awid);
    return appKey;
  }

  /**
   * Getter for composed product property.
   *
   * @return {string} product
   */
  getProduct() {
    return this._product;
  }

  /**
   * Getter for property vendor.
   *
   * @return {string} vendor
   */
  getVendor() {
    return this._vendor;
  }

  /**
   * Getter for property app.
   *
   * @return {string} app
   */
  getApp() {
    return this._app;
  }

  /**
   * Getter for property subApp.
   *
   * @return {string} subApp
   */
  getSubApp() {
    return this._subApp;
  }

  /**
   * Getter for property asid.
   *
   * @return {string} asid
   */
  getAsid() {
    return this._asid;
  }

  /**
   * Getter for property awid.
   *
   * @return {string} awid
   */
  getAwid() {
    return this._awid;
  }

  /**
   * Creates string representation of the appKey.
   *
   * @return {string} UuAppKey string value
   */
  toString() {
    let parts = this._asid ? [["/", this._asid], ["-", this._awid]] : [["/", this._awid]];

    let result = this._product;
    for (let partPair of parts) {
      if (partPair[1]) {
        result += partPair.join("");
      } else {
        break;
      }
    }

    return result;
  }

  /**
   * Returns regular expression (based on attributes of UuAppKey instance).
   *
   * @return {string} regular expression
   */
  getRegExp() {
    let parts = [["\\-", this._app], ["\\-", this._subApp]];
    parts = parts.concat(
      this._asid || !this._awid ? [["\\/", this._asid], ["\\-", this._awid]] : [["\\/(.+\\-)?", this._awid]]
    );

    let result = this._vendor;
    for (let partPair of parts) {
      if (partPair[1]) {
        result += partPair.join("");
      } else {
        result += partPair[0] + ".*";
        break;
      }
    }

    return result;
  }

  /**
   * Indicates whether some other object is equal to this one.
   *
   * @param {UuAppKey} UuAppKey UuAppKey with which to compare
   * @return {boolean} true if equal
   */
  equals(appKey) {
    if (appKey == this) {
      return true;
    }

    if (!appKey || !(appKey instanceof UuAppKey)) {
      return false;
    }

    return (
      this.getVendor() == appKey.getVendor() &&
      this.getApp() == appKey.getApp() &&
      this.getSubApp() == appKey.getSubApp() &&
      this.getAwid() == appKey.getAwid() &&
      this.getAsid() == appKey.getAsid()
    );
  }

  /**
   * Compares parts of UuAppKey instance with set value against parts of UuAppKey argument.
   * This method doesn't ensure symmetric comparison (e.g. if a==b then b==a) as it compares only non-null parts of the UuAppKey instance it is called on.
   *
   * @param {UuAppKey} appKey UuAppKey with which to compare
   * @return {boolean} true if this non null appKey parts are the same as parts of the appKey argument
   */
  compareNonNullParts(appKey) {
    if (appKey == this) {
      return true;
    }

    if (!appKey || !(appKey instanceof UuAppKey)) {
      return false;
    }

    return (
      this.getVendor() == appKey.getVendor() &&
      (!this.getApp() || this.getApp() == appKey.getApp()) &&
      (!this.getSubApp() || this.getSubApp() == appKey.getSubApp()) &&
      (!this.getAwid() || this.getAwid() == appKey.getAwid()) &&
      (!this.getAsid() || this.getAsid() == appKey.getAsid())
    );
  }
}

module.exports = UuAppKey;
