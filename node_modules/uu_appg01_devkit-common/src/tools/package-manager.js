const child_process = require("child_process");
const fs = require("fs");
const path = require("path");

class Npm {
  constructor(config) {
    this.config = config || {};
  }
  async install(options) {
    return this._execute(options.command || "install", options);
  }
  async uninstall(options) {
    return this._execute(options.command || "uninstall", options);
  }
  async _execute(command, { packages, save, saveDev, saveExact, logLevel, cwd, exitOnFailure }) {
    let { executable = "npm", genericArgs = [] } = this.config;

    let args = genericArgs.concat([command]);
    if (Array.isArray(arguments[1].args)) args = args.concat(arguments[1].args);
    if (typeof save === "boolean") args.push(save ? "--save" : "--no-save");
    if (typeof saveDev === "boolean") args.push(saveDev ? "--save-dev" : "--no-save-dev");
    if (typeof saveExact === "boolean") args.push(saveExact ? "--save-exact" : "--no-save-exact");
    if (logLevel) args.push("--loglevel=" + logLevel);
    if (Array.isArray(packages)) args.push(...packages);

    var result = child_process.spawnSync(executable, args, {
      shell: true,
      cwd: cwd,
      stdio: "inherit",
    });
    if (result.status && exitOnFailure) process.exit(1);
    return result;
  }
  isForced() {
    return this.config.forced;
  }
}

class Pnpm extends Npm {
  constructor(config = {}) {
    super({
      executable: "pnpm",
      ...config,
    });
  }
  install(opts) {
    let command = Array.isArray((opts || {}).packages) && opts.packages.length > 0 ? "add" : "install";
    let usedOpts;
    if (command === "install") {
      let { packages, save, saveDev, saveExact, ...restOpts } = opts;
      usedOpts = restOpts;
    } else {
      usedOpts = { ...opts, args: ["--ignore-workspace-root-check"] };
    }
    usedOpts.command = command;
    return super.install(usedOpts);
  }
  uninstall(opts) {
    let usedOpts = { ...opts, command: "remove" };
    return super.uninstall(usedOpts);
  }
}

function initInstance() {
  let name;  
  
  // figure out package manager from node_modules/ if it exists
  let isRoot = fs.existsSync("uuapp.json");
  if (fs.existsSync("node_modules/.pnpm") || !isRoot && fs.existsSync("../node_modules/.pnpm")) {
    name = "pnpm";
  } else if (fs.existsSync("node_modules") || !isRoot && fs.existsSync("../node_modules")) {
    name = "npm";
  }
  
  // use package manager as preferred by env variable
  let forced;
  if (!name) {
    let fallbackName = process.env.UU_APPG01_DEVKIT_PM;
    name = fallbackName;
    forced = true;
  }

  // try to use pnpm
  if (!name) {
    try {
      let pnpmResult = child_process.spawnSync("pnpm -v", { shell: true, cwd: process.cwd(), stdio: "pipe" });
      if (pnpmResult.status === 0 && pnpmResult.stdout.toString().trim() > "0") name = "pnpm";
    } catch (e) {
      // ignore and fallback to using npm
    }
  }
  let allowedValues = new Set(["npm", "pnpm"]);
  let packageManager = allowedValues.has(name) ? name : allowedValues.values().next().value || "npm";

  let result;
  switch (packageManager) {
    case "pnpm":
      result = new Pnpm({ forced });
      break;
    case "npm":
      result = new Npm({ forced });
      break;
    default:
      throw new Error(`Using package manager '${packageManager}' is not supported.`);
  }
  return result;
}

let instance;
class PackageManager {
  static getInstance() {
    if (!instance) instance = initInstance();
    return instance;
  }
  static async install({
    packages,
    save,
    saveDev,
    saveExact,
    logLevel = "error",
    cwd = process.cwd(),
    exitOnFailure = true,
  } = {}) {
    return PackageManager.getInstance().install({ packages, save, saveDev, saveExact, logLevel, cwd, exitOnFailure });
  }
  static async uninstall({
    packages,
    logLevel = "error",
    cwd = process.cwd(),
    exitOnFailure = true,
  } = {}) {
    return PackageManager.getInstance().uninstall({ packages, logLevel, cwd, exitOnFailure });
  }
}
PackageManager.Npm = Npm;
PackageManager.Pnpm = Pnpm;

module.exports = PackageManager;
