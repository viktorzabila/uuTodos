const path = require("path");
const fs = require("fs");

const Package = require("../../src/tools/package.js");

let globalInstance;

module.exports = class ProjectConfig {
  constructor({ mode, commandLineConfig, packageJsonSource, appJsonSource } = {}) {
    this.mode = mode;
    this.commandLineConfig = commandLineConfig;
    this.packageJsonSource = packageJsonSource || new PackageJsonSource();
    this.appJsonSource = appJsonSource || new AppJsonSource();
    this.buildTimestamp = process.env.BUILD_TIMESTAMP || (new Date()).toISOString().replace(/[\-:T]/g, "").split(".")[0];
    process.env.BUILD_TIMESTAMP = this.buildTimestamp;
    this.overrides = {};
    this._merged = null;
  }
  setMode(mode) {
    if (this === globalInstance) process.env.NODE_ENV = mode;
    if (this.mode === mode) return;
    this.mode = mode;
    this._merged = null;
  }
  getMode() {
    return this.mode;
  }
  getUsedMode() {
    return this.mode || process.env.NODE_ENV || "development";
  }
  getBuildTimestamp() {
    return this.buildTimestamp;
  }
  /** If using multi build (or if allAvailable is true), returns list of libraries involved. */
  getWorkspaceLibraryList(allAvailable = false) {
    let result;
    if (this.appJsonSource && typeof this.appJsonSource.getWorkspaceLibraryList === "function") {
      result = this.appJsonSource.getWorkspaceLibraryList(allAvailable);
    }
    return result || [];
  }
  setCommandLineConfig(config) {
    let { environment, mode, ...rest } = config || {};
    this.commandLineConfig = rest;
    if (environment || mode) this.setMode(environment || mode);
    this._merged = null;
  }
  set(/* a) key, value;  b) set */) {
    if (arguments.length === 2) {
      this.overrides[arguments[0]] = arguments[1];
      if (arguments[1] == null) this._merged = null;
      // setting null means "fallback to other source"
      else if (this._merged) this._merged[arguments[0]] = arguments[1];
    } else if (arguments.length === 1 && arguments[0] && typeof arguments[0] === "object") {
      Object.assign(this.overrides, arguments[0]);
      if (hasNulls(arguments[0])) this._merged = null;
      else if (this._merged) Object.assign(this._merged, arguments[0]);
    }
  }
  get(key) {
    this._ensureLoaded();
    return this._merged[key];
  }
  getAll() {
    this._ensureLoaded();
    return this._merged;
  }
  toCommandLineArgs() {
    // TODO Pass from other sources / overrides also (but not from package.json / uuapp.json / mode file / defaults).
    let args = [];
    if (this.commandLineConfig) {
      args = args.concat(this.commandLineConfig._commandLineArgs);
      // args = args.concat(
      //   Object.keys(this.commandLineConfig).map(key => {
      //     let value = this.commandLineConfig[key];
      //     let dashKey = key.replace(/[A-Z]/g, m => "-" + m.toLowerCase());
      //     if (value == null) return "--" + dashKey;
      //     if (typeof value === "boolean") return (value ? "--" : "--no-") + dashKey;
      //     else if (typeof value === "number" || typeof value === "string") return "--" + dashKey + "=" + value;
      //     else console.warn(`Cannot convert value to command line arg - ignoring; key=${key}, value:`, value);
      //   })
      // ); // TODO Append remaining args (non-options).
    }
    return args;
  }

  _ensureLoaded() {
    if (!this._merged) {
      let mode = this.getUsedMode();
      let sources = []; // last wins
      sources.push(this.packageJsonSource);
      sources.push(this.appJsonSource);
      sources.push(this === globalInstance ? ModeSource.forMode(mode) : new ModeSource(mode));
      sources.push(this.commandLineConfig);
      sources.push(this.overrides);

      this._merged = sources.filter(Boolean).reduce((map, source) => {
        let obj;
        if (typeof source.getConfig === "function") obj = source.getConfig();
        else obj = source;
        obj = removeNulls(obj);
        return Object.assign(map, obj);
      }, {});
    }
  }

  static get instance() {
    if (!globalInstance) globalInstance = new ProjectConfig();
    return globalInstance;
  }
};

class AppJsonSource {
  getConfig() {
    if (!this._data) this._data = this.load();
    return this._data;
  }
  load() {
    let appJsonPath = this._getAppJsonPath();
    if (!appJsonPath) return null;
    let appJson = JSON.parse(fs.readFileSync(appJsonPath, "utf-8"));
    let curDirName = appJsonPath.startsWith("..") ? path.basename(process.cwd()) : ".";
    let { [curDirName]: specificCfg, ...result } = appJson;
    if (specificCfg) Object.assign(result, specificCfg);
    return result;
  }
  getWorkspaceLibraryList(allAvailable = false) {
    if (this._libraryList === undefined) {
      this._libraryList = null;
      let appJsonPath = this._getAppJsonPath();
      if (appJsonPath) {
        let appJson = require(path.resolve(appJsonPath));
        let reservedKeys = new Set(["product", "version", "license", "description"]);
        let root = Object.keys(appJson)
          .filter((it) => reservedKeys.has(it))
          .reduce((r, k) => ((r[k] = appJson[k]), r), {});
        let keys = Object.keys(appJson).filter((it) => !reservedKeys.has(it));
    
        this._libraryList = keys
          .map((name) => {
            if (name === ".") return;
            if (appJson[name] && appJson[name].version) return; // same-release-cycle modules must have same version (i.e. from root of uuapp.json)
            let modulePath = path.resolve(appJsonPath, "..", name);
            let modulePkgJsonPath = path.resolve(modulePath, "package.json");
            if (!fs.existsSync(modulePkgJsonPath)) return;
            let pkg = Package.getSingletonSync(modulePkgJsonPath);
            let type = pkg.templateInfo.type;
            if (!type || !type.match(/lib$/)) return;
            return { name, path: modulePath, type, ...root, ...appJson[keys], pkg: pkg.get() };
          })
          .filter(Boolean);
        
        let topLevelPkgPath = path.resolve(appJsonPath, "../package.json");
        if (fs.existsSync(topLevelPkgPath)) {
          let { spec } = Package.getSingletonSync(topLevelPkgPath).get();
          this._libraryListEnabled = (typeof spec === "string" && spec.match(/nodejs-multi/));
        } else {
          this._libraryListEnabled = false;
        }
      }
    }
    return allAvailable || this._libraryListEnabled ? this._libraryList : [];
  }

  _getAppJsonPath() {
    if (this._appJsonPath === undefined) {
      if (fs.existsSync("uuapp.json")) this._appJsonPath = "uuapp.json";
      else if (fs.existsSync(path.join("..", "uuapp.json"))) this._appJsonPath = path.join("..", "uuapp.json");
      else this._appJsonPath = null;
    }
    return this._appJsonPath;
  }
}

class PackageJsonSource {
  getConfig() {
    if (!this._data) this._data = this.load();
    return this._data;
  }
  load() {
    let values = Package.getSingletonSync("package.json").get();
    let { name, version, namespace, babel, jest } = values;
    return { name, version, namespace, babel, jest };
  }
}

class ModeSource {
  constructor(mode) {
    this.mode = mode;
  }
  static forMode(mode) {
    let result = ModeSource.modes[mode];
    if (!result) result = ModeSource.modes[mode] = new ModeSource(mode);
    return result;
  }
  getConfig() {
    if (!this._data) this._data = this.load();
    return this._data;
  }
  load() {
    let result = null;
    let filePath = path.join("env", this.mode + ".json");
    if (fs.existsSync(filePath)) result = JSON.parse(fs.readFileSync(filePath, "utf-8"));
    return result;
  }
}
ModeSource.modes = {};

function removeNulls(obj) {
  let result = obj;
  if (obj && typeof obj === "object") {
    result = Object.keys(obj)
      .filter(it => obj[it] != null)
      .reduce((r, it) => ((r[it] = obj[it]), r), {});
  }
  return result;
}

function hasNulls(obj) {
  let result = false;
  if (obj && typeof obj === "object") {
    result = Object.keys(obj).some(it => obj[it] == null);
  }
  return result;
}
