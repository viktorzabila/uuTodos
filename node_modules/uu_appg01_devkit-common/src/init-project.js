const path = require("path");
const util = require("util");

const fs = require("fs-extra");
const klaw = require("klaw");

const Package = require("./tools/package.js");
const StringUtil = require("./tools/string-util.js");
const { processFile } = require("./tools/template-helpers");
const ProjectConfig = require("./config/project-config.js");
const { VALUE_PLACEHOLDER, APP_JSON_KEY_ORDER } = require("./tools/constants.js");

const PRETTIER_DEFAULTS = {
  printWidth: 120
};

let fs_readFile = util.promisify(fs.readFile);
let fs_writeFile = util.promisify(fs.writeFile);

const APP_SERVER_README_TITLE = "uuApp Server Project (NodeJs)";

const APP_SERVER_README_LINK = "https://uuapp.plus4u.net/uu-bookkit-maing01/2590bf997d264d959b9d6a88ee1d0ff5/book/page?code=getStarted";

const APP_CLIENT_README_TITLE = "uuApp Client Project (UU5)";

const APP_CLIENT_README_LINK = "https://uuapp.plus4u.net/uu-bookkit-maing01/ed11ec379073476db0aa295ad6c00178/book/page?code=getStartedHooks";

const LIB_UU5_README_TITLE = "UU5 Library Project";

const LIB_UU5_README_LINK = "https://uuapp.plus4u.net/uu-bookkit-maing01/e884539c8511447a977c7ff070e7f2cf/book/page?code=uuLibCreation";

const LIB_ISO_README_TITLE = "uuApp Library Project";

const LIB_ISO_README_LINK = "https://uuapp.plus4u.net/uu-bookkit-maing01/e884539c8511447a977c7ff070e7f2cf/book/page?code=uuLibCreation";

const LIB_NODE_README_TITLE = "uuApp Library Project";

const LIB_NODE_README_LINK = "https://uuapp.plus4u.net/uu-bookkit-maing01/e884539c8511447a977c7ff070e7f2cf/book/page?code=uuLibCreation";

module.exports = async function(opts) {
  let { stack, name, namespace, content, hasServer, hasClient, skipInstall } = opts || {};

  let targetDir = name;
  if (fs.existsSync(targetDir)) {
    console.log(`\nWARNING: Project ${targetDir} already exists, skipping.`);
    return;
  }
  console.log(`\nCreating project ${targetDir}:`);

  // create directory
  console.log("  Creating project structure...");
  fs.mkdirSync(targetDir);
  process.chdir(targetDir);

  try {
    // read existing uuapp.json (to use version, license and description for new projects)
    let [uuappJson, { version, license, description }] = await loadUuappJson("../uuapp.json", name);

    // create package.json
    let toolsVersion = require("../package.json").version; // we're assuming that our version is same as _devkit one
    let type = stack;
    let pack = new Package("package.json");
    let packageJson = {
      name,
      version: version,
      license: license,
      description: description,
      spec: `${stack}; uu_appg01_devkit`,
      engines: {
        node: ">=" + require("./config/preconditions").NODEJS_VERSION // this is just a plain-text hint, by default it is not enforced by node/npm
      },
      dependencies: {},
      devDependencies: {
        uu_appg01_devkit: `^${toolsVersion}`
      }
    };
    pack.set(packageJson);

    let namespaceApp = [pack.vendor, pack.nameNoVendor.replace(/[-_].*/, "").replace(/g\d{2}$/, "")]
      .map(it => it.replace(/^./, m => m.toUpperCase()))
      .join(""); // uu_demoappg01_main-client => UuDemoapp
    let namespaceAppSnakeCase = [pack.vendor, pack.nameNoVendor.replace(/[-_].*/, "").replace(/g\d{2}$/, "")].join("-"); // uu_demoappg01_main-client => uu-demoapp
    let namespaceAllParts = [
      pack.vendor,
      ...pack.nameNoVendor
        .replace(/-.*/, "")
        .replace(/g\d{2}($|_)/, "$1")
        .split("_")
    ]; // uu_demoappg01_main-client => [uu, demoapp, main]
    let context = {
      ...opts,
      vendor: pack.vendor,
      nameNoVendor: pack.nameNoVendor,
      nameWithVendor: pack.nameWithVendor,
      namespaceApp,
      namespaceAppSnakeCase,
      namespaceAllParts,
      app: pack.nameNoVendor.replace(/[-_].*/, ""),
      subApp: pack.nameNoVendor.replace(/-.*/, "").split("_")[1] || "",
      projectClassName: namespaceAllParts.slice(1).map((item) => {return (item.charAt(0).toUpperCase() + item.substr(1))}).join(""),
      projectClassFile: namespaceAllParts.slice(1).map((item) => {return item.toLowerCase()}).join("-"),
      creationYear: (new Date()).getFullYear(),
      appCode: name.split(/[-_]/).slice(0, -1).join(".").toUpperCase(),
      appName: name.split(/[-_]/).slice(0, -1).join("_").replace(/(_\w)/g, function (match) {
        return match[1].toUpperCase();
      }),
      appVersion: version,
      appLicense: license,
      appDescription: description,
      valuePlaceholder: VALUE_PLACEHOLDER,
      insomniaContextPath: name.replace(/_/g,"-").split("-server")[0],
      errorCode: namespaceAllParts.join("-"),
      workspaces: [], 
      devkitVersion: require("../package.json").version,
    };

    let isLib = type.endsWith("lib");

    let templatesDir = path.join(__dirname, "templates");
    let typeDir = path.join(templatesDir, "__" + (type === "nodejs-app" && !hasClient ? "nodejs-service" : type));
    let contentDir = path.join(typeDir, "__" + content);
    let packageJsonByTemplatePath = path.resolve(contentDir, "package-partial.json");
    if (!fs.existsSync(packageJsonByTemplatePath)) {
      packageJsonByTemplatePath = path.resolve(typeDir, "package-partial.json"); // NOTE Must not be named package.json because "npm pack" would omit it from packing.
    }
    let packageJsonByTemplateExpr = await fs_readFile(packageJsonByTemplatePath, "utf-8");
    let packageJsonByTemplate = JSON.parse(
      StringUtil.evalExpressions(packageJsonByTemplateExpr, context, packageJsonByTemplatePath)
    );
    Object.assign(packageJsonByTemplate, {
      name,
      prettier: PRETTIER_DEFAULTS
    });
    if (type !== "nodejs-app" && type !== "nodejs-service") packageJsonByTemplate["namespace"] = namespace;
    Object.keys(packageJsonByTemplate)
      .filter(k => packageJsonByTemplate[k] != null)
      .forEach(k => mergeDeep(packageJson, k, packageJsonByTemplate[k]));
    packageJson.spec = `${type}; uu_appg01_devkit@${toolsVersion}`;
    packageJson = Package.sort(packageJson);
    pack.set(packageJson);
    await pack.save();

    console.log("  Generating project content...");
    // prepare list of files to copy (merge templates/*, templates/__<type>/* and templates/__<type>/__<content>/*)
    let genericFiles = listFiles(templatesDir);
    let typeFiles = fs.existsSync(typeDir) ? listFiles(typeDir) : []; // project-type specific
    let contentFiles = fs.existsSync(contentDir) ? listFiles(contentDir) : [];

    // use both specific + generic files
    genericFiles = await genericFiles;
    let genericItems = genericFiles.map(fullPath => ({ relFile: path.relative(templatesDir, fullPath), fullPath }));
    typeFiles = await typeFiles;
    let specificItems = typeFiles.map(fullPath => ({ relFile: path.relative(typeDir, fullPath), fullPath }));
    contentFiles = await contentFiles;
    let contentItems = contentFiles.map(fullPath => ({ relFile: path.relative(contentDir, fullPath), fullPath }));

    let fileFilter = getFileFilter(type);
    let usedSet = new Set();
    let usedItems = [...contentItems, ...specificItems, ...genericItems]
      .filter(it => {
        let isNew = !usedSet.has(it.relFile);
        if (isNew) usedSet.add(it.relFile);
        return isNew;
      })
      .filter(it => fileFilter(it.relFile));

    let projectClassPrefix = namespaceAllParts.slice(1).map((item) => {return item.toLowerCase()}).join("-");
    // prettier-ignore
    const RENAME_MAP = {
      // NOTE The templates/ folder contains gitignore (no dot), because npm registry
      // automatically renames all .gitignore to .npmignore during publishing / downloading
      // https://github.com/npm/npm/issues/1862
      gitignore: ".gitignore",
      gitattributes: ".gitattributes",
      [path.join("app", "api", "controllers", "project-controller.js")]: path.join("app", "api", "controllers", `${projectClassPrefix}-controller.js`),
      [path.join("app", "dao", "project-mongo.js")]: path.join("app", "dao", `${projectClassPrefix}-mongo.js`),
      [path.join("app", "api", "errors", "project-use-case-error.js")]: path.join("app", "api", "errors", `${projectClassPrefix}-use-case-error.js`),
      [path.join("app", "api", "errors", "project-error.js")]: path.join("app", "api", "errors", `${projectClassPrefix}-error.js`),
      [path.join("app", "abl", "project-abl.js")]: path.join("app", "abl", `${projectClassPrefix}-abl.js`),
      [path.join("app", "api", "validation_types", "project-types.js")]: path.join("app", "api", "validation_types", `${projectClassPrefix}-types.js`),
      [path.join("bin", "project.js")]: path.join("bin", `${name}.js`)
    };

    let filesForParentDir = [".editorconfig", "README.md", "gitignore", "gitattributes"];
    if (isLib) filesForParentDir.push("LICENSE");
    filesForParentDir.forEach(item => {
      if (!fs.existsSync(path.join("..", RENAME_MAP[item] || item))) RENAME_MAP[item] = path.join("..", RENAME_MAP[item] || item);
      else usedItems = usedItems.filter(it => it.relFile !== item);
    });
    
    if (isLib) {
      // add workspace files to the root for library projects
      let libRootDir = path.join(templatesDir, "__lib-root");
      let parentDirFiles = await listFiles(libRootDir);
      let parentDirItems = parentDirFiles.map((fullPath) => {
        let relFile = path.relative(libRootDir, fullPath);
        return {
          relFile,
          fullPath,
          relDestFile: path.join("..", relFile === "package-partial.json" ? "package.json" : relFile),
        };
      });
      parentDirItems.push({
        relFile: "pnpmfile.js",
        fullPath: path.resolve(templatesDir, "pnpmfile.js"),
        relDestFile: path.join("..", "pnpmfile.js"),
      });
      usedItems = usedItems.concat(parentDirItems.filter((it) => !fs.existsSync(it.relDestFile)));
    }

    usedItems.forEach(it => (it.relDestFile = it.relDestFile || RENAME_MAP[it.relFile] || it.relFile));
    usedItems.sort((a, b) => (a.relDestFile < b.relDestFile ? -1 : 1));

    // copy files asynchronously in batches (there's a limit for the number of opened files on some systems)
    // console.log("Copying files.");
    let dirs = new Set();
    let copyFileFns = usedItems.map(({ relFile, fullPath, relDestFile }) => async () => {
      let isFile = path.basename(fullPath) !== "."; // directories use form of "<dir>/."
      let destFile = path.resolve(relDestFile);
      // console.log("  " + relDestFile);
      let targetFileDir = isFile ? path.dirname(destFile) : destFile;
      if (!dirs.has(targetFileDir)) {
        await fs.ensureDir(targetFileDir);
        dirs.add(targetFileDir);
      }
      if (isFile) await processFile(fullPath, destFile, context);
    });
    let copyPromise = batchExecute(20, copyFileFns);

    // enable beta versions if requested
    if (process.env.UUAPP_DEV_ENABLED) {
      fs.copyFileSync(path.resolve(templatesDir, "__npmrc-dev"), ".npmrc");
    } else if (process.env.UUAPP_BETA_ENABLED) {
      fs.copyFileSync(path.resolve(templatesDir, "__npmrc"), ".npmrc");
    }

    // generate/update uuapp.json while files are being copied
    console.log("  Registering project in uuapp.json...");
    let parsedProduct = Package.parseProduct(name);
    // TODO Throw if already exists with different values?
    if (uuappJson.product === undefined) uuappJson.product = parsedProduct.product;
    if (!uuappJson.version) uuappJson.version = pack.get().version;
    if (uuappJson.license === undefined) uuappJson.license = "License Commercial";
    if (uuappJson.description === undefined) uuappJson.description = { en: "", cs: "" };
    let specificCfg = uuappJson[parsedProduct.name];
    if (!specificCfg) specificCfg = uuappJson[parsedProduct.name] = {};
    if (isLib || parsedProduct.specifier === 'client') {
      specificCfg.namespace = namespace;
    }
    if (isLib) {
      if (uuappJson.docUri === undefined) uuappJson.docUri = "";
      if (uuappJson.imageUri === undefined) uuappJson.imageUri = "";
      if (uuappJson.flsUri === undefined) uuappJson.flsUri = "";
      if (uuappJson.slsUri === undefined) uuappJson.slsUri = "";
      if (specificCfg.sourceUri === undefined) {
        specificCfg.sourceUri = `https://cdn.plus4u.net/${parsedProduct.vendor}-${pack.nameNoVendor
          .replace(/-.*/, "")
          .replace(/_/g, "-")}/%s/${name}.min.js`;
      }
      if (specificCfg.componentList === undefined) specificCfg.componentList = [];
    }
    let devkit = uuappJson.devkit || (uuappJson.devkit = {});
    if (devkit.development === undefined) devkit.development = {};
    if (devkit.development.appBoxLocationUri === undefined) devkit.development.appBoxLocationUri = VALUE_PLACEHOLDER;
    if (devkit.development.appDeploymentUri === undefined && type !== "nodejs-lib") {
      devkit.development.appDeploymentUri = null;
    }
    if (devkit.development.resourcePoolUri === undefined && (type === "uu5-lib" || type === "lib")) {
      devkit.development.resourcePoolUri = VALUE_PLACEHOLDER;
    }
    uuappJson = Package.sort(uuappJson, APP_JSON_KEY_ORDER);
    await fs_writeFile("../uuapp.json", JSON.stringify(uuappJson, null, 2) + "\n", "utf-8");

    // wait for copying to end
    await copyPromise;
    if (type === "nodejs-app" || type === "nodejs-service") {
      // Rename test subfolder
      fs.renameSync(path.join(".", "test", "project"), path.join(".", "test", projectClassPrefix));
    } else if (type === "uu5-lib" && content === "decoration") {
      fs.ensureDirSync("src/assets");
    }

    // Update readme
    let readmeTitle = null;
    let readmeLink = null;
    if (type === "nodejs-app" || type === "nodejs-service") {
      readmeTitle = APP_SERVER_README_TITLE;
      readmeLink = APP_SERVER_README_LINK;
    } else if (type === "uu5-app") {
      readmeTitle = APP_CLIENT_README_TITLE;
      readmeLink = APP_CLIENT_README_LINK;
    } else if (type === "uu5-lib") {
      readmeTitle = LIB_UU5_README_TITLE;
      readmeLink = LIB_UU5_README_LINK;
    } else if (type === "lib") {
      readmeTitle = LIB_ISO_README_TITLE;
      readmeLink = LIB_ISO_README_LINK;
    } else if (type === "nodejs-lib") {
      readmeTitle = LIB_NODE_README_TITLE;
      readmeLink = LIB_NODE_README_LINK;
    }
    updateReadme(readmeTitle, readmeLink);
    updateInsomniaTemplate();
    if (isLib) {
      await updateLibWorkspace(name);
    }

    // install dependencies
    if (!skipInstall) {
      console.log(`  Installing packages (this may take a while)...`);
      const PackageManager = require("./tools/package-manager.js");
      await PackageManager.install();

      if (isLib && !fs.existsSync("../node_modules")) {
        console.log(`  Installing packages in workspace root (this may take a while)...`);
        await PackageManager.install({ cwd: path.resolve("..") });
      }
    }

    console.log("  ...finished.\n");
  } finally {
    process.chdir("..");
  }
};

async function loadUuappJson(filePath, name = undefined) {
  let uuappJson = {};
  if (await pathExists(filePath)) uuappJson = JSON.parse(await fs_readFile(filePath, "utf-8"));
  let version = uuappJson.version || "0.1.0";
  let license = "License Commercial";
  if (name && uuappJson[name] && uuappJson[name].license) {
    license = uuappJson[name].license;
  } else if (uuappJson.license) {
    license = uuappJson.license;
  }
  let description = "";
  if (name && uuappJson[name] && uuappJson[name].description) {
    description = typeof uuappJson[name].description === "object" ? uuappJson[name].description.en : uuappJson[name].description;
  } else if (uuappJson.description) {
    description = typeof uuappJson.description === "object" ? uuappJson.description.en : uuappJson.description;
  }
  return [uuappJson, { version, license, description }];
}

function mergeDeep(target, name, newValue, overwrite = false) {
  if (newValue == null) return;
  if (overwrite || target[name] == null) target[name] = newValue;
  else if (typeof newValue === "object") {
    Object.keys(newValue).forEach(it => mergeDeep(target[name], it, newValue[it], overwrite));
  }
}

function listFiles(dir) {
  return new Promise((resolve, reject) => {
    let dirAbsPath = path.resolve(dir);
    let klawOpts = {
      filter: fileName => fileName.substr(dirAbsPath.length).indexOf(path.sep + "__") === -1 // omit files/dirs starting with "__"
    };
    let files = [];
    klaw(dirAbsPath, klawOpts)
      .on("error", e => reject(e))
      .on("data", item => {
        if (item.stats.isFile()) files.push(item.path);
        else if (item.stats.isDirectory()) files.push(item.path + path.sep + ".");
      })
      .on("end", () => resolve(files));
  });
}

async function batchExecute(maxBatchSize, jobFns) {
  // runs all jobFns; at most maxBatchSize run in parallel at any time
  // NOTE Rejects on 1st error encountered (jobs that are in-flight at the time
  // of the error are not cancelled, i.e. they will finish later than the rejection).
  let { result } = await jobFns.reduce(
    async (partialResult, jobFn, i, arr) => {
      let { result, inFlightSet } = await partialResult;
      if (inFlightSet.size >= maxBatchSize) await Promise.race(inFlightSet);
      let jobPromise = Promise.resolve().then(jobFn);
      let jobPromiseWithRemoval = jobPromise.then(() => inFlightSet.delete(jobPromiseWithRemoval));
      inFlightSet.add(jobPromiseWithRemoval);
      result.push(jobPromise);
      return { result, inFlightSet };
    },
    { result: [], inFlightSet: new Set() }
  );
  return Promise.all(result);
}

function getFileFilter(type) {
  let excludedFiles;
  if (type === "nodejs-app") excludedFiles = ["config/config.js"];
  else if (type === "nodejs-lib" || type === "uu5-app") {
    excludedFiles = [
      "config/uucloud-config.json",
      "config/uucloud-descriptor.json"
    ];
  } else excludedFiles = [];
  excludedFiles.push("package-partial.json");
  excludedFiles = new Set(excludedFiles.map(item => item.replace(/\//g, () => path.sep))); // normalize path separator
  return f => !excludedFiles.has(f);
}

async function pathExists(path) {
  return new Promise(resolve => {
    fs.access(path, err => {
      resolve(!err);
    });
  });
}

function updateInsomniaTemplate() {
  let templatePath = path.resolve(".", "test", "insomnia", "insomnia-workspace.json");
  if (!fs.existsSync(templatePath)) {
    return;
  }
  let template = fs.readFileSync(templatePath).toString();

  const timestamp = Math.floor(Date.now() / 1000);
  const newTemplate = template.replace(/(wrk|env|fld|jar|pair|req)_[^"]+/g, (match) => {
    return `${match}_${timestamp}`;
  });

  fs.writeFileSync(templatePath, newTemplate);
}

function updateReadme(readmeTitle, readmeLink) {
  let readmePath = path.resolve("..", "README.md");
  if (!fs.existsSync(readmePath)) {
    return;
  }
  let readme = fs.readFileSync(readmePath).toString();
  if (!readmeTitle || readme.match(new RegExp(readmeTitle.replace(/\(/g, "\\(").replace(/\)/g, "\\)")))) {
    return;
  }
  let endsWithNewline = readme.endsWith("\n");
  readme = readme.concat(`${endsWithNewline ? "" : "\n"}- [${readmeTitle}](${readmeLink})${endsWithNewline ? "\n" : ""}`);
  fs.writeFileSync(readmePath, readme);
}

async function updateLibWorkspace(name) {
  let libraryList = new ProjectConfig().getWorkspaceLibraryList(true);

  // update workspaces
  let rootPkg = JSON.parse(fs.readFileSync("../package.json", "utf-8"));
  if (!Array.isArray(rootPkg.workspaces)) {
    rootPkg.workspaces = libraryList.map((it) => it.name).sort();
  } else if (!rootPkg.workspaces.includes(name)) {
    rootPkg.workspaces.push(name);
    rootPkg.workspaces.sort();
  }
  fs.writeFileSync("../package.json", JSON.stringify(rootPkg, null, 2) + "\n", "utf-8");

  let pnpmWorkspacesContent = fs.readFileSync("../pnpm-workspace.yaml", "utf-8");
  let matched;
  let modContent = pnpmWorkspacesContent.replace(
    /((?:^|\n)\s*packages:[ \t]*(?:#.*)?)((?:\r?\n[ \t]*\S+.*)*)/,
    (m, firstPart, pkgsStr) => {
      if (pkgsStr) pkgsStr = pkgsStr.replace(/^[ \t]*\r?\n[ \t]*-[ \t]*($|\r?\n)/, "$1"); // replace initial empty "\n  - \n" by "\n"
      let quotedPkgs = pkgsStr ? pkgsStr
        .trim()
        .replace(/#.*/g, "")
        .split("\n")
        .map((it) => it.trim().replace(/^-\s*/, "")) : [];
      matched = true;
      let result;
      if (!quotedPkgs.includes("'" + name + "'") && !quotedPkgs.includes(name)) {
        if (pkgsStr.indexOf("#") === -1) {
          result = firstPart + "\n  - " + [...quotedPkgs, `'${name}'`].sort().join("\n  - ");
        } else {
          result = pkgsStr + `\n  - '${name}'`;
        }
      } else {
        result = m;
      }
      return result;
    }
  );
  if (!matched) modContent += `\n\npackages:\n  - ${rootPkg.workspaces.map((it) => "'" + it + "'").join("\n  - ")}`;
  if (modContent !== pnpmWorkspacesContent) fs.writeFileSync("../pnpm-workspace.yaml", modContent, "utf-8");
}

// TODO Next major (5.x) - remove.
module.exports.upgradeToLibWorkspaceTopLevel = upgradeToLibWorkspaceTopLevel;
async function upgradeToLibWorkspaceTopLevel(libraryList, upgradeVersion = "") {
  if (libraryList.length === 0) {
    console.log(`${upgradeVersion} Upgrading to library workspace... skipped (no library projects are present).`)
    return;
  }
  console.log(`${upgradeVersion} Upgrading to library workspace`);
  let [uuappJson, { version, license, description }] = await loadUuappJson("uuapp.json");
  let { name } = Package.parseProduct(uuappJson.product);

  // copy files from templates/__lib-root folder
  console.log("  ...generating top-level files");
  let templatesMultiDir = path.resolve(__dirname, "templates", "__lib-root");
  let baseName = name.replace(/-.*/, "");
  let context = {
    name: baseName,
    appCode: baseName.split(/[-_]/).slice(0, -1).join(".").toUpperCase(),
    appName: baseName
      .split(/[-_]/)
      .slice(0, -1)
      .join("_")
      .replace(/(_\w)/g, function (match) {
        return match[1].toUpperCase();
      }),
    appVersion: version,
    appLicense: license,
    appDescription: description,
    valuePlaceholder: VALUE_PLACEHOLDER,
    devkitVersion: require("../package.json").version,
    workspaces: libraryList.map((it) => it.name).sort(),
  };
  let templateFiles = await listFiles(templatesMultiDir);
  for (let fullPath of templateFiles) {
    let targetFile = fullPath.substr(templatesMultiDir.length + path.sep.length);
    if (path.basename(targetFile) === "package-partial.json") {
      targetFile = path.dirname(targetFile) + path.sep + "package.json";
    }
    fs.ensureDirSync(path.dirname(targetFile));
    if (!fullPath.endsWith(path.sep + ".") && !fs.existsSync(targetFile)) {
      await processFile(fullPath, targetFile, context);
    }
  }
  await processFile(path.resolve(__dirname, "templates", "pnpmfile.js"), "pnpmfile.js", context);

  console.log("  ...finished.");
}
