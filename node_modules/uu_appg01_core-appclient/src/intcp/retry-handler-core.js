"use strict";

const Helpers = require("../app-client/helpers.js");
const InvalidParameters = require("../error/invalid-options-error.js");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { Json } = require("uu_appg01_core-utils");


/**
 * Core Interceptor for retry policy  working. Should be extended by retry and retry browser interceptor to avoid code duplication
 */
class RetryHandlerCore {
  constructor(next, options = null) {
    this._next = next;
    this._validateOptions(options);
    this._options = options.retryPolicy;
    this._attempt = 0;
    this._originalRequestId = null;
    this._logger = LoggerFactory.get("UuApp.AppClient.Interceptor.RetryHandler");
  }

  async invoke(request, options = null) {
    let response = await this._next.invoke(request, options);

    if (options != null) {
      this._options = Helpers.mergeOptions(this._options, options.retryPolicy);
    }

    this._originalRequestId = request.headers["x-request-id"];
    if (!this._shouldRetry(request, response, this._options)) {
      return response;
    }

    // Check if body contain streams
    if (
      request.headers["content-type"] &&
      (request.headers["content-type"].startsWith("multipart/form-data") ||
        request.headers["content-type"].startsWith("application/octet-stream")) &&
      this._containStream(request.body)
    ) {
      this._logger.debug(`Request failed and wont be repeated as it contains binary stream. requestId=${this._originalRequestId}`);
      return response;
    }

    response = await this._processRetryPolicy(request, response, options);
    return response;
  }

  async _processRetryPolicy(request, response, options) {
    let retryAfter = false;
    this._attempt++;

    if (!this._shouldRetry(request, response, this._options)) {
      return response;
    }

    if (response.status === 503) {
      let retryAfterHeader = this._parseHeaders(response.headers())["retry-after"];

      if (retryAfterHeader) {
        retryAfter = this._getRetryAfterFromHeader(retryAfterHeader);
      }
    }

    if (retryAfter && retryAfter > this._options.maxTimeInterval) {
      this._logger.debug(`Request wont be repeated. Response retry-after header is after max time interval. requestId=${this._originalRequestId}, retryAfter=${retryAfter}, maxTimeInterval=${this._options.maxTimeInterval}`);
      return response;
    }

    let sleepTime;
    request.headers["x-request-id"] = `${this._originalRequestId}-${this._attempt.toString().padStart(3, "0")}`;

    if (!retryAfter) {
      sleepTime = this._getRandomIntInclusive(
        0,
        Math.min(this._options.maxTimeInterval, this._options.baseTimeInterval * Math.pow(2, this._attempt))
      );
    }

    this._logger.error(`Request failed. Retry conditions valid, retrying the request in ${sleepTime}ms. originalRequestId=${this._originalRequestId}, originalResponseStatus=${response.status}, originalResponseData=${response.data}, attempt=${this._attempt}, retryPolicy=${Json.stringify(this._options)}`)
    await this._timeout(sleepTime);
    response = await this._next.invoke(request, options);

    return await this._processRetryPolicy(request, response, options);
  }

  async _timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  _parseHeaders(rawHeaders) {
    let parsedHeaders = {};
    rawHeaders.split("\n").forEach((header) => {
      const [key, value] = header.split(/\s*:\s/);
      parsedHeaders[key] = value;
    });
    return parsedHeaders;
  }

  _getRetryAfterFromHeader(retryAfter) {
    if (!retryAfter) {
      return false;
    }

    if (!isNaN(retryAfter)) {
      return parseInt(retryAfter) * 1000;
    }

    const retryDateTimestamp = Date.parse(retryAfter);

    if (isNaN(retryDateTimestamp)) {
      return false;
    }

    const diff = retryDateTimestamp - Date.now();

    if (diff <= 0) {
      return false;
    }

    return diff;
  }

  _getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  _shouldRetry(request, response, options) {
    // Check maxAttempts
    if (options.maxAttempts < 1) {
      return false;
    }

    if (this._attempt > this._options.maxAttempts) {
      this._logger.debug(`Request wont be repeated. Max attempts exceeded. requestId=${this._originalRequestId}, requestAttempt=${this._attempt}, maxAttempts=${this._options.maxAttempts}`);
      return false;
    }

    // Check http methods
    if (!this._checkHttpMethod(this._options.retryCondition.httpMethods, request.method)) {
      this._logger.debug(`Request wont be repeated. Http method condition invalid. requestId=${this._originalRequestId}, requestHttpMethod=${request.method}, retryHttpMethods=${this._options.retryCondition.httpMethods}`);
      return false;
    }

    // Check httpStatuses
    if (
      !this._options.retryCondition.httpStatusCodes ||
      !this._checkStatusCode(this._options.retryCondition.httpStatusCodes, response.status.toString())
    ) {
      this._logger.debug(`Request wont be repeated. Http status condition invalid. requestId=${this._originalRequestId}, responseHttpStatus=${response.status.toString()}, retryHttpStatus=${this._options.retryCondition.httpStatusCodes}`);
      return false;
    }

    return true;
  }

  _checkHttpMethod(requiredHttpMethods = [], method) {
    if (requiredHttpMethods.length < 1) {
      return false;
    }

    const normalizedMethod = method.toUpperCase();

    if (requiredHttpMethods.includes(normalizedMethod)) {
      return true;
    }

    return false;
  }

  _checkStatusCode(requiredStatuses = [], status) {
    const checkStatusRegex = new RegExp("[0-9]([0-9]|x){2}");
    const replacerRegex = new RegExp("x", "g");

    if (requiredStatuses.length < 1) {
      return false;
    }

    if (!status) {
      return false;
    }

    if (typeof status !== "string" || !status.match(checkStatusRegex)) {
      return false;
    }

    for (let requiredStatus of requiredStatuses) {
      const compareRegex = new RegExp(requiredStatus.replace(replacerRegex, "[0-9]"));

      if (status.match(compareRegex)) {
        return true;
      }
    }

    return false;
  }

  /* According to requirements body should be checked to avoid retry with streams inside body.
  * There are use-cases when body is stream by itself so we cannot retry it:

  * 1) Sending stream data with application/octet-stream header
  * 2) Sending FormData (or another data that will be converted to FormData by content transformers)
  *
  * In the second case if body is FormData we should check if it contains data that have streams, but in current
  * implementation it is not possible as after failure request data is not accessible. Also FormData have not entries method
  * to access data and the only way to do this is to use "_streams" private parameter that is not safety;
  *
  * As FormData is stream itself all requests with FormData body will not retry.
  * TODO The check might be improved in further implementation by rebuilding FormData one more time if it does not contain stream inside.
  */
  _containStream(body = {}) {
    if (this._isStream(body)) {
      return true;
    }

    return false;
  }

  _isStream(value) { // overridden by subclasses
    return false;
  }

  _validateOptions(options) {
    if (!options) {
      throw new InvalidParameters("Options are required in RetryHandler");
    }

    if (typeof options !== "object") {
      throw new InvalidParameters("Options must be object");
    }

    if (!options.retryPolicy) {
      throw new InvalidParameters("Options.retryPolicy is required");
    }

    if (typeof options.retryPolicy !== "object") {
      throw new InvalidParameters("Options.retryPolicy must be object");
    }

    if (!options.retryPolicy.maxTimeInterval) {
      throw new InvalidParameters("Options.retryPolicy.maxTimeInterval is required");
    }

    if (typeof options.retryPolicy.maxTimeInterval !== "number" || options.retryPolicy.maxTimeInterval < 0) {
      throw new InvalidParameters("Options.retryPolicy.maxTimeInterval must be positive integer");
    }

    if (!options.retryPolicy.baseTimeInterval) {
      throw new InvalidParameters("Options.retryPolicy.baseTimeInterval is required");
    }

    if (typeof options.retryPolicy.baseTimeInterval !== "number" || options.retryPolicy.baseTimeInterval < 0) {
      throw new InvalidParameters("Options.retryPolicy.baseTimeInterval must be positive integer");
    }

    if (options.retryPolicy.maxAttempts == null) {
      throw new InvalidParameters("Options.retryPolicy.maxAttempts is required");
    }

    if (typeof options.retryPolicy.maxAttempts !== "number" || options.retryPolicy.maxAttempts < 0) {
      throw new InvalidParameters("Options.retryPolicy.maxAttempts must be positive integer");
    }

    if (!options.retryPolicy.retryCondition) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition is required");
    }

    if (typeof options.retryPolicy.retryCondition !== "object") {
      throw new InvalidParameters("Options.retryPolicy.retryCondition must be object");
    }

    if (!options.retryPolicy.retryCondition.httpMethods) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpMethods is required");
    }

    if (!(options.retryPolicy.retryCondition.httpMethods instanceof Array)) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpMethods must be array");
    }

    options.retryPolicy.retryCondition.httpMethods.forEach((method) => {
      const availableMethods = ["GET", "POST", "HEAD", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"];
      if (!availableMethods.includes(method)) {
        throw new InvalidParameters(
          `Incorect httpMethod - ${method} in retryCondition.httpMethods list. Should be one of ${Json.stringify(
            availableMethods
          )}`
        );
      }
    });

    if (!options.retryPolicy.retryCondition.httpStatusCodes) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpStatusCodes is required");
    }

    if (!(options.retryPolicy.retryCondition.httpStatusCodes instanceof Array)) {
      throw new InvalidParameters("Options.retryPolicy.retryCondition.httpStatusCodes must be array");
    }

    options.retryPolicy.retryCondition.httpStatusCodes.forEach((method) => {
      const pattern = "[0-9]([0-9]|x){2}";
      const checkStatusRegex = new RegExp(pattern);

      if (typeof method !== "string") {
        throw new InvalidParameters("HttpStatusCode in retryCondition.httpStatusCodes list must be string");
      }

      if (!method.match(checkStatusRegex)) {
        throw new InvalidParameters(
          `HttpStatusCode in retryCondition.httpStatusCodes must meet regex pattern ${pattern}`
        );
      }
    });

    return true;
  }
}

module.exports = RetryHandlerCore;
