"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config, OptsReader, BaseError, Json } = require("uu_appg01_core-utils");
const { TokenSanitizer } = require("uu_appg01_core-authentication");
const Got = require("got");
const getStream = require("get-stream");
const FormData = require("form-data");
const Helpers = require("./helpers.js");
const { PassThrough, Readable } = require("stream");

const ACCESS_TOKEN_PARAM = "access_token";

class HttpClient {

  constructor(options = null) {
    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  }

  async invoke(request, options = null) {
    let opts = new OptsReader(options, this._options, Config);

    // enable self-signed certificates
    let sslOpts = new OptsReader(
      options,
      this._options, // remap Config param to internal opt
      { verifySsl: Config.get("uu_app_client_verify_ssl") }
    );
    let rejectUnauthorized = sslOpts.getBoolean("verifySsl", true);

    // TODO Implement abortion support
    // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));

    // check whether to send parameters in body or querystring
    let canHaveBody = request.method.match(/^(put|post)$/i);
    let url = request.uri.toString();
    let body;
    if (!canHaveBody) {
      // attach preserialized body as query for GET requests (see Form serializer)
      if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
    } else {
      body = request.body;
    }

    // map request parameters to underlying Got API
    let gotOptions = {
      method: request.method,
      headers: request.headers,
      body: canHaveBody ? this._transformBodyForGot(body) : undefined,
      retries: 0, // got retries twice by default
      https: {
        rejectUnauthorized
      }
    };

    // use FormData header that already includes proper multipart boundary
    if (body instanceof FormData) {
      gotOptions.headers["content-type"] = body.getHeaders()["content-type"];
    }

    gotOptions.headers["user-agent"] = `uuAppClient (Node.js)`;

    // transform timeout from s to ms
    let timeout = opts.getNumber("requestTimeout");
    if (timeout > 0) gotOptions.timeout = timeout * 1000;

    if (this._logger.isDebugLoggable()) {
      this._logger.debug(
        `Invoking request: ${Json.stringify({
          method: request.method,
          url: this._sanitizeQueryParameters(url),
          headers: this._sanitizeHeaders({ ...request.headers }),
          body: (body instanceof Readable || body instanceof FormData) ? "stream" : this._sanitizeBody(body)
        })}`
      );
    }

    let response = await new Promise(async (resolve, reject) => {
      let stream = Got.stream(url, gotOptions);

      stream.on("error", async (error) => {
        if (error.name === "HTTPError") {
          try {
            // moving relevant data to stream
            stream.headers = error.response.headers;
            stream.statusCode = error.response.statusCode;
            stream.body = error.response.body;
            resolve(stream);
          } catch (err) {
            reject(err);
          }
        } else {
          reject(new BaseError("Request failed", error));
        }
      });

      stream.on("response", async res => {
        try {
          // moving relevant data to stream
          stream.headers = res.headers;
          stream.statusCode = res.statusCode;
          resolve(await this._formatResponse(stream, opts));
        } catch (err) {
          reject(err);
        }
      });
    });

    if (this._logger.isDebugLoggable()) {
      this._logger.debug(`Received response: ${Json.stringify({ url, status: response.status, data: response.data })}`);
    }

    return Helpers.interceptorMakeResponse(response);
  }

  /**
   * Rerouting to a pass-through stream is necessary to
   * avoid Got reading out
   * @param {Response} stream
   * @returns {stream.PassThrough}
   * @private
   */
  _passThrough(stream) {
    let pt = new PassThrough();
    pt.statusCode = stream.statusCode;
    pt.headers = stream.headers;
    return stream.pipe(pt);
  }

  _transformBodyForGot(body) {
    if (body == null) return Buffer.from([]);
    if (this._isBodyValid(body)) return body;

    try {
      body = Json.stringify(body);
    } catch (e) {
      throw new BaseError("Unable to serialize body.", e);
    }

    return body;
  }

  _isBodyValid(body) {
    return typeof body === "string" || body instanceof Buffer || body instanceof Readable || body instanceof FormData;
  }

  async _formatResponse(res, opts) {
    const doNotTransform = opts.getBoolean("transformResponse", true) !== true;
    if (doNotTransform) return res;

    let cDisp = res.headers["content-disposition"];
    if (cDisp) {
      res.filename = _findMatch(cDisp);
      let cType = res.headers["content-type"];
      if (cType) {
        let cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
        res.contentType = cTypeItems[1] || null;
        res.encoding = cTypeItems[2] || null;
      }
      return res;
    }

    res.body = await getStream(res);

    return res;

    function _findMatch(cDisp) {
      let regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
      let match;
      let results = [];
      while ((match = regex.exec(cDisp)) != null) {
        results = results.concat(match.slice(1).filter(m => m));
      }

      let last = results[results.length - 1];

      return last ? decodeURIComponent(last) : null;
    }
  }

  _sanitizeHeaders(headers) {
    if (headers.authorization) {
      headers.authorization = TokenSanitizer.processHeader(headers.authorization);
    }
    return headers;
  }

  _sanitizeQueryParameters(url) {
    return TokenSanitizer.processUri(url);
  }

  _sanitizeBody(body) {
    if (typeof body === "string" && body.includes(ACCESS_TOKEN_PARAM)) {
      let parsedBody;
      try {
        parsedBody = Json.parse(body);
      } catch (e) {
        return body;
      }
      if (parsedBody[ACCESS_TOKEN_PARAM]) {
        parsedBody[ACCESS_TOKEN_PARAM] = TokenSanitizer.processToken(parsedBody[ACCESS_TOKEN_PARAM]);
      }
      body = Json.stringify(parsedBody)
    }
    return body;
  }

}

module.exports = HttpClient;
