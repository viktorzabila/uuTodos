"use strict";

const { LoggerFactory } = require("uu_appg01_core-logging");
const { Config, OptsReader, BaseError, Json } = require("uu_appg01_core-utils");
const { TokenSanitizer } = require("uu_appg01_core-authentication");
const Helpers = require("./helpers.js");

const ACCESS_TOKEN_PARAM = "access_token";

class HttpClient {

  constructor(options = null) {
    this._options = options;
    this._logger = LoggerFactory.get("UuApp.AppClient.Client");
  }

  // function InvokeClient (cmdClient, httpClientOpts, finalRequest, finalOpts) {
  async invoke(request, options = null) {
    let opts = new OptsReader(options, this._options, Config);

    // TODO Implement abortion support
    // if (cmdClient.aborted) return Promise.reject(Helpers.interceptorMakeResponse(null, finalRequest, { error: new AbortError("The Client call has been aborted.") }));

    let canHaveBody = request.method.match(/^(put|post)$/i);
    let url = request.uri.toString();
    let body;
    if (!canHaveBody) {
      if (request.body) url += (url.indexOf("?") === -1 ? "?" : "&") + request.body;
    } else {
      body = request.body;
    }
    let headers = request.headers;
    let timeout = opts.getNumber("requestTimeout", 300);
    if (this._logger.isDebugLoggable()) {
      this._logger.debug(
        "Invoking request: " +  Json.stringify({
            method: request.method,
            url: this._sanitizeQueryParameters(url),
            headers: this._sanitizeHeaders({ ...headers }),
            body: this._sanitizeBody(body),
            requestTimeout: timeout
          })
      );
    }

    let usedHeaders = {};
    for (let k in headers) {
      let v = headers[k];
      if (k && v != null) {
        // omit "Content-Type" header if it's multipart/form-data, otherwise the browser doesn't update
        // it with proper boundary and server won't be able to parse the body
        if (k === "content-type" && body instanceof FormData && v === "multipart/form-data") continue;
        usedHeaders[k.replace(/(^|-)./g, (m) => m.toUpperCase())] = v + "";
      }
    }

    let result;
    let responseInfo;
    try {
      let doFetch = async () => {
        if (typeof fetch === "undefined") {
          require("whatwg-fetch");
        }
        let requestData = {
          method: request.method,
          headers: usedHeaders,
          body
        };
        let credentialsPolicy = opts.getString("credentialsPolicy");
        if (credentialsPolicy) {
          requestData.credentials = credentialsPolicy;
        }
        return await fetch(url, requestData);
      };
      if (timeout > 0) doFetch = this._addAsyncFnTimeout(doFetch, timeout * 1000);
      let response = await doFetch();

      responseInfo = { response };
      const transformResponse = opts.getBoolean("transformResponse", true) === true;
      if (!transformResponse) responseInfo.responseType = "arraybuffer";
      else Object.assign(responseInfo, this._autodetectBinaryData(response));
      if (opts.getBoolean("enableStreamApi", false) === true && responseInfo.responseType === "arraybuffer") {
        responseInfo.responseType = "stream";
      }

      // status 200 - 5xx
      if (responseInfo.responseType === "stream") {
        responseInfo.body = this._getResponseStream(response);
      } else if (responseInfo.responseType === "arraybuffer") {
        responseInfo.body = new Uint8Array(await response.arrayBuffer());
      } else {
        responseInfo.body = await response.text();
      }
      if (this._logger.isDebugLoggable()) {
        this._logger.debug(
          "Received response: " +
            Json.stringify({
              url: url,
              status: response.status,
              data: responseInfo.body,
            })
        );
      }
      result = Helpers.interceptorMakeResponse(responseInfo);
    } catch (e) {
      if (e.name === "AbortError") {
        // user / developer abort; AbortError
        this._logger.warn("Request has been aborted: " + Json.stringify({ url: url }), e);
        result = Promise.reject(
          Helpers.interceptorMakeResponse(responseInfo, {
            error: new BaseError("Request has been aborted - " + url, e),
          })
        );
      } else if (e.name === "TimeoutError") {
        // TimeoutError
        this._logger.error("Request timed out: " + Json.stringify({ url: url }), e);
        result = Promise.reject(
          Helpers.interceptorMakeResponse(responseInfo, { error: new BaseError("Request timed out - " + url, e) })
        );
      } else {
        // network / other error
        this._logger.error("Request ended with error: " + Json.stringify({ url: url }), e);
        result = Promise.reject(
          Helpers.interceptorMakeResponse(responseInfo, {
            error: new BaseError("Error - " + url, e),
            data: responseInfo ? responseInfo.body : null,
          })
        );
      }
    }
    return result;
  }

  _addAsyncFnTimeout(runnableFn, timeout) {
    return async () => {
      let timeoutId;
      let timeoutPromise = new Promise(
        (resolve, reject) =>
          (timeoutId = setTimeout(() => {
            let error = new Error("Timed out.");
            error.name = "TimeoutError";
            reject(error);
          }, timeout))
      );
      let runnablePromise = runnableFn();
      return Promise.race([runnablePromise, timeoutPromise]).finally(() => clearTimeout(timeoutId));
    };
  }

  _autodetectBinaryData(fetchResponse) {
    function _findMatch(cDisp) {
      let regex = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g;
      let match;
      let results = [];
      while ((match = regex.exec(cDisp)) != null) {
        results = results.concat(match.slice(1).filter((m) => m));
      }

      let last = results[results.length - 1];

      return last ? decodeURIComponent(last) : null;
    }

    let cDisp;
    try {
      cDisp = fetchResponse.headers.get("Content-Disposition");
    } catch (e) {
      // do nothing
    }

    if (!cDisp) return;

    let responseInfo = {};
    responseInfo.responseType = "arraybuffer";
    responseInfo.filename = _findMatch(cDisp);
    let cType = fetchResponse.headers.get("Content-Type");
    if (cType) {
      let cTypeItems = cType.trim().match(/^([^;\s]+)(?:\s*;\s*charset\s*=\s*([^;]+))?/i) || [];
      responseInfo.contentType = cTypeItems[1] || null;
      responseInfo.encoding = cTypeItems[2] || null;
    }

    return responseInfo;
  }

  _getResponseStream(response) {
    let listeners = {};
    let emitEvent = (event, ...args) => {
      let list = listeners[event];
      if (list) {
        let listCopy = [...list];
        listCopy.forEach((listenerFn) => {
          try {
            listenerFn(...args);
          } catch (e) {
            this._logger.error(e);
            // continue with next listener
          }
        });
      }
    };

    let stream = response.body || {}; // we'll return object with on() fn even for browsers not supporting Streams API
    stream.on = (event, callback) => {
      if (!listeners[event]) listeners[event] = [];
      listeners[event].push(callback);
      if (event === "data" || event === "end" || event === "error") startConsumingStream();
    };
    if (!stream[Symbol.asyncIterator]) {
      stream[Symbol.asyncIterator] = async function* () {
        // if stream isn't really stream then return just single chunk with all data
        if (typeof ReadableStream === "undefined" || !(stream instanceof ReadableStream)) {
          let allData = new Uint8Array(await response.arrayBuffer());
          yield allData;
          return;
        }

        let reader = stream.getReader();
        try {
          // eslint-disable-next-line no-constant-condition
          while (true) {
            let { done, value } = await reader.read();
            if (done) break;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      };
    }

    let startedConsumingStream = false;
    let startConsumingStream = async () => {
      if (startedConsumingStream) return;
      startedConsumingStream = true;
      try {
        for await (let chunk of stream) {
          emitEvent("data", chunk);
        }
        emitEvent("end");
      } catch (e) {
        if (!listeners["error"]) this._logger.error(e);
        emitEvent("error", e);
      }
    };

    return stream;
  }

  _sanitizeHeaders(headers) {
    if (headers.authorization) {
      headers.authorization = TokenSanitizer.processHeader(headers.authorization);
    }
    return headers;
  }

  _sanitizeQueryParameters(url) {
    return TokenSanitizer.processUri(url);
  }

  _sanitizeBody(body) {
    if (typeof body === "string" && body.includes(ACCESS_TOKEN_PARAM)) {
      let parsedBody;
      try {
        parsedBody = Json.parse(body);
      } catch (e) {
        return body;
      }
      if (parsedBody[ACCESS_TOKEN_PARAM]) {
        parsedBody[ACCESS_TOKEN_PARAM] = TokenSanitizer.processToken(parsedBody[ACCESS_TOKEN_PARAM]);
      }
      body = Json.stringify(parsedBody)
    }
    return body;
  }

}

module.exports = HttpClient;
