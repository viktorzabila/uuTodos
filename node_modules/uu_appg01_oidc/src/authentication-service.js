"use strict";

const Os = require("os");
const Fs = require("fs");
const Util = require("util");
const fsReadFile = Util.promisify(Fs.readFile);
const fsExists = Util.promisify(Fs.exists);
const Path = require("path");
const Process = require("process");
const { BaseError, Digest, Base64, ValueConverter, Config } = require("uu_appg01_core-utils");
const CoreAuthenticationService = require("uu_appg01_core-authentication").AuthenticationService;
const { InvalidCredentials, AuthenticationError } = require("uu_appg01_core-authentication");
const { LoggerFactory } = require("uu_appg01_core-logging");
const DefaultServiceLoader = require("./internal/default-service-loader.js");
const OAuthClient = require("./internal/oauth-client.js");
const OAuthCode = require("./internal/oauth-code.js");
const ClientCredentialsProvider = require("./internal/client-credentials-provider.js");
const OidcSession = require("./session.js");
const { ContextStore } = require("uu_appg01_core-utils");
let UseCaseContext = null;
try {
  UseCaseContext = require("uu_appg01_core-appserver").UseCaseContext;
} catch (e) {
  UseCaseContext = null;
}

const DEFAULT_ACCESS_TOKEN_PATTERN = ".*";
const DEFAULT_REFRESH_TOKEN_PATTERN = ".*";
const DEFAULT_VERIFY_AUDIENCE = false;
const UU_CLOUD_ENV_VARIABLE = "UU_CLOUD_HOST_NAME";

const META_SERVICE_NAME = "uu_appg01_oidc";

const OAUTH_CODE = "code";
const OAUTH_REDIRECT_URI = "redirect_uri";
const JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;

const asid = Config.get("asid");

/**
 * Implementation of authentication service based on uuOIDC.
 */
class OidcAuthenticationService {

  /**
   * Load and initialize authentication service(s)
   * @param reconfigure
   */
  static load(reconfigure = false) {
    DefaultServiceLoader.load(OidcAuthenticationService, reconfigure);
  }

  /**
   * Creates new instance of uuOIDC authentication service and registers it
   * as authentication service with given name.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  static create(name, opts = {}) {
    // Do not allow reinitialization of already registered services
    let force = opts.force || false;
    if (!force && this._providers[name]) {
      return;
    }

    let authService = new this(name, opts);
    // Register service in global authentication service component
    CoreAuthenticationService._register(name, authService);
    // Register oidc meta-service to be able to use multiple oidc providers via generic API
    CoreAuthenticationService._register(META_SERVICE_NAME, this);
    // Store service localy
    // (to be able to choose service based on tokens)
    this._providers[name] = authService;
    if (!this._primaryProvider) {
      this._primaryProvider = name;
    }
  }

  /**
   * Authenticates user.
   * @param {Object|String} credentials User credentials to be verified (data object or token string)
   * @param {String} credentials.access_code1 User access code 1
   * @param {String} credentials.access_code2 User access code 2
   * @param {String} credentials.code Value for OAuth code flow
   * @param {String} credentials.systemIdentity Value for OAuth Client Credentials Flow
   * @param {String|null} scope Scope (single value or array) representing functionality to be invoked within session.
   * @param {Object} opts Authentication options.
   * @param {Boolean} opts.allowPasswordFile If set to false, password file authentication will be disabled. Default value is true.
   * @returns {Promise<Session>} User session for passed user credentials.
   * @throws {InvalidCredentials} In case credentials are not valid.
   * @throws {AuthenticationError} In case authentication fails.
   */
  static async authenticate(credentials, scope = null, opts = {}) {
    if (opts.allowPasswordFile !== false) {
      credentials = await this._resolvePasswordFileCredentials(credentials);
    }
    let supportedServices = [];
    if (!credentials) {
      // In case of interactive login, we just have to use primary service
      // (we cannot try multiple services due to required browser interaction)
      supportedServices.push(this._providers[this._primaryProvider]);
    } else {
      // In case of given credentials, find all services supporting it
      // (primary service should be always first to check)
      let primaryProvider = this._providers[this._primaryProvider];
      if (await primaryProvider.areCredentialsSupported(credentials)) {
        supportedServices.push(primaryProvider);
      }
      for (let provider of Object.values(this._providers)) {
        if (provider.getServiceName() !== this._primaryProvider) {
          if (await provider.areCredentialsSupported(credentials)) {
            supportedServices.push(provider);
          }
        }
      }
    }
    if (supportedServices.length === 0) {
      throw new InvalidCredentials("Unsupported credentials.");
    }
    // Iterate throuth each service supporting credentials and try to authenticate
    let authenticationErrors = [];
    for (let service of supportedServices) {
      try {
        //In case of successful authentication return immediately
        return await service.authenticate(credentials, scope, opts);
      } catch (e) {
        // Remember service name and authentication error
        authenticationErrors.push([service.getServiceName(), e]);
      }
    }
    let logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
    for (let [serviceName, error] of authenticationErrors.slice(0, -1)) {
      logger.error(`Authentication with ${serviceName} failed.`, error);
    }
    //In case authentication did not succeed, throw last error
    throw authenticationErrors.pop()[1];
  }

  static async authenticateSystemIdentity(scope) {
    if (UseCaseContext && UseCaseContext.getUri()) {
      return OidcAuthenticationService.authenticate({ systemIdentity: UseCaseContext.getUri().getAwid() }, scope);
    } else {
      return OidcAuthenticationService.authenticate({ systemIdentity: asid }, scope);
    }
  }


  /**
   * Returns name of primary authentication service.
   * @returns {String} Name of primary authentication service
   */
  static getServiceName() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getServiceName() : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   */
  static async getServiceUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? (await primaryProvider.getServiceUri()) : null;
  }

  /**
   * Returns URI of primary authentication service.
   * @returns {String} URI of primary authentication service
   * @deprecated
   */
  static getProviderUri() {
    let primaryProvider = this._providers[this._primaryProvider];
    return primaryProvider ? primaryProvider.getProviderUri() : null;
  }

  /**
   * Creates new instance of uuOIDC authentication service.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  constructor(name, opts = {}) {
    if (!name) {
      throw new BaseError("Service name is not defined");
    }
    this._serviceName = name;
    this._serviceUri = opts.serviceUri;
    if (!this._serviceUri) {
      throw new BaseError(`There is no service URI defined for service ${this._serviceName}`);
    }
    this._accessTokenPattern = new RegExp(opts.accessTokenPattern || DEFAULT_ACCESS_TOKEN_PATTERN);
    this._refreshTokenPattern = new RegExp(opts.refreshTokenPattern || DEFAULT_REFRESH_TOKEN_PATTERN);
    this._doVerifyAudience = (typeof opts.verifyAudience === "boolean") ? opts.verifyAudience : DEFAULT_VERIFY_AUDIENCE;
    // Allow audience alias by default in uuCloud environment (checked by presence of specific uuCloud environment variable)
    this._allowAudienceAlias = (typeof opts.allowAudienceAlias === "boolean") ? opts.allowAudienceAlias : !!process.env[UU_CLOUD_ENV_VARIABLE];
    let oauthRealization;
    if (opts.oauthRealization) {
      let sourcePath = Config.get("server_root") || Process.cwd();
      oauthRealization = ValueConverter.toClass(opts.oauthRealization, sourcePath);
    } else {
      oauthRealization = OAuthClient;
    }
    this._oauthClient = new oauthRealization(this._serviceUri, opts);
    this._oauthCode = new OAuthCode(this._serviceUri, opts);
    this._callTokenType = opts.callTokenType;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
  }

  /**
   * Returns Returns name of authentication service.
   * @returns {String} Name of authentication service
   */
  getServiceName() {
    return this._serviceName;
  }

  /**
   * Returns URI of authentication service.
   * @returns {String} URI of authentication service
   */
  async getServiceUri() {
    return (await this._oauthClient.getIssuerList())[0];
  }

  /**
   * Returns URI of authentication service.
   * @returns {String|Uri|*} URI of authentication service
   * @deprecated
   */
  getProviderUri() {
    return this._serviceUri;
  }

  /**
   * Checks if credentials are supported by service.
   * @param credentials Credentials to be checked.
   * @return {Promise<boolean>} True if credentials are supported
   */
  async areCredentialsSupported(credentials) {
    if (typeof credentials === "string") {
      if (credentials.match(JWT_TOKEN_REGEX)) {
        let tokenIssuer = null;
        try {
          tokenIssuer = JSON.parse(Base64.urlSafeDecode(credentials.split(".")[1])).iss;
        } catch (e) {
          throw new InvalidCredentials("Token is not trusted (unknown token issuer).", e);
        }
        let supportedIssuers = await this._oauthClient.getIssuerList();
        return supportedIssuers.includes(tokenIssuer);
      } else {
        return !!credentials.match(this._accessTokenPattern);
      }
    } else if (typeof credentials === "object") {
      return true;
    } else {
      return false;
    }
  }

  async authenticate(credentials, scope = null, opts = {}) {
    if (opts.allowPasswordFile !== false) {
      credentials = await OidcAuthenticationService._resolvePasswordFileCredentials(credentials);
    }
    let session = null;
    if (!credentials) {
      if (!this._oauthCode.isSupported()) {
        throw new InvalidCredentials("Missing credentials.");
      }
      let clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
      try {
        credentials = await this._oauthCode.get(clientId, scope);
      } catch (e) {
        throw new AuthenticationError("Authentication failed.", e);
      }
      session = await this.authenticate(credentials, scope);
    } else if (typeof credentials === "string") {
      let supportedAcrValues;
      let claims;
      let idToken;
      let accessToken;
      if (JWT_TOKEN_REGEX.test(credentials)) {
        claims = await this._oauthClient.parseToken(credentials, this._callTokenType, true, null);
        if (this._doVerifyAudience) {
          await this._verifyAudience(claims);
        }
        supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        if (this._callTokenType === "idToken") {
          idToken = credentials;
          accessToken = null;
        } else if (this._callTokenType === "accessToken") {
          idToken = null;
          accessToken = credentials;
        } else {
          // uuOidc by default uses JWT format only for idToken
          idToken = credentials;
          accessToken = null;
        }
      } else {
        let tokenKey = Digest.sha1(credentials);
        claims = await this._oauthClient.getToken(tokenKey);
        if (!claims) {
          let clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          claims = await this._oauthClient.parseToken(credentials, this._callTokenType, true, clientCredentials);
          if (this._doVerifyAudience) {
            await this._verifyAudience(claims);
          }
          this._oauthClient.cacheToken(tokenKey, claims.exp, claims);
        }
        supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        if (this._callTokenType === "idToken") {
          idToken = credentials;
          accessToken = null;
        } else if (this._callTokenType === "accessToken") {
          idToken = null;
          accessToken = credentials;
        } else {
          // uuOidc by default uses JWT format only for idToken
          idToken = null;
          accessToken = credentials;
        }

      }
      session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, idToken, accessToken);
    } else {
      let clientCredentials = credentials.clientCredentials;
      if (credentials[OAUTH_CODE]) {
        if (!clientCredentials) {
          clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
        }
        let authorizationCode = credentials[OAUTH_CODE];
        let redirectUri = credentials[OAUTH_REDIRECT_URI];
        let token = await this._oauthClient.grantAuthorizationCodeToken(authorizationCode, clientCredentials, redirectUri, scope);
        let claims = await this._oauthClient.parseToken(token.id_token, "idToken");
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, token.id_token, token.access_token);
      } else if (credentials.systemIdentity) {
        const awid = credentials.systemIdentity;
        if (awid === asid) {
          if (UseCaseContext && UseCaseContext.getUri() && UseCaseContext.getUri().getAwid() !== asid) {
            this._logger.info(`Authentication of asid System Identity ${asid} from awid request scope ${UseCaseContext.getUri().getAwid()}.`);
          }
        } else {
          if (!UseCaseContext || !UseCaseContext.getUri()) {
            throw new AuthenticationError("Authentication of System Identity failed. Unable to load request context.");
          }

          if (UseCaseContext.getUri().getAwid() !== awid) {
            throw new InvalidCredentials("Invalid System Identity credentials. It is forbidden to authenticate System Identity of different awid.");
          }
        }
        let clientId;
        if (clientCredentials) {
          clientId = clientCredentials.client_id;
        } else {
          clientId = await ClientCredentialsProvider.getClientId(this._serviceName, awid);
        }

        let tokenKey;
        if (Array.isArray(scope)) {
          tokenKey = Digest.sha1(`${clientId}:${scope.sort().join("|")}`);
        } else {
          tokenKey = Digest.sha1(`${clientId}:${scope}`);
        }
        let token = this._oauthClient.getToken(tokenKey);
        if (!token) {
          if (!clientCredentials) {
            clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName, awid);
          }
          token = await this._oauthClient.grantClientCredentialsToken(clientCredentials, scope);
          let expiresAt = token.expires_at || Number((Date.now() / 1000) + token.expires_in);
          this._oauthClient.cacheToken(tokenKey, expiresAt, token);
        }
        let claims = await this._oauthClient.parseToken(token.id_token, "idToken");
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, token.id_token, token.access_token);
      } else {
        let clientId;
        if (clientCredentials) {
          clientId = clientCredentials.client_id;
        } else {
          clientId = await ClientCredentialsProvider.getClientId(this._serviceName);
        }
        let username = credentials.username || credentials.accessCode1 || credentials.access_code1;
        let password = credentials.password || credentials.accessCode2 || credentials.access_code2;
        if (!username || !password) {
          throw new InvalidCredentials("Unsupported credentials.");
        }
        let tokenKey;
        if (Array.isArray(scope)) {
          tokenKey = Digest.sha1(`${username}:${clientId}:${scope.sort().join("|")}`);
        } else {
          tokenKey = Digest.sha1(`${username}:${clientId}:${scope}`);
        }
        let token = this._oauthClient.getToken(tokenKey);
        if (!token) {
          if (!clientCredentials) {
            clientCredentials = await ClientCredentialsProvider.getClientCredentials(this._serviceName);
          }
          token = await this._oauthClient.grantResourceOwnerPasswordCredentialsToken(username, password, clientCredentials, scope);
          let expiresAt = token.expires_at || Number((Date.now() / 1000) + token.expires_in);
          this._oauthClient.cacheToken(tokenKey, expiresAt, token);
        }
        let claims = await this._oauthClient.parseToken(token.id_token, "idToken");
        let supportedAcrValues = await this._oauthClient.getSupportedAcrValues();
        session = new OidcSession(this._serviceName, this._oauthClient, supportedAcrValues, claims, token.id_token, token.access_token);
      }
    }
    return session;
  }

  async authenticateSystemIdentity(scope) {
    if (UseCaseContext && UseCaseContext.getUri()) {
      return this.authenticate({ systemIdentity: UseCaseContext.getUri().getAwid() }, scope);
    } else {
      return this.authenticate({ systemIdentity: asid }, scope);
    }
  }

  async _verifyAudience(claims) {
    let serviceUri = null;
    let serviceUriAlias = null;
    if (UseCaseContext && ContextStore.get("uuapp.server.endpoint")) {
      serviceUri = UseCaseContext.getUri().toString();
      if (this._allowAudienceAlias) {
        let baseUriAlias = UseCaseContext.getBaseUriAlias();
        if (baseUriAlias) {
          serviceUriAlias = `${baseUriAlias}/${UseCaseContext.getUri().getUseCase()}`;
        }
      }
    }
    let audienceClaim = claims.aud ? (Array.isArray(claims.aud) ? claims.aud : [claims.aud]) : [];
    let checkServiceUri = serviceUri && audienceClaim.length > 1;
    let clientId = null;
    if (!checkServiceUri) {
      clientId = (await ClientCredentialsProvider.getClientId(this._serviceName));
    }
    for (let audience of (audienceClaim)) {
      if (checkServiceUri) {
        if (serviceUri.startsWith(audience) || (serviceUriAlias && serviceUriAlias.startsWith(audience))) {
          return true;
        }
      } else {
        if (clientId === audience) {
          return true;
        }
      }
    }
    throw new InvalidCredentials(`Token scope does not match (verified value: "${checkServiceUri ? serviceUri : clientId}", received scope: [${audienceClaim.join(", ")}]).`);
  }

  static async _resolvePasswordFileCredentials(credentials) {
    if (typeof credentials !== "string") {
      return credentials;
    }
    let passwdFilePath = credentials;
    if (!Path.isAbsolute(passwdFilePath)) {
      passwdFilePath = Path.join(Os.homedir(), ".uu", passwdFilePath);
    }
    if (!(await fsExists(passwdFilePath))) {
      return credentials;
    }
    credentials = {};
    let passwdFileContent = await fsReadFile(passwdFilePath, "utf8");
    passwdFileContent = passwdFileContent.replace(/\r\n?/g, "\n");
    passwdFileContent.split("\n").forEach(function(line) {
      line = line.trim();
      if (/^[#!]/.test(line)) {
        return;
      }
      let [name, value] = line.split(/[=:](.*)/, 2);
      name = name ? name.trim() : null;
      if (name) {
        value = value ? value.trimLeft() : null;
        credentials[name] = value ? value : null;
      }
    });
    return credentials;
  }

}

OidcAuthenticationService._providers = {};
OidcAuthenticationService._primaryProvider = null;

// Load all available OIDC authentication services
OidcAuthenticationService.load(false);

module.exports = OidcAuthenticationService;
