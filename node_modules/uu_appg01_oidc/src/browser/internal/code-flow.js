"use strict";

const { AuthenticationError } = require("uu_appg01_core-authentication");
const { AppClient } = require("uu_appg01_core-appclient");
const AbstractAuthorizationFlow = require("./abstract-authorization-flow.js");
const ImplicitFlow = require("./implicit-flow.js");

const RESPONSE_TYPE = "code";
const RESTORE_SESSION_FORCED = "forced";
const WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
const CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");

class CodeFlow extends AbstractAuthorizationFlow {

  constructor(oauthClient, serviceName, redirectUri, appBaseUri) {
    super(oauthClient, serviceName, redirectUri);
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._redirectUri = redirectUri;
    this._appBaseUri = appBaseUri;
    this._client = new AppClient();
    // Code based flow uses implicit flow to obtain call token for external services
    this._implicitFlow = new ImplicitFlow(oauthClient, serviceName, redirectUri, appBaseUri);
  }

  getResponseType() {
    return RESPONSE_TYPE;
  }

  createAuthState(authCtx = null, usePopup = null) {
    let result = super.createAuthState(authCtx, usePopup);
    result.redirectUri = this._redirectUri;
    return result;
  }

  async restoreSession(options, scope = null) {
    let isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    options = {prompt: "none", ...options};
    if (!isAuthCallback && AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED) {
      // We have to load metadata, else redirect will not work
      // due to requirement of metadata being available locally
      await this._oauthClient.getMetadata();
      delete options.prompt;
      options.usePopup = false;
      // Store current referrer to provide it after redirect
      sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
    }
    return super.restoreSession(options, scope);
  }

  authenticate(options, scope = null) {
    let promise = super.authenticate(options, scope);
    let result = promise.then(({ authResponse, state, nonce, scope, acrValues, maxAge, clientId }) => {
      return this._processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId);
    });
    result.uiComponent = promise.uiComponent;
    return result;
  }

  /**
   * @param {*} aLoginCallbackResult
   * @returns OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
   */
  getAuthResponseFromCallback(aLoginCallbackResult) {
    // extract login token
    // example of successful aLoginCallbackResult: "...?code=...&state=...
    // example of error aLoginCallbackResult:      "...?error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
    let authResponse = {};
    aLoginCallbackResult.replace(/^[^?#]*[?#]?/, "").replace(/#/, "&").split(/&/).filter(Boolean).forEach(it => {
      let eqlIdx = it.indexOf("=");
      let key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
      let value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx+1)).replace(/\+/g, " "));
      authResponse[key] = value;
    });
    return authResponse;
  }

  refreshSession(options, scope = null) {
    options = {prompt: "none", usePopup: false, ...options};
    return super.refreshSession(options, scope);
  }

  getCallToken(options, scope = null) {
    return this._implicitFlow.getCallToken(options, scope);
  }

  getEndSessionUri() {
    let endSessionUri = this._appBaseUri + "oidc/logout";
    let csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
    if (csrfToken) {
      endSessionUri += `?csrf_token=${encodeURIComponent(csrfToken)}`;
    }
    return endSessionUri;
  }

  isEndSessionIdTokenHintRequired() {
    return false;
  }

  // ======================== Protected methods ================================

  async _processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId) {
    let authResponseTime = Date.now();
    await this._validateAuthResponse(authResponse, state, nonce);
    let claims = (await this._client.get(this._appBaseUri + "oidc/introspect", {_: Date.now()})).data;
    delete claims.session_info;
    delete claims.uuAppErrorMap;

    let { session_expires_in, session_state } = authResponse;
    let globalSessionExpiresAt = session_expires_in ? authResponseTime + 1000 * session_expires_in : null;
    sessionStorage.removeItem("uu_app_oidc_auth_cb");
    let authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
    if (authenticationContext) {
      authenticationContext = JSON.parse(authenticationContext);
      sessionStorage.removeItem("uu_app_oidc_auth_ctx");
    }

    return {
      claims: claims,
      idToken: null,
      accessToken: null,
      authenticationContext: authenticationContext,
      globalSessionExpiresAt: globalSessionExpiresAt,
      globalSessionState: session_state,
      clientId: clientId,
      scope: scope,
      acrValues: acrValues,
      maxAge: maxAge
    };
  }

  // ======================== Private methods ================================

  async _validateAuthResponse(authResponse, state, nonce) {
    // validate state
    if (state && authResponse.state !== state) {
      throw new AuthenticationError("Invalid 'state' in received authorization response. Expected " + state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));
    }
  }

}

module.exports = CodeFlow;
