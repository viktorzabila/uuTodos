const {Config, Digest} = require("uu_appg01_core-utils");
const {LoggerFactory} = require("uu_appg01_core-logging");
const OidcSession = require("../../session.js");
const ExternalCallTokenProvider = require("./external-call-token-provider.js");
const Dom = require("../ui/dom.js");

const STORE_PREFIX = "uu_app_oidc_providers_";
const CONFIG_PREFIX = "uu_app_oidc_providers_";
const JWT_CLAIM_EXP = "exp";

// TODO Constant for workaround to allow sending of word values to G01
const G02_ACR_VALUES_OLD = ["none", "low", "medium", "high", "veryHigh"];
const G02_ACR_VALUES = ["none", "low", "standard", "high", "veryHigh"];

const logger = LoggerFactory.get("uuapp.oidc.Session");

class BrowserSession {

  static from(session, authenticationContext, expiresAt, state, authnService) {
    if (!session) return session;

    // Cache base uri without trailing slashes (to be used when call token is requested)
    session._appBaseUri = Dom.appBaseUri.replace(/\/$/, "");
    session._canonicalAppBaseUri = Dom.canonicalAppBaseUri && Dom.canonicalAppBaseUri.replace(/\/$/, "");

    // Add frontend specific method for returning authentication context
    session._authnCtx = authenticationContext || null;
    session.getAuthenticationContext = function () {
      return this._authnCtx;
    }.bind(session);

    // Add frontend specific method for returning session expiration time
    session._expiresAt = expiresAt || null;
    session.getExpiresAt = function () {
      return this._expiresAt;
    }.bind(session);

    // Add frontend specific method for returning session state
    session._state = state || null;
    session.getState = function () {
      return this._state;
    }.bind(session);

    // Add frontend specific field authnService required by ExternalCallTokenProvider
    Object.defineProperty(session, "_authnService", {
      get() {
        return authnService;
      },
      enumerable: false
    });

    // Override session.getCallTokenScope in order to provide
    // valid scope also for application using aliases
    session._origGetCallTokenScope = session.getCallTokenScope.bind(session);
    session.getCallTokenScope = function(uri = null, opts = {}) {
      if (!uri) {
        return null;
      }
      let scope = null;
      if (uri.startsWith(this._appBaseUri) || (this._canonicalAppBaseUri && uri.startsWith(this._canonicalAppBaseUri))) {
        scope = Dom.canonicalAppBaseUri || Dom.appBaseUri;
        scope = scope.replace(/\/$/, "");
      } else {
        scope = this._origGetCallTokenScope(uri, opts);
      }
      return scope;
    }.bind(session);

    // Override session.getCallToken to support providing of tokens
    // for external calls without use of token exchange which is not
    // possible to realize on frontend
    session.getCallToken = async function(scope = null, opts = {}) {
      let token;
      if (scope && !scope.startsWith(this._appBaseUri) && !(this._canonicalAppBaseUri && scope.startsWith(this._canonicalAppBaseUri))) {
        token = await ExternalCallTokenProvider.getCallToken(session, scope, opts);
      } else {
        let callTokenType = opts ? opts.callTokenType : null;
        if (!callTokenType) {
          let cfgKey = `${this._configPrefix}call_token_type`;
          callTokenType = Config.getString(cfgKey);
        }
        if (callTokenType === "idToken") {
          token = this._idToken;
        } else if (callTokenType === "accessToken") {
          token = this._accessToken;
        } else if (!callTokenType) {
          token = this._idToken || this._accessToken;
        }
      }
      if (token) {
        let excludeAuthType = opts ? opts.excludeAuthenticationType : false;
        if (excludeAuthType === true) {
          return token;
        } else {
          return `Bearer ${token}`;
        }
      } else {
        return null;
      }
    }.bind(session);

    // Override session.close() to perform logout in browser environment
    session.close = async function() {
      this.removeFromCache();
      if (this._authenticated) {
        try {
          await session._authnService._authnFlow.endSession(session);
          if (typeof this._onCloseListener === "function") {
            this._onCloseListener(this);
          }
          session._authenticated = false;
          session._idToken = null;
          session._accessToken = null;
        } catch (e) {
          logger.warn("Logout finished but session might not be cancelled - server responded with unexpected callback.", e);
          // Invoke explicit session check which will cause logout in case session was successfully canceled
          session._authnService.checkSession();
        }
      }
    }.bind(session);

    // Add frontend specific method to check if session matches given constraints
    session.matches = function(acrValues, maxAge) {
      let minAuthenticationLevelOfAssurance;
      if (acrValues) {
        let supportedValues = this._supportedAcrValues;
        // TODO Workaround for renaming of "medium" acrValue on G02 server
        let requestedValuesStr = acrValues.toString();
        if (supportedValues.includes("medium")) {
          requestedValuesStr = requestedValuesStr.replace("standard", "medium");
        } else if (supportedValues.includes("standard")) {
          requestedValuesStr = requestedValuesStr.replace("medium", "standard");
        }
        // ...end of workaround
        // Transform all values to number and find minimum (so we can delegate
        // call to session.assertTrustiness)
        let requestedValues = requestedValuesStr.split(" ");
        let transformedValues = [];
        requestedValues.forEach(requestedValue => {
          let transformedValue = Number(requestedValue);
          if (isNaN(transformedValue)) {
            transformedValue = supportedValues.indexOf(requestedValue);
            // TODO Workaround for checking word values against G01
            if (transformedValue < 0) {
              transformedValue = G02_ACR_VALUES.indexOf(requestedValue);
            }
            if (transformedValue < 0) {
              transformedValue = G02_ACR_VALUES_OLD.indexOf(requestedValue);
            }
            // ...end of workaround
          }
          if (transformedValue >= 0) {
            transformedValues.push(transformedValue);
          }
        });
        minAuthenticationLevelOfAssurance = Math.min(...transformedValues);
      }
      let maxAuthenticationAge;
      if (maxAge) {
        maxAuthenticationAge = maxAge;
      }
      try {
        this.assertTrustiness({minAuthenticationLevelOfAssurance, maxAuthenticationAge});
        return true;
      } catch (e) {
        return false;
      }
    }.bind(session);

    // Add frontend specific method to store session to session store
    session.storeToCache = function(clientId = null) {
      let sessionData = {
        attributes: this._attributes,
        acrValues: this._supportedAcrValues,
        idToken: this._idToken,
        acccessToken: this._accessToken,
        authnCtx: this._authnCtx,
        expiresAt: this._expiresAt,
        state: this._state,
        authConstraints: this._authConstraints,
        userAgent: Digest.sha1(navigator.userAgent)
      };
      let storeKey = `${STORE_PREFIX}${this._serviceName}_session`;
      if (clientId) {
        storeKey += `_${Digest.sha1(clientId)}`
      }
      sessionStorage.setItem(storeKey, JSON.stringify(sessionData));
    }.bind(session);

    // Add frontend specific method to remove session from session store
    session.removeFromCache = function() {
      let storeKey = `${STORE_PREFIX}${this._serviceName}_session`;
      Object.keys(sessionStorage).forEach((key) => {
        if (key && key.toString().startsWith(storeKey)) {
          sessionStorage.removeItem(key);
        }
      });
    }.bind(session);

    return session;
  }

  static loadFromCache(authnService, clientId = null) {
    let serviceName = authnService.getServiceName();
    let storeKey = `${STORE_PREFIX}${serviceName}_session`;
    if (clientId) {
      storeKey += `_${Digest.sha1(clientId)}`
    }
    let sessionData = sessionStorage.getItem(storeKey);
    if (!sessionData) {
      return null;
    }
    try {
      sessionData = JSON.parse(sessionData);
      let now = Date.now() / 1000;
      let tokenExpiresAt = sessionData.attributes[JWT_CLAIM_EXP];
      let tokenLeeway = Config.getNumber(CONFIG_PREFIX + serviceName + "_token_refresh_leeway");
      if (tokenLeeway == null) tokenLeeway = 5 * 60;
      if ((sessionData.expiresAt && sessionData.expiresAt <= now) ||
          (tokenExpiresAt && (tokenExpiresAt - tokenLeeway) <= now)) {
        logger.warn(`Cached session for ${serviceName} is expired.`);
        sessionStorage.removeItem(storeKey);
        return null;
      }
      if (sessionData.userAgent != Digest.sha1(navigator.userAgent)) {
        logger.warn(`UserAgent does not match on cached session for service ${serviceName}.`);
        sessionStorage.removeItem(storeKey);
        return null;
      }
      let oauthClient = authnService._oauthClient;
      let session = new OidcSession(serviceName, oauthClient, sessionData.acrValues, sessionData.attributes, sessionData.idToken, sessionData.acccessToken);
      session._authConstraints = sessionData.authConstraints;
      return BrowserSession.from(session, sessionData.authnCtx, sessionData.expiresAt, sessionData.state, authnService);
    } catch (e) {
      logger.error(`Unable to restore cached session for ${serviceName}.`, e);
      return null;
    }
  }

}

module.exports = BrowserSession;
