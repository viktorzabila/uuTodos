"use strict";

const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");

const CONFIG_PREFIX = "uu_app_oidc_providers_";
const DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;

/**
 * Component providing tokens for external calls
 * (call to URLs outside of current application scope)
 */
class ExternalCallTokenProvider {

  /**
   * Returns token to be used by client to call functionality provided by other application server.
   * @param {Session} initSession Instance of current session in which scope we are requesting token.
   * @param {String|URI} callUri URI of called functionality.
   * @param {Object} opts Call token options.
   * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
   * @returns {Promise<String>} Call token
   */
  static async getCallToken(initSession, callUri, opts) {
    let serviceName = initSession.getServiceName();
    if (!serviceName || !initSession._oauthClient) {
      return null;
    }
    callUri = callUri ? callUri.toString() : "";
    let providerKey = `${serviceName}|${callUri}`;
    let provider = this._providers[providerKey];
    if (!provider) {
      provider = new this(initSession, callUri);
      this._providers[providerKey] = provider;
    }
    return provider._getCallToken(opts);
  }

  /**
   * Creates new external call token provider.
   * @param {Session} initSession Instance of current session in which scope we are requesting token.
   * @param {String} callUri Call URI for which to provide token
   */
  constructor(initSession, callUri) {
    this._serviceName = initSession.getServiceName();
    this._callUri = callUri;
    this._configPrefix = `${CONFIG_PREFIX}${this._serviceName}_`;
    this._tokenTimeLeeway = Config.getNumber(`${this._configPrefix}token_time_leeway`, false) || DEFAULT_TOKEN_TIME_LEEWAY;
    this._logger = LoggerFactory.get("uuapp.oidc.ExternalCallTokenProvider");
    this._authnFlow = initSession._authnService._authnFlow;
    this._runningPromise = null;
    this._idToken = null;
    this._accessToken = null;
    this._expireAt = null;

    initSession._authnService.addListener("sessionChanged", () => {
      this._idToken = null;
      this._accessToken = null;
      this._expireAt = null;
    });
  }

  async _getCallToken(opts = {}) {
    if (this._isExpired()) {
      if (!this._runningPromise) {
        this._logger.debug(`Requesting new call token for ${this._callUri}`);
        let authOpts = {prompt: "none", usePopup: false};
        if (this._authnFlow.getCallToken) {
          this._runningPromise = this._authnFlow.getCallToken(authOpts, this._callUri);
        } else {
          this._runningPromise = this._authnFlow.authenticate(authOpts, this._callUri);
        }
      }
      try {
        let {idToken, accessToken, claims, expireAt} = await this._runningPromise;
        this._idToken = idToken;
        this._accessToken = accessToken;
        if (expireAt) {
          this._expireAt = expireAt;
        } else {
          this._expireAt = claims.exp * 1000;
        }
        this._logger.debug(`Call token for ${this._callUri} received`);
      } catch (e) {
        this._logger.error(`Unable to get call token for ${this._callUri}`, e);
        return null;
      } finally {
        this._runningPromise = null;
      }
    }
    let token = null;
    let callTokenType = opts ? opts.callTokenType : null;
    if (!callTokenType) {
      let cfgKey = `${this._configPrefix}call_token_type`;
      callTokenType = Config.getString(cfgKey);
    }
    if (callTokenType === "idToken") {
      token = this._idToken;
    } else if (callTokenType === "accessToken") {
      token = this._accessToken;
    } else if (!callTokenType) {
      token = this._idToken || this._accessToken;
    }
    return token;
  }

  _isExpired() {
    if (!this._expireAt) {
      return true;
    }
    return Date.now() >= (this._expireAt - this._tokenTimeLeeway * 2);
  }

}

ExternalCallTokenProvider._providers = {};

module.exports = ExternalCallTokenProvider;
