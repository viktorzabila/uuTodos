const { DbConnection, UuDataStoreDao } = require("uu_appg01_datastore");
const { BulkResult, Lock } = require("uu_appg01_datastore");

const UnexpectedError = require("../dao_errors/unexpected-error");
const DuplicateKey = require("../dao_errors/duplicate-key");
const ExpiredLock = require("../dao_errors/expired-lock");
const NoiExceeded = require("../dao_errors/noi-exceeded");
const SoiExceeded = require("../dao_errors/soi-exceeded");
const ObjectLocked = require("../dao_errors/object-locked");
const ObjectNotFound = require("../dao_errors/object-not-found");
const LockDoesNotExist = require("../dao_errors/lock-does-not-exist");
const MissingRevision = require("../dao_errors/missing-revision");
const InvalidRevision = require("../dao_errors/invalid-revision");
const ObjectStoreError = require("../dao_errors/objectstore-error");

class Dao extends UuDataStoreDao {
  /**
   * constructor of the Dao
   * @param name {string}
   * @param maxNoi {integer}
   * @param maxSoi {integer}
   * @param customUri {string}
   */
  constructor(name, maxNoi, maxSoi, customUri) {
    super(name, maxNoi, maxSoi, customUri);
    this.Errors = {
      SoiExceeded,
      UnexpectedError,
      ObjectLocked,
      DuplicateKey,
      ObjectNotFound,
      LockDoesNotExist,
      ExpiredLock,
    };
  }

  /**
   * stores new uuObject in database
   * @async
   * @param uuObject {object}
   * @returns {Promise.<TResult>} {object}
   */
  async insertOne(uuObject, lock = null) {
    let self = this;
    uuObject = { ...uuObject };

    uuObject = super._convertId(uuObject);
    uuObject["sys"] = super._createStamps();

    if (lock) {
      if (!lock.isValid()) {
        throw new this.Errors.ExpiredLock();
      }
      uuObject["sys"] = { ...uuObject["sys"], ...{ lockHash: lock.hash }, lockExpTs: lock.expiration };
    }

    super._checkSoi(uuObject);

    let expectedChange = 1;
    let db = await DbConnection.get(this.customUri);
    let check = await super._checkCurrentNoiBefore(expectedChange, uuObject["awid"]);

    if (check !== true) {
      throw new NoiExceeded();
    } else {
      return await db
        .collection(this.collectionName)
        .insertOne(uuObject)
        .then((res) => {
          super._recalculateCurrentNoiAfter(res.ops.length, uuObject["awid"]);
          let insertedObject = super._convertToId(res.ops[0]);
          if (lock) {
            lock.addObject(insertedObject, self);
          }

          return insertedObject;
        })
        .catch((e) => {
          if (e.message.match(/^E11000/)) {
            throw new DuplicateKey(e);
          } else {
            throw new UnexpectedError(e);
          }
        });
    }
  }

  /**
   * stores multiple objects in the database
   * @async
   * @param uuObjectList {array} array of objects
   * @param ordered {boolean} specifying whether the mongod instance should perform an ordered or unordered insert
   * @returns {Promise.<TResult>} {object}
   */
  async insertMany(uuObjectList, ordered = true) {
    uuObjectList = uuObjectList.map((o) => {
      return { ...o };
    });

    let error = null;
    let stamps = super._createStamps();

    uuObjectList.forEach((uuObject) => {
      try {
        super._checkSoi(uuObject);
      } catch (e) {
        error = e;
        return false;
      }
      uuObject["sys"] = stamps;
      uuObject = super._convertId(uuObject);
    });

    if (error) {
      throw error;
    }

    let expectedChange = uuObjectList.length;

    let db = await DbConnection.get(this.customUri);
    let check = await super._checkCurrentNoiBefore(expectedChange, uuObjectList[0]["awid"]);

    if (check !== true) {
      throw new NoiExceeded();
    } else {
      let bulkInserts = [];
      uuObjectList.forEach(function(document) {
        bulkInserts.push({
          insertOne: {
            document,
          },
        });
      });

      let insertedIds = [];
      let result;
      try {
        result = await db.collection(this.collectionName).bulkWrite(bulkInserts, { ordered: ordered });
      } catch (e) {
        result = e.result;
      }
      let nInserted = result.toJSON()["nInserted"];
      if (nInserted === 0) {
        //nothing inserted
        uuObjectList = [];
      } else {
        if (ordered) {
          //ordered inserts
          insertedIds = result.toJSON().insertedIds.slice(0, nInserted);
          uuObjectList = uuObjectList.slice(0, nInserted);
          if (result.toJSON().writeErrors[0]) {
            error = result.toJSON().writeErrors[0]["errmsg"];
          }
        } else {
          //unordered inserts
          let indexes = result.toJSON().writeErrors.map(function(error) {
            return error["index"];
          });

          insertedIds = result.toJSON().insertedIds;
          if (indexes !== []) {
            indexes.reverse().forEach(function(index) {
              insertedIds.splice(index, 1);
              uuObjectList.splice(index, 1);
            });
          }

          let error = result.toJSON().writeErrors.map(function(error) {
            return error["errmsg"];
          });
        }
      }
      if (error) {
        let result = new BulkResult(false, error);
        uuObjectList.forEach((element) => {
          result.push(super._convertToId(element));
        });
        return result;
      } else {
        let result = new BulkResult(true, null);
        uuObjectList.forEach((element) => {
          result.push(super._convertToId(element));
        });

        return result;
      }
    }
  }

  /**
   * delete object from database
   * @async
   * @param filter {object}
   * @param lock {Lock}
   * @returns {Promise.<TResult>}
   */
  async deleteOne(filter, lock = null) {
    filter = super._convertId(filter);

    let deleteFilter = {
      $and: [filter],
    };
    let lockPart;
    if (lock) {
      lockPart = {
        "sys.lockHash": lock.hash,
        "sys.lockExpTs": {
          $gt: new Date(),
        },
      };
    } else {
      lockPart = {
        $or: [
          {
            "sys.lockHash": {
              $exists: false,
            },
          },
          {
            "sys.lockHash": {
              $exists: true,
            },
            "sys.lockExpTs": {
              $lt: new Date(),
            },
          },
        ],
      };
    }

    deleteFilter["$and"].push(lockPart);

    let db = await DbConnection.get(this.customUri);
    return await db
      .collection(this.collectionName)
      .deleteOne(deleteFilter)
      .then((status) => {
        if (!status || status === null || status.result.ok !== 1) {
          throw new UnexpectedError();
        } else if (status.result.n === 0) {
          return super._findWrapper(filter).then((result) => {
            result = result[0];
            if (result) {
              if (lock && result["sys"] && result["sys"]["lockHash"] === lock.hash) {
                throw new ExpiredLock();
              } else if (result["sys"] && result["sys"]["lockHash"] && result["sys"]["lockExpTs"] > new Date()) {
                throw new ObjectLocked();
              }
            }
          });
        }
      });
  }

  /**
   * delete all objects matching given query
   * @async
   * @param filter {object}
   * @param lock {Lock} optional
   * @returns {Promise.<TResult>}
   */
  async deleteMany(filter, lock = null) {
    let self = this;
    filter = super._convertId(filter);

    let deleteFilter = {
      $and: [filter],
    };
    let lockPart;
    if (lock) {
      lockPart = {
        "sys.lockHash": lock.hash,
        "sys.lockExpTs": {
          $gt: new Date(),
        },
      };
    } else {
      lockPart = {
        $or: [
          {
            "sys.lockHash": {
              $exists: false,
            },
          },
          {
            "sys.lockHash": {
              $exists: true,
            },
            "sys.lockExpTs": {
              $lt: new Date(),
            },
          },
        ],
      };
    }

    deleteFilter["$and"].push(lockPart);

    let db = await DbConnection.get(this.customUri);
    return await db
      .collection(this.collectionName)
      .deleteMany(deleteFilter)
      .then((result) => {
        return super._findWrapper(filter).then((res) => {
          if (res.length > result.result.n) {
            throw new ObjectLocked();
          } else {
            return result;
          }
        });
      })
      .catch((e) => {
        if (e instanceof ObjectStoreError) {
          throw e;
        } else {
          throw new UnexpectedError(e);
        }
      });
  }

  /**
   * find one object and update it
   * @param filter {object}
   * @param uuObject {object}
   * @param revisionStrategy
   * @param lock {Lock}
   * @returns {Promise.<TResult>} return updatad object
   */
  async findOneAndUpdate(filter, uuObject, revisionStrategy = "REVISION", lock = null) {
    if (lock && !lock.isValid()) {
      throw new this.Errors.ExpiredLock();
    }

    uuObject = { ...uuObject };

    filter = this._convertId(filter);
    uuObject = this._convertId(uuObject);

    super._checkSoi(uuObject);

    // prepare update
    let update = this._prepareUpdate(Object.assign({}, uuObject));

    let updateFilter = {
      $and: [filter],
    };

    let lockPart;
    if (lock) {
      lockPart = {
        "sys.lockHash": lock.hash,
        "sys.lockExpTs": {
          $gt: new Date(),
        },
      };
    } else {
      lockPart = {
        $or: [
          {
            "sys.lockHash": {
              $exists: false,
            },
          },
          {
            "sys.lockHash": {
              $exists: true,
            },
            "sys.lockExpTs": {
              $lt: new Date(),
            },
          },
        ],
      };
    }

    updateFilter["$and"].push(lockPart);

    if (revisionStrategy === "REVISION") {
      if (uuObject.sys == null || uuObject.sys.rev == null) {
        throw new MissingRevision();
      }
      let revisionPart = {
        "sys.rev": uuObject.sys.rev,
      };

      updateFilter["$and"].push(revisionPart);
    }

    let db = await DbConnection.get(this.customUri);
    return await db
      .collection(this.collectionName)
      .findOneAndUpdate(updateFilter, update, { returnDocument: "after" })
      .then((result) => {
        if (result.value) {
          return super._convertToId(result.value);
        } else {
          return super._findWrapper(filter).then((res) => {
            if (!res || res.length === 0) {
              throw new ObjectNotFound();
            } else if (revisionStrategy === "REVISION" && res[0].sys.rev !== uuObject.sys.rev) {
              throw new InvalidRevision();
            } else if (res[0]["sys"] && res[0]["sys"]["lockHash"] && res[0]["sys"]["lockExpTs"] > new Date()) {
              throw new ObjectLocked();
            } else {
              throw new UnexpectedError();
            }
          });
        }
      })
      .catch((e) => {
        if (e.message.match(/^E1100[01]/)) {
          throw new DuplicateKey(e);
        } else if (e instanceof ObjectStoreError) {
          throw e;
        } else {
          throw new UnexpectedError(e);
        }
      });
  }

  _prepareUpdate(update) {
    delete update["sys"];

    let preparedUpdate = {};
    for (let k in update) {
      // eslint-disable-next-line no-prototype-builtins
      if (update.hasOwnProperty(k) && k.startsWith("$")) {
        preparedUpdate[k] = update[k];
        delete update[k];
      }
    }

    // merge inc with increment of revision, if is contained in update query
    if (!preparedUpdate["$inc"]) {
      preparedUpdate["$inc"] = {};
    }
    preparedUpdate["$inc"]["sys.rev"] = 1;

    // eslint-disable-next-line no-prototype-builtins
    if (preparedUpdate.hasOwnProperty("$set")) {
      Object.assign(preparedUpdate["$set"], update);
    } else if (Object.keys(update).length > 0) {
      preparedUpdate["$set"] = update;
    } else {
      preparedUpdate["$set"] = {};
    }
    preparedUpdate["$set"]["sys.mts"] = new Date();

    return preparedUpdate;
  }
}

module.exports = Dao;
