"use strict";

const Matcher = require("../matcher.js");
const ValidationResult = require("../validation-result.js");
const Validator = require("../validator.js");
const MatcherError = require("../matcher-error.js");
const Sizeof = require("object-sizeof");

class _Map extends Matcher {

  constructor(...params) {
    super("map", ...params);
  }

  processParams(...params) {
    if (params.length === 0) {
      return; // empty map validation
    }
    if (params.length < 2 || params.length > 5) {
      throw new MatcherError("Map: wrong number of parameters, expected 2..5");
    }
    let keyMatcherOrValidator = params[0];
    if (keyMatcherOrValidator instanceof Matcher) {
      this.keyMatchers = [keyMatcherOrValidator];
    } else if (keyMatcherOrValidator instanceof Validator) {
      this.keyMatchers = keyMatcherOrValidator.matchers;
    } else {
      throw new MatcherError("Map: invalid parameter0, expected Matcher or Validator");
    }
    this.keyMatchers.forEach(matcher => {
      // TODO Verify matcher types
    });
    let valueMatcherOrValidator = params[1];
    if (valueMatcherOrValidator instanceof Matcher) {
      this.valueMatchers = [valueMatcherOrValidator];
    } else if (valueMatcherOrValidator instanceof Validator) {
      this.valueMatchers = valueMatcherOrValidator.matchers;
    } else {
      throw new MatcherError("Map: invalid parameter1, expected Matcher or Validator");
    }
    if (params.length === 3) {
      this.maxLength = params[2];
      if (this.maxLength != null && (typeof this.maxLength !== "number" || this.maxLength < 0)) {
        throw new MatcherError("Map: invalid parameter2, expected Number greater than or equal to 0");
      }
    } else {
      this.minLength = params[2];
      this.maxLength = params[3];
      if (this.minLength != null && (typeof this.minLength !== "number" || this.minLength < 0)) {
        throw new MatcherError("Map: invalid parameter2, expected Number greater than or equal to 0");
      }
      if (this.maxLength != null && (typeof this.maxLength !== "number" || this.maxLength < 0)) {
        throw new MatcherError("Map: invalid parameter3, expected Number greater than or equal to 0");
      }
      this.maxSize = params[4];
      if (this.maxSize != null && (typeof this.maxSize !== "number" || this.maxSize < 0)) {
        throw new MatcherError("Map: invalid parameter4, expected Number greater than or equal to 0");
      }
    }
  }

  match(value, ctx) {
    let result = new ValidationResult();
    if (value == undefined) {
      return result;
    }

    // Check via "Object.prototype.toString.call(value) !== '[object Object]'" must be used,
    // as "value.constructor !== Object" is not reliably working in sandbox (uuScriptEngine)
    if (typeof value !== "object" || (Object.prototype.toString.call(value) !== "[object Object]" && Object.prototype.toString.call(value) !== "[object Map]")) {
      result.addInvalidTypeError("map.e001", "The value must be a map.");
    } else if (this.keyMatchers && this.valueMatchers) {
      ctx = { ...ctx };
      ctx["parentValue"] = value;
      let keys = Object.keys(value);
      keys.forEach(key => {
        let val = value[key];
        let childResult = new ValidationResult();
        let keyValResult = new ValidationResult();
        this.keyMatchers.forEach(matcher => {
          keyValResult.addChildResult(key, matcher.match(key, ctx));
        });
        if (!keyValResult.valid) {
          let keyValResErrorMap = keyValResult.getValidationErrorMap();
          let keyValResKeys = Object.keys(keyValResErrorMap);
          keyValResKeys.forEach(key => {
            let invalidMap = keyValResErrorMap[key];
            let invalidMapKeys = Object.keys(invalidMap);
            invalidMapKeys.forEach(invalidKey => {
              childResult.addInvalidKeyError(
                Object.keys(invalidMap[invalidKey])[0],
                Object.values(invalidMap[invalidKey])[0]
              );
            });
          });
        }
        let valueValResult = new ValidationResult();
        this.valueMatchers.forEach(matcher => {
          valueValResult.addChildResult(key, matcher.match(val, ctx));
        });
        if (childResult.invalidKeyMap && Object.keys(childResult.invalidKeyMap).length !== 0) {
          if (!valueValResult.childResults) {
            valueValResult = { childResults: { [key]: { invalidKeyMap: childResult.invalidKeyMap } } }
            valueValResult = { childResults: { [key]: { valid: false } } }
          } else {
            valueValResult.childResults[key].invalidKeyMap = childResult.invalidKeyMap;
            valueValResult.childResults[key].valid = false;
          }
        }
        if (valueValResult.childResults && valueValResult.childResults[key]) {
          result.addChildResult(key, valueValResult.childResults[key]);
        }
      });
      if (!result.valid) {
        result.addInvalidValueError("map.e002", "The content of map must be valid.");
      }
      if (this.maxLength != null && keys.length > this.maxLength) {
        result.addInvalidValueError("map.e004", `The map must not contain more then ${this.maxLength} entries.`);
      }
      if (this.minLength != null && keys.length < this.minLength) {
        result.addInvalidValueError("map.e003", `The map must not contain less then ${this.minLength} entries.`);
      }
      if (this.maxSize != null && Sizeof(value) > this.maxSize) {
        result.addInvalidValueError("map.e005", `The size of the map must not exceed ${this.maxSize} B.`);
      }
    }

    return result;
  }

}

function MapMatcher(...params) {
  let matcher = new _Map(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = MapMatcher;
