"use strict";

const Matcher = require("../matcher.js");
const ValidationResult = require("../validation-result.js");
const Validator = require("../validator.js");
const MatcherError = require("../matcher-error.js");

class _isRequired extends Matcher {

  constructor(...params) {
    super("isRequired", ...params);
  }

  processParams(...params) {
    if (params.length > 0) {
      if (params.length === 1) {
        if (Array.isArray(params[0]) || params[0] instanceof Array) {
          this.altKeys = params[0];
        } else {
          this.altKeys = [params[0]];
        }
      } else {
        this.altKeys = params;
      }
      this.altKeys.forEach(key => {
        if (typeof key !== "string") {
          throw new MatcherError("IsRequired: parameters must be of type String");
        }
      })
    }
  }

  match(val, ctx) {
    let result = new ValidationResult();
    if (val != undefined) {
      return result;
    }

    let parentStruct = ctx.parentValue;
    if (!this.altKeys || this.altKeys.length === 0 || !parentStruct || parentStruct.constructor !== Object) {
      result.addMissingKey("isRequired.e001", "The value is required but missing.");
    } else {
      let missingKeys = new Set();
      this.altKeys.forEach(altKey => {
        if (parentStruct[altKey] === undefined) {
          missingKeys.add(altKey);
        }
      });
      if (this.altKeys.length === missingKeys.size) {
        result.addMissingKey("isRequired.e001", "The value is required but missing.");
      }
    }

    return result;
  }

}

function IsRequired(...params) {
  let matcher = new _isRequired(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = IsRequired;
