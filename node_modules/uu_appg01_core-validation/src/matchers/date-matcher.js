"use strict";

const Matcher = require("../matcher.js");
const ValidationResult = require("../validation-result.js");
const Validator = require("../validator.js");
const MatcherError = require("../matcher-error.js");
const d3 = require("d3-time-format");

const DEFAULT_FORMAT = "%Y-%m-%d";
const DAY_OF_MONTH = "d";
const MONTH_NUMBER = "m"
const DAY_OF_MONTH_FORMAT_REGEXP = new RegExp(`-?[%${DAY_OF_MONTH}]-?`);
const MONTH_NUMBER_FORMAT_REGEXP = new RegExp(`-?[%${MONTH_NUMBER}]-?`);
const FORMAT_SEPARATOR_REGEXP = /-?%?/g;
const VALUE_SEPARATOR_REGEXP = /-/g;

class _Date extends Matcher {

  constructor(...params) {
    super("date", ...params);
  }

  processParams(...params) {
    if (params.length > 3) {
      throw new MatcherError("Date: wrong number of parameters, expected 0..3");
    }
    let [format, from, to] = params;
    if (format && !this._isString(format)) {
      throw new MatcherError("Date: invalid parameter0, expected String");
    }
    let parsed;
    format = format || DEFAULT_FORMAT;
    let timeParse = d3.timeParse(format);
    this.timeParse = timeParse;
    this.format = format;
    if (from) {
      if (!this._isString(from)) {
        throw new MatcherError("Date: invalid parameter1, expected String");
      }
      parsed = timeParse(from);
      if (!parsed) {
        throw new MatcherError(`Date: parameter1 does not match "${format}"`);
      }
      this.from = from;
      this.fromParsed = parsed;
    }
    if (to) {
      if (!this._isString(to)) {
        throw new MatcherError("Date: invalid parameter2, expected String");
      }
      parsed = timeParse(to);
      if (!parsed) {
        throw new MatcherError(`Date: parameter2 does not match "${format}"`);
      }
      this.to = to;
      this.toParsed = parsed;
    }
  }

  match(value, ctx) {
    let result = new ValidationResult();
    if (value == undefined) {
      return result;
    }

    let parsed = this.timeParse(value);
    if ((this._isString(value) && parsed) || value.constructor.name === "Date") {
      parsed = parsed || value; // when date instance is provided
      if (!isNaN(parsed)) { // can happen when date instance is provided
        if (this.fromParsed && parsed < this.fromParsed) {
          result.addInvalidValueError("date.e002", `The value must not be before ${this.from}.`);
        }
        if (this.toParsed && parsed >= this.toParsed) {
          result.addInvalidValueError("date.e003", `The value must not be ${this.to} and later.`);
        }
        let dayOfMonth = this._getFormatValue(value, DAY_OF_MONTH, DAY_OF_MONTH_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (dayOfMonth && (dayOfMonth > 31 || dayOfMonth < 1)) {
          result.addInvalidTypeError("date.e001", `The value must be date in ${this.format} date format .`);
        }
        let monthNumber = this._getFormatValue(value, MONTH_NUMBER, MONTH_NUMBER_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (monthNumber && (monthNumber > 12 || monthNumber < 1)) {
          result.addInvalidTypeError("date.e001", `The value must be date in ${this.format} date format .`);
        }
      } else {
        result.addInvalidTypeError("date.e001", `The value must be date in ${this.format} date format .`);
      }
    } else {
      result.addInvalidTypeError("date.e001", `The value must be date in ${this.format} date format .`);
    }

    return result;
  }

  _isString(value) {
    return typeof value === "string" || !value instanceof String;
  }

  _getFormatValue(value, format, formatRegExp, formatSeparatorRegExp) {
    if (formatRegExp.test(this.format) && value.constructor.name !== "Date") {
      let formatPosition = this.format.replace(formatSeparatorRegExp, "").search(format);
      if (formatPosition !== -1) {
        return value.split(VALUE_SEPARATOR_REGEXP)[formatPosition];
      }
    }
    return null;
  }

}

function DateMatcher(...params) {
  let matcher = new _Date(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = DateMatcher;
