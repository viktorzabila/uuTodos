"use strict";

const Matcher = require("../matcher.js");
const ValidationResult = require("../validation-result.js");
const Validator = require("../validator.js");
const MatcherError = require("../matcher-error.js");

class _OneOf extends Matcher {

  constructor(...params) {
    super("oneOf", ...params);
  }

  processParams(...params) {
    if (params.length > 0) {
      let matchersOrValidators = []
      if (params.length === 1) {
        if (Array.isArray(params[0]) || params[0] instanceof Array) {
          matchersOrValidators = params[0];
        } else {
          matchersOrValidators = [params[0]];
        }
      } else {
        matchersOrValidators = params;
      }
      this.matcherSet = []
      matchersOrValidators.forEach(matcherOrValidator => {
        if (matcherOrValidator instanceof Matcher) {
          this.matcherSet.push([matcherOrValidator]);
        } else if (matcherOrValidator instanceof Validator) {
          this.matcherSet.push(matcherOrValidator.matchers);
        } else if (typeof matcherOrValidator === "string" || typeof matcherOrValidator === "number" || typeof matcherOrValidator === "boolean") {
          this.matcherSet.push([matcherOrValidator]);
        } else {
          throw new MatcherError("OneOf: parameters must be of type Matcher, Validator or primitive value");
        }
      });
    }
  }

  match(value, ctx) {
    let result = new ValidationResult();
    if (value == undefined || !this.matcherSet || this.matcherSet.length === 0) {
      return result;
    }

    let isValid = false;
    for (let valueMatchers of this.matcherSet) {
      let oneOfIsValid = true;
      let index = 0;
      for (let matcher of valueMatchers) {
        if (matcher instanceof Matcher) {
          let childResult = matcher.match(value, ctx);
          if (!childResult.valid) {
            oneOfIsValid = false;
            break;
          }
          result.addChildResult(index, childResult);
          index += 1;
        } else {
          if (matcher !== value) {
            oneOfIsValid = false;
            break;
          }
        }
      }
      if (oneOfIsValid) {
        isValid = true;
        break;
      }
    }
    if (!isValid) {
      let expectedTypes = this.getQualifiedName().replace(/^oneOf\(/, "[").replace(/\)$/, "]");
      result.addInvalidValueError("oneOf.e001", `The value must be one of ${expectedTypes}.`);
    }

    return result;
  }

}

function OneOf(...params) {
  let matcher = new _OneOf(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = OneOf;
