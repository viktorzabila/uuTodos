"use strict";

const Matcher = require("../matcher.js");
const ValidationResult = require("../validation-result.js");
const Validator = require("../validator.js");
const MatcherError = require("../matcher-error.js");
const d3 = require("d3-time-format");

const DEFAULT_FORMAT = "%Y-%m-%dT%H:%M:%S.%L%Z";
const DEFAULT_FORMAT_NO_MILLIS = "%Y-%m-%dT%H:%M:%S%Z";
const DAY_OF_MONTH = "d";
const MONTH_NUMBER = "m";
const HOURS_NUMBER = "H";
const MINUTES_NUMBER = "M";
const SECONDS_NUMBER = "S";
const DAY_OF_MONTH_FORMAT_REGEXP = new RegExp(`-?[%${DAY_OF_MONTH}]-?T?`);
const MONTH_NUMBER_FORMAT_REGEXP = new RegExp(`-?[%${MONTH_NUMBER}]-?T?`);
const HOURS_NUMBER_FORMAT_REGEXP = new RegExp(`T[%${HOURS_NUMBER}]:?`);
const MINUTES_NUMBER_FORMAT_REGEXP = new RegExp(`:[%${MINUTES_NUMBER}]:?`);
const SECONDS_NUMBER_FORMAT_REGEXP = new RegExp(`:[%${SECONDS_NUMBER}].?`);
const FORMAT_SEPARATOR_REGEXP = /[-:.+TZ]?%?/g;
const VALUE_SEPARATOR_REGEXP = /[-:.+TZ]/g;

class _Datetime extends Matcher {

  constructor(...params) {
    super("datetime", ...params);
  }

  processParams(...params) {
    if (params.length > 3) {
      throw new MatcherError("DateTime: wrong number of parameters, expected 0..3");
    }
    let [format, from, to] = params;
    if (format && !this._isString(format)) {
      throw new MatcherError("DateTime: invalid parameter0, expected String");
    }
    let parsed;
    format = format || DEFAULT_FORMAT;
    let timeParse = d3.timeParse(format);
    this.timeParse = timeParse;
    this.format = format;
    if (from) {
      if (!this._isString(from)) {
        throw new MatcherError("DateTime: invalid parameter1, expected String");
      }
      parsed = timeParse(from);
      if (!parsed) {
        if (this.format === DEFAULT_FORMAT) {
          let timeParseNoMillis = d3.timeParse(DEFAULT_FORMAT_NO_MILLIS);
          parsed = timeParseNoMillis(from);
        }
        if (!parsed) {
          throw new MatcherError(`DateTime: parameter1 does not match "${format}"`);
        }
      }
      this.from = from;
      this.fromParsed = parsed;
    }
    if (to) {
      if (!this._isString(to)) {
        throw new MatcherError("DateTime: invalid parameter2, expected String");
      }
      parsed = timeParse(to);
      if (!parsed) {
        if (this.format === DEFAULT_FORMAT) {
          let timeParseNoMillis = d3.timeParse(DEFAULT_FORMAT_NO_MILLIS);
          parsed = timeParseNoMillis(to);
        }
        if (!parsed) {
          throw new MatcherError(`DateTime: parameter2 does not match "${format}"`);
        }
      }
      this.to = to;
      this.toParsed = parsed;
    }
  }

  match(value, ctx) {
    let result = new ValidationResult();
    if (value == undefined) {
      return result;
    }

    let parsed = this.timeParse(value);
    if (!parsed && this.format === DEFAULT_FORMAT) {
      let timeParseNoMillis = d3.timeParse(DEFAULT_FORMAT_NO_MILLIS);
      parsed = timeParseNoMillis(value);
    }
    if ((this._isString(value) && parsed) || value.constructor.name === "Date") {
      parsed = parsed || value; // when date instance is provided
      if (!isNaN(parsed)) { /// can happen when date instance is provided
        if (this.fromParsed && parsed < this.fromParsed) {
          result.addInvalidValueError("datetime.e002", `The value must not be before ${this.from}.`);
        }
        if (this.toParsed && parsed >= this.toParsed) {
          result.addInvalidValueError("datetime.e003", `The value must not be ${this.to} and later.`);
        }
        let dayOfMonth = this._getFormatValue(value, DAY_OF_MONTH, DAY_OF_MONTH_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (dayOfMonth && (dayOfMonth > 31 || dayOfMonth < 1)) {
          result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
        }
        let monthNumber = this._getFormatValue(value, MONTH_NUMBER, MONTH_NUMBER_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (monthNumber && (monthNumber > 12 || monthNumber < 1)) {
          result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
        }
        let hourNumber = this._getFormatValue(value, HOURS_NUMBER, HOURS_NUMBER_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (hourNumber && (hourNumber > 23)) {
          result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
        }
        let minuteNumber = this._getFormatValue(value, MINUTES_NUMBER, MINUTES_NUMBER_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (minuteNumber && (minuteNumber > 59)) {
          result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
        }
        let secondNumber = this._getFormatValue(value, SECONDS_NUMBER, SECONDS_NUMBER_FORMAT_REGEXP, FORMAT_SEPARATOR_REGEXP);
        if (secondNumber && (secondNumber > 59)) {
          result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
        }
      } else {
        result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
      }
    } else {
      result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
    }

    return result;
  }

  _isString(value) {
    return typeof value === "string" || !value instanceof String;
  }

  _getFormatValue(value, format, formatRegExp, formatSeparatorRegExp) {
    if (formatRegExp.test(this.format) && value.constructor.name !== "Date") {
      let formatPosition = this.format.replace(formatSeparatorRegExp, "").search(format);
      if (formatPosition !== -1) {
        return value.split(VALUE_SEPARATOR_REGEXP)[formatPosition];
      }
    }
    return null;
  }

}

function Datetime(...params) {
  let matcher = new _Datetime(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = Datetime;
