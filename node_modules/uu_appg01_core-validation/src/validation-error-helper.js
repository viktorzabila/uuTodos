"use strict";

const stream = require("stream");

/**
 * helper class to remove invalid keys and to remove error maps
 */
class ValidationErrorHelper {
  deleteInvalidObjectKeys(dtoIn, validationResult) {
    this._removeInvalidKeys(dtoIn, validationResult);
    this._removeErrorKeys(dtoIn, validationResult);
  }

  /**
   * remove invalid keys from dtoIn
   * @param {Object} dtoIn
   * @param {Object} validationResult
   * @private
   */
  _removeInvalidKeys(dtoIn, validationResult) {
    let attributesToDelete = validationResult.getUnsupportedKeys();

    if (attributesToDelete.length > 0) {
      for (let i = 0; i < attributesToDelete.length; i += 1) {
        let attributePath = attributesToDelete[i].split(".");
        let dtoInObject = dtoIn;
        for (let e = 0; e < attributePath.length; e += 1) {
          let path = attributePath[e];
          if (path === "$") {
            continue;
          }
          if (dtoInObject[path] && e != attributePath.length - 1) {
            dtoInObject = dtoInObject[path];
          } else if (path.indexOf("[") !== -1 && path.indexOf("]") !== -1) {
            let arrayPathName = path.substring(0, path.indexOf("["));
            let arrayPathIndex = path.substring(path.indexOf("[") + 1, path.indexOf("]"));
            if (dtoInObject[arrayPathName]) {
              if (e == attributePath.length - 1) {
                delete dtoInObject[arrayPathName][arrayPathIndex];
              } else {
                dtoInObject[arrayPathName][arrayPathIndex] ? dtoInObject = dtoInObject[arrayPathName][arrayPathIndex] : dtoInObject = dtoInObject[arrayPathName]
              }
            } else {
              break;
            }
          } else if (!Object.keys(dtoInObject).includes(path)) {
            break;
          } else {
            delete dtoInObject[path];
          }
        }
      }
    }
  }

  /**
   * remove error keys
   * @param {Object} dtoIn
   * @private
   */
  _removeErrorKeys(dtoIn) {
    if (dtoIn["uuAppErrorMap"]) {
      delete dtoIn["uuAppErrorMap"];
    }
    for (let key in dtoIn) {
      if (!dtoIn[key] || typeof dtoIn[key] !== "object" || this._isReadableStream(dtoIn[key])) {
        continue;
      }
      this._removeErrorKeys(dtoIn[key]);
      if (Object.keys(dtoIn[key]).includes("uuAppErrorMap")) {
        delete dtoIn[key]["uuAppErrorMap"];
      }
    }
  }

  /**
   * Check if incoming stream is readable
   * @param {Object} obj
   * @returns {boolean}
   * @private
   */
  _isReadableStream(obj) {
    return (
      obj instanceof stream.Stream && typeof (obj._read === "function") && typeof (obj._readableState === "object")
    );
  }
}

module.exports = new ValidationErrorHelper();
