"use strict";

const MatcherStore = require("./matcher-store.js");

class Parser {

  static parse(schemaString) {
    // 1. replace built-in matcher names by loaded matchers
    for (let matcherName in MatcherStore.matchers) {
      schemaString = this._replaceAll(schemaString, new RegExp(`${matcherName}\\s*\\(`), `MatcherStore.matchers['${matcherName}'](`);
    }
    schemaString = this._replaceAll(schemaString, ".MatcherStore.matchers", "");

    // 2. replace custom type names by loaded types
    let typeMatch;
    let typeMatcher = new RegExp("(?:const|let|var)\\s+([^\\s]+)\\s*=", "mg");
    while ((typeMatch = typeMatcher.exec(schemaString)) !== null) {
      let declaration = typeMatch[0];
      let typeName = typeMatch[1];
      // replace declarations
      schemaString = this._replaceAll(schemaString, declaration, `validationTypes.${typeName} =`);
      // replace usages
      schemaString = this._replaceAll(schemaString, new RegExp(`${typeName}(?!(?:\\s*(?:=|:|"|')|\\w+))\\s*(?:\\(\\))?`), `this._deepClone(validationTypes.${typeName})`);
    }

    // 3. parse schema via eval and return contained validation types
    let parseValidationTypes = null;
    eval(`parseValidationTypes = function() {\nlet validationTypes = {};\n${schemaString}\nreturn validationTypes;\n};`);
    let validationTypes = parseValidationTypes.bind(this)();
    return validationTypes;
  }

  static _replaceAll(str, search, replacement) {
    let target = str;
    return target.split(search).join(replacement);
  }

  static _deepClone(obj) {
    if (obj == null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof RegExp || obj instanceof Date) {
      return obj;
    }
    let props = Object.getOwnPropertyDescriptors(obj);
    for (let prop in props) {
      props[prop].value = this._deepClone(props[prop].value);
    }
    if (obj instanceof Array) {
      return Array.from(obj);
    }
    return Object.create(Object.getPrototypeOf(obj), props);
  }

}

module.exports = Parser;
