"use strict";

const BadRequest = require("../error/bad-request.js");
const { BaseError, Json } = require("uu_appg01_core-utils");

const SEP = ".";
const INDEX_REGEX = /^_ยง!\[(\d+)]$/;
const PROTO_KEY = "__proto__";
const CONSTRUCTOR_KEY = "constructor";

/**
 * Class handles parsing of dot notation in dtoIn keys
 * to allow simple nesting of parameters,
 * especially in GET requests.
 * @example
 * dto.param1 = "one"
 * dto.param2 = "two"
 *
 * will produce:
 *
 * {
 *   param1: "one",
 *   param2: "two"
 * }
 *
 * Array notation is also supported.
 *
 * arr[0] = "first"
 * arr[1] = "second"
 *
 * will produce:
 *
 * [
 *   "first",
 *   "second"
 * ]
 */
class DotNotationParser {

  static parse(source) {
    if (!this._isObject(source)) {
      let isArray = Array.isArray(source);
      throw new BaseError(
        `Unable to parse dot notation in other types than Objects. Received: ${isArray ? "array" : typeof source}`
      );
    }

    source = Object.assign({}, source);

    Object.keys(source).forEach(key => {
      if (key === PROTO_KEY || key === CONSTRUCTOR_KEY) {
        delete source[key];
        return;
      }
      let pathSegments = this._parsePath(key);
      if (pathSegments.length > 1) {
        this._fill(pathSegments, source, source[key]);
        delete source[key];
      }
    });

    return source;
  }

  /**
   * Recursively traverse the dot-/array-notated
   * path and set the originalValue at the end
   * of the path. Throw on overwrites, unless
   * deep in merged objects.
   * @param pathSegments
   * @param source
   * @param originalValue
   * @private
   */
  static _fill(pathSegments, source, originalValue) {
    let segment = pathSegments.shift();
    segment = this._parseIndex(segment);
    if (segment === PROTO_KEY || segment === CONSTRUCTOR_KEY) {
      return;
    }
    if (pathSegments.length > 0) {
      source[segment] = source.hasOwnProperty(segment) ? source[segment] : this._isIndex(pathSegments[0]) ? [] : {};
      if (this._isObjectOrArray(source[segment])) {
        this._fill(pathSegments, source[segment], originalValue);
      } else {
        this._throwOnRedefine(source, segment, originalValue);
      }
    } else {
      if (source.hasOwnProperty(segment)) {
        if (this._isObject(source[segment]) && this._isTopLevelMergeable(source[segment], originalValue)) {
          this._mergeDeep(source[segment], originalValue);
        } else {
          this._throwOnRedefine(source, segment, originalValue);
        }
      } else {
        source[segment] = originalValue;
      }
    }
  }

  static _isIndex(k) {
    return INDEX_REGEX.test(k);
  }

  static _parseIndex(k) {
    let test = k.match(INDEX_REGEX);
    return test ? test[1] : k;
  }

  static _isObjectOrArray(val) {
    return val && typeof val === "object";
  }

  static _parsePath(path) {
    if (path.indexOf("[") >= 0) {
      path = path.replace(/\[/g, "._ยง!["); //.replace(/]/g, '')
    }
    return path.split(SEP);
  }

  static _throwOnRedefine(src, seg, val) {
    throw new BadRequest(
      `Invalid dot-/array-notated request parameters. Duplicity in: ${Json.stringify(src)}["${seg}"] = ${Json.stringify(
        val
      )}`
    );
  }

  static _isTopLevelMergeable(first, second) {
    let keys = Object.keys(first);
    let i = 0;
    for (; i < keys.length; i++) {
      if (second.hasOwnProperty(keys[i])) {
        return false;
      }
    }
    return true;
  }

  static _isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }

  static _mergeDeep(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();

    if (this._isObject(target) && this._isObject(source)) {
      for (const key in source) {
        if (source.hasOwnProperty(key)) {
          if (this._isObject(source[key])) {
            if (!target[key]) Object.assign(target, { [key]: {} });
            this._mergeDeep(target[key], source[key]);
          } else {
            Object.assign(target, { [key]: source[key] });
          }
        }
      }
    }

    return this._mergeDeep(target, ...sources);
  }
}

module.exports = DotNotationParser;
