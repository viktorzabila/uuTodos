const { ValidationErrorHelper, Validator } = require("uu_appg01_core-validation");
const { ValueConverter } = require("uu_appg01_core-utils");

class ValidationHelper {
  processValidationResult(dtoIn, validationResult, uuAppErrorMap, warningCode, customError) {
    if (typeof uuAppErrorMap == "string" || uuAppErrorMap instanceof String) {
      customError = warningCode;
      warningCode = uuAppErrorMap;
      uuAppErrorMap = {};
    }

    let updatedtDtoIn, converted, countOfConverted;
    [updatedtDtoIn, converted, countOfConverted] = this._tryToConvertValues(dtoIn, validationResult);

    if (countOfConverted > 0) {
      let updateValidator = validationResult._validator;
      // --------------------------------------------------------------------
      // Kept for backward compatibility with older uu_appg01_core-validation
      // TODO Remove with next major version
      if (!updateValidator) {
        updateValidator = new Validator(validationResult._schema.string, true);
      }
      // --------------------------------------------------------------------
      validationResult = updateValidator.validate(validationResult._schema.name, updatedtDtoIn);
    }
    dtoIn = updatedtDtoIn;

    let unsupportedKeys = validationResult.getUnsupportedKeys();

    if (unsupportedKeys.length > 0) {
      ValidationErrorHelper.deleteInvalidObjectKeys(dtoIn, validationResult);
      this.addWarning(uuAppErrorMap, warningCode, "DtoIn contains unsupported keys.", {
        unsupportedKeyList: unsupportedKeys
      });
    }

    if (!validationResult.isValid()) {
      throw new customError({ uuAppErrorMap }, validationResult.getValidationErrorMap());
    } else {
      delete uuAppErrorMap["unsupportedKeyList"];
    }

    return uuAppErrorMap;
  }

  addWarning(uuAppErrorMap, code, message, paramMap) {
    uuAppErrorMap[code] = {
      type: "warning",
      message: message,
      paramMap: paramMap
    };
  }

  _tryToConvertValues(dtoIn, validationResult) {
    let countOfConverted = 0;
    let converted = {};

    validationResult.getInvalidTypeKeys().forEach(key => {
      let invalidType = validationResult.getValidationResult(key).invalidTypes;
      if (Object.keys(invalidType).length !== 0 && invalidType.constructor === Object) {
        let typesKeys = Object.keys(invalidType);
        typesKeys.forEach(typeKey => {
          try {
            let pathKey = key.replace("$", "");
            if (typeof this._getValueFromPath(pathKey, dtoIn) === "string") {
              if (typeKey.match("(boolean|constant)") && this._getValueFromPath(pathKey, dtoIn).match("^(true|false)$")) {
                countOfConverted += 1;
                let convertedValue = ValueConverter.toBoolean(this._getValueFromPath(pathKey, dtoIn));
                this._setValueToPath(pathKey, dtoIn, convertedValue);
                converted[key] = this._getValueFromPath(pathKey, dtoIn);
              } else if (typeKey.match("(number|integer|float|constant)")) {
                countOfConverted += 1;
                let convertedValue = ValueConverter.toNumber(this._getValueFromPath(pathKey, dtoIn));
                this._setValueToPath(pathKey, dtoIn, convertedValue);
                converted[key] = convertedValue;
              }
            }
          } catch (e) {
            countOfConverted -= 1;
          }
        });
      }
    });

    return [dtoIn, converted, countOfConverted];
  }

  _getValueFromPath(path, obj) {
    let parts = path.split(/\]\[|\]\.|\[|\]|\./);
    let value = obj;
    parts.forEach(val => {
      if (val !== "") {
        value = value[val];
      }
    });
    return value;
  }

  _setValueToPath(path, obj, newValue) {
    let parts = path.split(/\]\[|\]\.|\[|\]|\./);
    let value = obj;
    parts = parts.filter(a => a !== "");

    parts.forEach((val, index) => {
      if (index === parts.length - 1) {
        value[val] = newValue;
      } else {
        value = value[val];
      }
    });
  }
}

module.exports = new ValidationHelper();
