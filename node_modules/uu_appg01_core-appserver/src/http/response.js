"use strict";

const contentDisposition = require("content-disposition");
const MimeTypes = require("mime-types");
const { Config } = require("uu_appg01_core-utils");

const MEDIA_TYPE_IMAGE = new RegExp(Config.getString("uu_app_server_media_type_image") || "^image/.*$");
const MEDIA_TYPE_VIDEO = new RegExp(Config.getString("uu_app_server_media_type_video") || "^video/.*$");
const MEDIA_TYPE_AUDIO = new RegExp(Config.getString("uu_app_server_media_type_audio") || "^audio/.*$");

/**
 * Response object.
 */
class Response {

  constructor(res) {
    this._status = res.statusCode;
    this._headers = res.getHeaders();
    this._body = null;
    this._source = res;
  }

  /**
   * Returns original Express response.
   * @returns {http.ServerResponse}
   */
  unwrap() {
    return this._source;
  }

  /**
   * Get status code currently set on response.
   * @returns {number} status code
   */
  getStatus() {
    return this._status;
  }

  get status() {
    return this.getStatus();
  }

  /**
   * Set status code to response.
   * @param value {number} status code
   */
  setStatus(value) {
    this._status = parseInt(value);
  }

  set status(value) {
    this.setStatus(value);
  }

  /**
   * Get the current value of response body.
   * @returns {object|string|stream.Readable}
   */
  getBody() {
    return this._body;
  }

  get body() {
    return this.getBody();
  }

  /**
   * Sets the response body. Supported bodies include
   * objects serializable to JSON, strings, buffers and readable streams.
   * @param {object|string|stream.Readable|Buffer} value
   */
  setBody(value) {
    this._body = value;
  }

  set body(value) {
    this.setBody(value);
  }

  /**
   * Sets the response body and relevant headers to
   * download binary data.
   * @param {string|Buffer|stream.Readable} value
   * @param {object} [options] - file metadata
   * @param {string} [options.filename = defaultName] - name of the resulting file
   * @param {string} [options.contentType = application/octet-stream] - declared media type of the response body
   * @param {number|string} [options.contentLength] - size of the response body
   * @param {string} [options.contentDisposition] - value of content disposition header; defaults to "inline" for
   *    images, video and audio, "attachment" for everything else
   */
  setBinaryBody(value, options) {
    let filename = options.filename || "defaultName";
    let contentType = options.contentType;
    if (!contentType) {
      contentType = MimeTypes.lookup(filename) || "application/octet-stream";
    }
    let dispositionType = options.contentDisposition;
    if (!dispositionType) {
      if (contentType.match(MEDIA_TYPE_IMAGE) || contentType.match(MEDIA_TYPE_VIDEO) || contentType.match(MEDIA_TYPE_AUDIO)) {
        dispositionType = "inline";
      } else {
        dispositionType = "attachment";
      }
    }
    this.setHeader("content-type", contentType);
    this.setHeader("content-disposition", contentDisposition(filename, { type: dispositionType }));
    if (options.contentLength != null) {
      this.setHeader("content-length", options.contentLength + "");
    }
    this.setBody(value);
  }

  /**
   * Gets all headers in an object, capitalized. Note that the object
   * does not prototypically inherit from Object so methods
   * such as .hasOwnProperty or .toString are not available.
   * @returns {object} capitalized headers
   */
  getHeaders() {
    return this._capitalizeHeaders(this._headers);
  }

  get headers() {
    return this.getHeaders();
  }

  /**
   * Sets headers using an object where header names are keys
   * and header contents are values. Headers will be merged
   * and original headers will be overwritten on conflict.
   * @param {object} headers
   */
  setHeaders(headers) {
    Object.assign(this._headers, this._lowercaseHeaders(headers));
  }

  set headers(headers) {
    return this.setHeaders(headers);
  }

  /**
   * Get value of supplied header. Returns undefined if
   * header is not set on response.
   * @param header {string} header name
   * @returns {string} lower-cased header name
   */
  getHeader(header) {
    return this._headers[header.toLowerCase()];
  }

  /**
   * Sets the value of supplied header. Overwrites any
   * previously set header.
   * @param header {string} header name
   * @param value {string} header value
   */
  setHeader(header, value) {
    this._headers[header.toLowerCase()] = value;
  }

  /**
   * Gets the Content-Type header value.
   * @returns {string}
   */
  getContentType() {
    return this._headers["content-type"];
  }

  get contentType() {
    return this.getContentType();
  }

  /**
   * Sets the Content-Type header value.
   * @param value {string}
   */
  setContentType(value) {
    this._headers["content-type"] = value;
  }

  set contentType(value) {
    this.setContentType(value);
  }

  /**
   * Configures resource caching based on given options.
   * @param {Object} opts Cache options
   * @param {string} opts.etag Value of resource entity tag.
   * @param {string|Date} opts.lastModified Date of last modification.
   * @param {number} opts.maxAge How long should be resource cached.
   * @param {boolean} opts.public If resource should be caches by proxy servers.
   *  (usable only in conjunction with opts.maxAge defaults to false)
   */
  setResourceCache(opts = {}) {
    if (opts.lastModified) {
      this.setHeader("last-modified", new Date(opts.lastModified).toUTCString());
    }
    if (opts.etag) {
      this.setHeader("etag", `"${opts.etag}"`);
    }
    if (opts.maxAge) {
      this.setHeader("cache-control", `max-age=${opts.maxAge}` + (opts.public ? ", public" : ", private"));
    }
  }

  /**
   * Force disable of resource caching.
   */
  disableResourceCache() {
    this.setHeader("cache-control", "no-cache");
    this.setHeader("pragma", "no-cache");
  }

  /**
   * Helper method to create empty response instructing
   * client to use cached resource value.
   */
  useCachedResource() {
    this.setStatus(304);
    this.setHeader("content-length", "0");
    this.setBody(null);
  }

  _capitalizeHeaders(headers) {
    return Object.keys(headers).reduce((capitalized, headerName) => {
      let capH = headerName
        .split("-")
        .map(word => word[0].toUpperCase() + word.substr(1))
        .join("-");
      capitalized[capH] = headers[headerName];
      return capitalized;
    }, Object.create(null));
  }

  _lowercaseHeaders(headers) {
    return Object.keys(headers).reduce((lowercased, headerName) => {
      let lcH = headerName
        .split("-")
        .map(word => word[0].toLowerCase() + word.substr(1))
        .join("-");
      lowercased[lcH] = headers[headerName];
      return lowercased;
    }, Object.create(null));
  }
}

module.exports = Response;
