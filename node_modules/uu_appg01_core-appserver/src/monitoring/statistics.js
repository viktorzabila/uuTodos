"use strict";

const { Histogram } = require("uu_appg01_core-utils");

/**
 * Object encapsulating server usage statistics (by default statistics
 * are accessible via {UuApp::AppServer::Sys::StatisticsGet} system
 * endpoint).
 */
class Statistics {
  /**
   * Creates new instance of statistics.
   # @param {Fixnum} maxRequestTime Maximum expected request
   #   time (should not be set higher than response timeout
   #   controlled by {UuApp::AppServer::Middleware::ResponseTimer}
   #   middleware).
   */
  constructor(maxRequestTime) {
    this._maxRequestTime = maxRequestTime;
    /**
     * Server start time.
     * @type {number} Server start time.
     */
    this.startTime = Date.now();
    /**
     * Last request time.
     * @type {number} Last request time.
     */
    this.lastRequestTime = null;
    /**
     * Last time of error caused by client.
     * @type {number} Last client error time.
     */
    this.lastClientErrorTime = null;
    /**
     * Last time of error caused by internal server error.
     * @type {number} Last server error time.
     */
    this.lastServerErrorTime = null;
    /**
     * Total count of processed requests.
     * @type {number}
     */
    this.requestCount = 0;
    /**
     * Number of failed requests caused by client error.
     * @type {number} Total client error count.
     */
    this.clientErrorCount = 0;
    /**
     * Number of failed requests caused by internal server error.
     * @type {number} Total server error count.
     */
    this.serverErrorCount = 0;
    /**
     * Number of concurrently processed requests.
     * @type {number} Concurrently processed requests.
     */
    this.concurrentRequests = 0;

    /**
     * Time of last reset of statistics.
     * @type {number} Time of last reset of statistics.
     */
    this.resetTime = this.startTime;

    this._requestHistogram = new Histogram(1, maxRequestTime * 1000000, maxRequestTime * 10);
  }

  /**
   * Server uptime (with seconds precision).
   * @returns {string} Server uptime (with seconds precision).
   */
  uptime() {
    let secElapsed = Math.round((Date.now() - this.startTime) / 1000);
    return this._formatTime(secElapsed);
  }

  /**
   * Server uptime counted from last reset (with seconds precision).
   * @returns {string} Server uptime counted from last reset (with seconds precision).
   */
  collectingUptime() {
    let secElapsed = Math.round((Date.now() - this.resetTime) / 1000);
    return this._formatTime(secElapsed);
  }

  /**
   * Method to be called on beginning of request processing.
   * @returns {void}
   */
  beginRequest() {
    this.concurrentRequests++;
  }

  /**
   * Method to be called upon sucessfuly processed request.
   * @param {number} duration Processing time in nanoseconds.
   * @returns {void}
   */
  recordRequest(duration) {
    this.lastRequestTime = Date.now();
    this.requestCount++;
    this.concurrentRequests--;
    this._requestHistogram.record(duration / 1000);
  }

  /**
   * Method to be called upon request failed by client error.
   * @param {number} duration Processing time in nanoseconds.
   * @returns {void}
   */
  recordClientError(duration) {
    let time = Date.now();
    this.lastRequestTime = time;
    this.lastClientErrorTime = time;
    this.requestCount++;
    this.clientErrorCount++;
    this.concurrentRequests--;
    this._requestHistogram.record(duration / 1000);
  }

  /**
   * Method to be called upon request failed by server error.
   * @param {number} duration Processing time in nanoseconds.
   * @returns {void}
   */
  recordServerError(duration) {
    let time = Date.now();
    this.lastRequestTime = time;
    this.lastServerErrorTime = time;
    this.requestCount++;
    this.serverErrorCount++;
    this.concurrentRequests--;
    this._requestHistogram.record(duration / 1000);
  }

  /**
   * Returns fastest request time.
   * @return {number} Fastest request time in nanoseconds.
   */
  minRequestTime() {
    let res = this._requestHistogram.min();
    return res ? res * 1000 : res;
  }

  /**
   * Returns slowest request time.
   * @return {number} Slowest request time in nanoseconds.
   */
  maxRequestTime() {
    let res = this._requestHistogram.max();
    return res ? res * 1000 : res;
  }

  /**
   * Returns average request time.
   * @return {number} Average request time in nanoseconds.
   */
  averageRequestTime() {
    let res = this._requestHistogram.average();
    return res ? res * 1000 : res;
  }

  /**
   * Returns value of request time percentile.
   * @param {number} val Requested percentile (between 0 and 100).
   * @return {number} Values of request time percentile (in nanoseconds).
   */
  requestTimePercentile(val) {
    let res = this._requestHistogram.percentile(val);
    return res ? res * 1000 : res;
  }

  /**
   * Reset statistics.
   * @returns {void}
   */
  reset() {
    this.lastRequestTime = null;
    this.lastClientErrorTime = null;
    this.lastServerErrorTime = null;
    this.requestCount = 0;
    this.clientErrorCount = 0;
    this.serverErrorCount = 0;
    this.resetTime = Date.now();
    this._requestHistogram = new Histogram(1, this._maxRequestTime * 1000000, this._maxRequestTime * 10);
  }

  /**
   * Returns time in hh:mm:ss format.
   * @param time Time in seconds.
   * @returns {string} Time in hh:mm:ss format.
   * @private
   */
  _formatTime(time) {
    let ss = time % 60;
    let mSec = (time - ss) / 60;
    let mm = mSec % 60;
    let hMin = (mSec - mm) / 60;
    let hh = hMin % 60;
    return `${hh}:${mm}:${ss}`;
  }
}

module.exports = new Statistics(15);
