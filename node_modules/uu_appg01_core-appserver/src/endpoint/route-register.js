const UVE = "UVE";
const { LoggerFactory } = require("uu_appg01_core-logging");
const { BaseError } = require("uu_appg01_core-utils");


class RouteRegister {
  constructor() {
    this._registerProductsExpression = {};
    this._registerProductsExact = {};
    this._registerProductsPartialExpression = {};
    this._expressionRoutes = [];
    this._partialExpressionRoutes = [];
    this._registeredSpps = new Set();
  }

  isVuc(useCase, uriProduct, method = null) {
    if (!this._logger) this._logger = LoggerFactory.get("UuApp.AppServer");
    // TODO uncomment when client helpers support UVE in build
    // this._logger.warn("RouteRegister.isVuc(uc) is deprecated. Use .isUve(uc) instead.");
    return this._safeGet(useCase, uriProduct, method).type === UVE;
  }

  isUve(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).type === UVE;
  }

  httpMethod(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).httpMethod;
  }

  consumes(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).consumes;
  }

  produces(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).produces;
  }

  product(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).product;
  }

  path(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).path;
  }

  route(useCase, uriProduct, method = null) {
    return this._safeGet(useCase, uriProduct, method).route;
  }

  exists(useCase, uriProduct) {
    let exist = false;
    if (this.get(useCase, uriProduct, null, false, true)) {
      exist = true;
    }

    return exist;
  }

  getRegisteredSppList() {
    return [...this._registeredSpps];
  }

  set(useCase, useCasePattern, data, method) {
    let product = data.product;
    let countOfExpression = this._getCountOfExpression(product);
    let dataWithMethod = { [method]: data };

    let dataObject = this.get(useCase, data.product, null, true, true) || {};

    if (countOfExpression === product.split("-").length) {
      if (!this._registerProductsExpression[product]) {
        this._registerProductsExpression[product] = new Map();
      }
      this._registerProductsExpression[product].set(useCasePattern, { ...dataObject, ...dataWithMethod });
    } else if (countOfExpression > 0) {
      this._registeredSpps.add(product.split("-").splice(countOfExpression).join("-"));
      if (!this._registerProductsPartialExpression[product]) {
        this._registerProductsPartialExpression[product] = new Map();
      }
      this._registerProductsPartialExpression[product].set(useCasePattern, { ...dataObject, ...dataWithMethod });
    } else {
      if (!this._registerProductsExact[product]) {
        this._registerProductsExact[product] = new Map();
      }
      this._registerProductsExact[product].set(useCasePattern, { ...dataObject, ...dataWithMethod });
    }

    this.sortExpressionRoutes();
  }

  sortExpressionRoutes() {
    this._expressionRoutes = this._sortRoutesObject(this._registerProductsExpression);
  }

  sortPartialExpressionRoutes() {
    this._partialExpressionRoutes = this._sortRoutesObject(this._registerProductsPartialExpression);
  }

  _getUseCase(useCase, from, method = null, getAllMethods = false) {
    let result;
    let useCasePatterns = Array.from(from.keys());
    for (let i = 0; i < useCasePatterns.length; i += 1) {
      let useCasePattern = useCasePatterns[i];
      if (useCasePattern.match(useCase)) {
        result = from.get(useCasePattern);
        break;
      }
    }
    if (result != null) {
      if (getAllMethods) {
        return result;
      }

      if (method) {
        return result[method];
      } else {
        let resultKeys = Object.keys(result);
        if (resultKeys.length === 1) {
          return result[resultKeys[0]];
        } else {
          if (this._checkForSameRealization(result)) {
            return result[resultKeys[0]];
          } else {
            throw new BaseError("Route cannot be clearly identified - multiple realizations are associated to this UseCase through various HTTP methods. HTTP method has to be specified.");
          }
        }
      }
    }
  }

  get(useCase, uriProduct, method = null, byName = false, getAllMethods = false) {
    let useCaseName = useCase;
    if (byName) {
      useCaseName = this._replaceAll(useCase, ":", "");
    }

    if (this._registerProductsExact[uriProduct]) {
      let from = this._registerProductsExact[uriProduct];
      let result = this._getUseCase(useCaseName, from, method, getAllMethods);
      if (result != null) {
        return result;
      }
    }

    if (this._registerProductsPartialExpression[uriProduct]) {
      let from = this._registerProductsPartialExpression[uriProduct];
      let result = this._getUseCase(useCaseName, from, method, getAllMethods);
      if (result != null) {
        return result;
      }
    }

    let uriProductParts = uriProduct.split("-");
    for (let l = 0; l < this._partialExpressionRoutes.length; l += 1) {
      let product = this._partialExpressionRoutes[l];
      let productParts = product.route.split("-");
      if (productParts.length === uriProductParts.length) {
        let matching = true;
        let index = 0;
        productParts.forEach(partOfProduct => {
          if (partOfProduct[0] !== "{" && partOfProduct !== uriProductParts[index]) {
            matching = false;
          }
          index += 1;
        });
        if (matching) {
          let result = this._getUseCase(useCaseName, product, method, getAllMethods);
          if (result != null) {
            return result;
          }
        }
      }
    }

    for (let l = 0; l < this._expressionRoutes.length; l += 1) {
      let product = this._expressionRoutes[l];
      const productRouteLength = product.route.split("-").length;
      if (productRouteLength === 1 || uriProductParts.length === productRouteLength) {
        let result = this._getUseCase(useCaseName, product, method, getAllMethods);
        if (result != null) {
          return result;
        }
      }
    }

    return null;
  }

  forEach(callback) {
    Object.keys(this._registerProductsExpression).forEach(key => {
      this._registerProductsExpression[key].forEach((v, k, m) => {
        callback(k, v);
      });
    });
    Object.keys(this._registerProductsExact).forEach(key => {
      this._registerProductsExact[key].forEach((v, k, m) => {
        callback(k, v);
      });
    });

    Object.keys(this._registerProductsPartialExpression).forEach(key => {
      this._registerProductsPartialExpression[key].forEach((v, k, m) => {
        callback(k, v);
      });
    });
  }

  _safeGet(useCase, uriProduct, method = null) {
    let result = this.get(useCase, uriProduct, method);

    if (!result) {
      return {};
    } else {
      return result;
    }
  }

  /**
   * Sorts routes based on their specificity (number of segments - descending)
   * and alphabetically (descending) which ensures that variables (starting
   * with colon) are moved to the end of the list, allowing specific routes
   * to take precedence.
   * @param {Array} routes
   * @returns {Array} routes
   * @private
   */
  _sortRoutes(routes) {
    // sort product parts of routes
    routes.sort((a, b) => {
      let routeA = a.route.toUpperCase();
      let routeB = b.route.toUpperCase();
      return this._compareRoutes(routeA, routeB);
    });

    // sort also all entries (full routes with product, workspace and use case)
    routes = routes.map((fullRoutes) => {
      if (!this._isIterable(fullRoutes)) {
        return fullRoutes;
      }
      const sortedRoutes =  new Map([...fullRoutes].sort((a,b)=> {
        const routeA = a[1][Object.keys(a[1])[0]].route.toUpperCase();
        const routeB = b[1][Object.keys(b[1])[0]].route.toUpperCase();
        return this._compareRoutes(routeA, routeB);
      }));
      sortedRoutes.route = fullRoutes.route;
      return sortedRoutes;
    });
    return routes;
  }

  _compareRoutes(routeA, routeB) {
    const segmentsA = routeA.split("/").length - 1;
    const segmentsB = routeB.split("/").length - 1;

    if (segmentsA > segmentsB) {
      return -1;
    } else if (segmentsA < segmentsB) {
      return 1;
    } else {
      if (routeA < routeB) {
        return 1;
      } else if (routeA > routeB) {
        return -1;
      } else {
        return 0;
      }
    }
  }

  _isIterable(obj) {
    if (obj == null) {
      return false;
    }
    return typeof obj[Symbol.iterator] === 'function';
  }

  _sortRoutesObject(routesObject) {
    let Routes = [];
    Object.keys(routesObject).forEach(key => {
      routesObject[key].route = key;
      Routes.push(routesObject[key]);
    });
    return this._sortRoutes(Routes).reverse();
  }

  _getCountOfExpression(product) {
    let countOfExpression = 0;
    let partsOfProduct = product.split("-");
    partsOfProduct.forEach(key => {
      if (key[0] === "{") {
        countOfExpression += 1;
      }
    });
    return countOfExpression;
  }

  _replaceAll(str, search, replacement) {
    let target = str;
    return target.split(search).join(replacement);
  }

  _checkForSameRealization(result) {
    let resultKeys = Object.keys(result);
    let isSameRealization = true;
    let qualifiedName = null;
    resultKeys.forEach(key => {
      if (qualifiedName === null) {
        qualifiedName = result[key].qualifiedName;
      } else {
        if (qualifiedName !== result[key].qualifiedName) {
          isSameRealization = false;
        }
      }
    });

    return isSameRealization;
  }
}

module.exports = new RouteRegister();
