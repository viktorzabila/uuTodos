"use strict";

const { LoggerMDC } = require("uu_appg01_core-logging");
const { ContextStore, BaseError } = require("uu_appg01_core-utils");

const CTX_STORE_NAME = "uuapp.server.endpoint";
const CONTEXT_KEY = "useCaseContext";

/**
 * Context providing use case invocation details.
 */
class UseCaseContext {
  /**
   * Creates new instance of invocation context.
   * @private
   */
  constructor() {
    this.requestId = null;
    this.uri = null;
    this.baseUriAlias = null;
    this.useCaseProperties = null;
    this.session = null;
    this.authorizationResult = null;
  }

  /**
   * Checks if context is available (we are in scope of request).
   * @returns {boolean} True if context is available.
   */
  static isAvailable() {
    return !!UseCaseContext._getInstance();
  }

  /**
   * Returns unique request ID.
   * @returns {String|null} Unique request ID.
   */
  static getRequestId() {
    let ctx = UseCaseContext._getInstance();
    return ctx ? ctx.requestId : null;
  }

  /**
   * Returns use case URI.
   * @returns {Uri|null} Use case URI
   */
  static getUri() {
    let ctx = UseCaseContext._getInstance();
    return ctx ? ctx.uri : null;
  }

  /**
   * Returns base URI alias (in case use case was invoked via alias)
   * @return {String|null} Base URI alias
   */
  static getBaseUriAlias() {
    let ctx = UseCaseContext._getInstance();
    return ctx ? ctx.baseUriAlias : null;
  }

  /**
   * Returns use case properties.
   * @returns {UseCaseProperties|null} Use case properties
   */
  static getUseCaseProperties() {
    let ctx = UseCaseContext._getInstance();
    return ctx ? ctx.useCaseProperties : null;
  }

  /**
   * Returns result of authentication process.
   * @returns {Session|null} Result of authentication process
   */
  static getSession() {
    let ctx = UseCaseContext._getInstance();
    return ctx ? ctx.session : null;
  }

  /**
   * Returns result of authorization process.
   * @returns {AuthorizationResult|null} Result of authorization process
   */
  static getAuthorizationResult() {
    let ctx = UseCaseContext._getInstance();
    return ctx ? ctx.authorizationResult : null;
  }

  /**
   * Stores unique request ID.
   * @param requestId Unique request ID
   */
  static setRequestId(requestId) {
    let context = UseCaseContext._getInstance();
    if (!context) {
      throw new BaseError("Use case context is not available.");
    }
    if (context.requestId) {
      throw new BaseError("Use case context already initialized.");
    }
    context.requestId = requestId;
    LoggerMDC.set("traceId", requestId);
  }

  /**
   * Stores use case URI.
   * @param uri Use case uri
   */
  static setUri(uri) {
    let context = UseCaseContext._getInstance();
    if (!context) {
      throw new BaseError("Use case context is not available.");
    }
    if (!context.uri) {
      // Unlike other values, URI may be written multiple
      // times by defaultVuc handler, however we keep
      // only original value on logger MDC
      LoggerMDC.set("resourceUri", uri);
    }
    context.uri = uri;
  }

  /**
   * Stores base URI alias.
   * @param baseUriAlias Base URI alias
   */
  static setBaseUriAlias(baseUriAlias) {
    let context = UseCaseContext._getInstance();
    if (!context) {
      throw new BaseError("Use case context is not available.");
    }
    if (context.baseUriAlias) {
      throw new BaseError("Base URI alias already initialized.");
    }
    context.baseUriAlias = baseUriAlias;
    LoggerMDC.set("baseUriAlias", baseUriAlias);
  }

  /**
   * Stores use case properties.
   * @param useCaseProperties Use case properties
   */
  static setUseCaseProperties(useCaseProperties) {
    let context = UseCaseContext._getInstance();
    if (!context) {
      throw new BaseError("Use case context is not available.");
    }
    if (context.useCaseProperties) {
      throw new BaseError("Use case context already initialized.");
    }
    context.useCaseProperties = useCaseProperties;
  }

  /**
   * Stores result of authentication process.
   * @param session Result of authentication process
   */
  static setSession(session) {
    let context = UseCaseContext._getInstance();
    if (!context) {
      throw new BaseError("Use case context is not available.");
    }
    if (context.session) {
      throw new BaseError("Use case context already initialized.");
    }
    context.session = session;
    if (session) {
      LoggerMDC.set("sessionId", session.getAuthenticationId());
      if (session.getIdentity()) {
        LoggerMDC.set("identityId", session.getIdentity().getUuIdentity());
      }
      if (session.getApplicationIdentity()) {
        LoggerMDC.set("clientId", session.getApplicationIdentity().getCode());
      }
    }
  }

  /**
   * Stores result of authorization process.
   * @param session Result of authorization process
   */
  static setAuthorizationResult(authorizationResult) {
    let context = UseCaseContext._getInstance();
    if (!context) {
      throw new BaseError("Use case context is not available.");
    }
    if (context.authorizationResult) {
      throw new BaseError("Use case context already initialized.");
    }
    context.authorizationResult = authorizationResult;
  }

  /**
   * Initializes invocation context.
   * @param emitters Context emmiters.
   * @param fn Function within which should be invocation context available
   * @returns {*} Return value of invoked function.
   * @private
   */
  static create(emitters = null, fn) {
    if (typeof emitters === "function") {
      fn = emitters;
      emitters = null;
    }
    return ContextStore.create(CTX_STORE_NAME, () => {
      let ctxStore = ContextStore.get(CTX_STORE_NAME);
      ctxStore.set(CONTEXT_KEY, new UseCaseContext());
      if (emitters) {
        emitters.forEach(e => ctxStore.bindEmitter(e));
      }
      return fn();
    });
  }

  /**
   * Returns instance of invocation context (or null if not initialized).
   * @returns {UseCaseContext} Instance of invocation context
   * @private
   */
  static _getInstance() {
    let store = ContextStore.get(CTX_STORE_NAME);
    return store ? store.get(CONTEXT_KEY) : null;
  }
}

module.exports = UseCaseContext;
