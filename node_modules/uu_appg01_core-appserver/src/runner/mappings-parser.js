"use strict";

const MappingsLoader = require("./mappings-loader.js");
const { LoggerFactory } = require("uu_appg01_core-logging");
const Path = require("path");
const { BaseError, Loader, Json } = require("uu_appg01_core-utils");
const RouteRegister = require("../endpoint/route-register.js");
const Fs = require("fs");
const { Config } = require("uu_appg01_core-utils");
const UrlPattern = require("url-pattern");

const WORKSPACE = "/{workspace}";
const FORBIDDEN_EXTRA_ATTRS = ["product", "path", "route", "uri", "namespace", "qualifiedName"];

/**
 * MappingsParser uses mappings deserialized by MappingsLoader
 * and transforms them into complete routing objects,
 * replacing variables with Express notation and filling
 * in defaults where necessary.
 */
class MappingsParser {
  /**
   * Handles output of individual routes.
   * @returns {Array} routes
   */
  getRoutes() {
    let mappings = MappingsLoader.load().data;
    return this._loadRoutes(mappings);
  }
  /**
   * Turns UVEs and CMDs in mappings into actual routes that can be
   * used as parameters in Express routing functions.
   * @returns {Array} routes
   */
  _loadRoutes(mappings) {
    let routes = [];
    let products = Object.keys(mappings);
    let urlPatterns = {};

    for (let i = 0; i < products.length; i++) {
      let product = products[i];
      let productRoute = product.replace(/{/g, ":").replace(/}/g, "");
      let workspaceRoute = WORKSPACE.replace(/{/g, ":").replace(/}/g, "");
      let routeData = mappings[product].useCaseMap;
      let useCases = Object.keys(routeData);
      for (let j = 0; j < useCases.length; j++) {
        let useCase = useCases[j];
        let route = this._parseUseCase(routeData[useCase], useCase);
        if (productRoute[0] !== "/") {
          productRoute = "/" + productRoute;
        }
        let paths = [];
        if (route.path) {
          paths.push(...route.path);
        } else {
          paths.push(useCase);
        }
        paths.forEach(path => {
          let routeObject = { ...route };
          path = RouteRegister._replaceAll(path, "{", ":");
          path = RouteRegister._replaceAll(path, "}", "");

          routeObject.useCase = useCase;
          if (path[0] !== "/") {
            path = "/" + path;
          }
          routeObject.product = product;
          routeObject.path = productRoute + workspaceRoute;
          routeObject.route = productRoute + workspaceRoute + path;
          routeObject.uri = "/" + product + WORKSPACE + path;
          routes.push(routeObject);

          let useCasePattern;
          let ucPath = path.substr(1);
          if (urlPatterns[ucPath]) {
            useCasePattern = urlPatterns[ucPath];
          } else {
            useCasePattern = new UrlPattern(ucPath);
            urlPatterns[ucPath] = useCasePattern;
          }

          routeObject.httpMethod.forEach(httpMethod => {
            RouteRegister.set(ucPath, useCasePattern, routeObject, httpMethod);
          });
        });
      }
    }
    RouteRegister.sortExpressionRoutes();
    RouteRegister.sortPartialExpressionRoutes();
    return RouteRegister._sortRoutes(routes);
  }

  /**
   * Assigns correct default values to useCase specs and maps controllers
   * where available.
   * @param useCase Parameters of the useCase.
   * @param name Name of the useCase.
   * @returns {{realization, type, httpMethod, consumes, produces}}
   */
  _parseUseCase(useCase, name) {
    let { source, realization, type, httpMethod, consumes, produces, path, ...extraAttrs } = useCase;

    FORBIDDEN_EXTRA_ATTRS.forEach(attr => {
      if (extraAttrs.hasOwnProperty(attr))
        throw new BaseError(
          `You are using a forbidden attribute "${attr}" in useCase: ${name}. ` +
            `Don't use: ${FORBIDDEN_EXTRA_ATTRS.join(", ")}`
        );
    });

    if (!(source && realization))
      throw new BaseError(
        `Invalid useCase realization or source\nCheck ${Json.stringify(useCase, true)}\n at ${source}`
      );
    type = type || (realization.endsWith(".html") ? "UVE" : "CMD");
    // rename deprecated VUC types to UVE (User Visual Entrypoint)
    if (type === "VUC") {
      if (!this._logger) this._logger = LoggerFactory.get("UuApp.AppServer");
      // TODO uncomment when client helpers support UVE in build
      // this._logger.warn("Use of VUC in mappings.json useCase types is deprecated. Use UVE instead.");
      type = "UVE";
    }
    if (realization.endsWith(".html")) {
      realization = this._loadUve(realization, name);
    } else {
      realization = this._loadControllers(source, realization);
    }
    httpMethod = this._methodToArray(httpMethod) || (type === "UVE" ? ["GET"] : ["POST"]);
    consumes = this._methodToArray(consumes) || ["*/*"];
    path = this._methodToArray(path) || null;
    produces =
      this._methodToArray(produces) || (type === "UVE" ? ["text/html", "application/json"] : ["application/json"]);
    let namespace = Path.resolve(source, "..", "..")
      .split(/\/|\\/)
      .pop();
    let qualifiedName = `${namespace}:${useCase.realization.replace(/^\.(\\|\/)/, "")}`;

    return {
      ...extraAttrs, // passing extraAttrs first so they can't overwrite the rest
      realization,
      type,
      httpMethod,
      consumes,
      produces,
      qualifiedName,
      path
    };
  }

  /**
   * Takes the path to root of the mappings.json source and the realization
   * path of individual useCase and returns Function representing
   * the requested controller method using the RealizationLoader
   * helper function (uu_appg01_core-utils).
   * @param mappingsSource
   * @param realization
   * @returns {Function} Controller method
   * @private
   */
  _loadControllers(mappingsSource, realization) {
    // strip config/mappings.json from path
    let sourcePath = Path.resolve(mappingsSource, "..", "..");
    if (sourcePath.match(/(\\|\/)(app|src)$/)) {
      sourcePath = Path.resolve(sourcePath, "..");
    }

    return Loader.loadRealization(sourcePath, realization);
  }

  _loadUve(realization, useCase) {
    let sepIndex = realization.lastIndexOf(Path.sep);
    let file = sepIndex === -1 ? realization : realization.substring(sepIndex + 1);
    if (!file.endsWith(".html")) throw new BaseError(`Invalid realization of useCase: ${useCase} Check your mappings.`);
    let publicPath = Config.get("public_path") || Path.join(Config.get("server_root"), "public");
    Fs.access(Path.join(publicPath, file), err => {
      if (err)
        throw new BaseError(
          `Unable to load realization file ${file} of use case: ${useCase} Check your mappings and file system.`
        );
    });
    return realization;
  }

  /**
   * Helper turning HTTP verb representation in mappings to array
   * for use by router.
   * @param httpMethod
   * @returns {*}
   * @private
   */
  _methodToArray(httpMethod) {
    if (typeof httpMethod === "string") return [httpMethod];
    if (Array.isArray(httpMethod)) return httpMethod;
    return null;
  }
}

/**
 * Module exports a single instance of MappingsParser that is initialized
 * at application startup (when the first relevant require call is resolved).
 * @type {MappingsParser}
 */
module.exports = new MappingsParser();
