"use strict";

const path = require("path");
const { Config, BaseError, Loader, Finder } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const MiddlewareDisabler = require("./middleware-disabler.js");

/**
 * MiddlewareLoader is responsible for scanning folders set by convention
 * to store middleware, load the available middleware and correctly order
 * it based on individual order values. AppServer middleware is kept
 * in src/middleware and user defined middleware may be placed in
 * serverRoot/app/middleware.
 */
class MiddlewareLoader {
  /**
   * Gets server root from Config. Throws BaseError if there's no root available.
   * @private
   */
  _getConfiguration() {
    this._root = Config.get("server_root");
    if (!this._root) {
      throw new BaseError("Server root is not defined. Unable to resolve application middleware location.");
    }
    this._logger = LoggerFactory.get("UuApp.AppServer");
  }

  /**
   * Finds middleware files in relevant folders, loads middleware objects, sorts them
   * based on their order values and then collects the stored middleware functions to
   * arrays to be used pre-controller and post-controller.
   * @returns {{preControllerMiddleware: Array, postControllerMiddleware: Array, ensureFunctions: Array}}
   */
  load() {
    this._getConfiguration();
    this._logger.info("Loading middleware.");

    // disable middleware selected at server startup
    MiddlewareDisabler.executeDisable();

    const PATH_TO_MIDDLEWARE = `{src,app}/middleware/*.js`;

    let middleware = [];
    let preControllerMiddleware = [];
    let postControllerMiddleware = [];
    let ensureFunctions = [];

    let middlewarePaths = Finder.findInModules(this._root, PATH_TO_MIDDLEWARE).concat(
      Finder.findInProject(this._root, PATH_TO_MIDDLEWARE)
    );

    middlewarePaths.forEach(file => {
      if (MiddlewareDisabler.isDisabled(file)) {
        this._logger.debug(`Middleware ${file} is disabled.`);
        return;
      }
      const mwClass = require(path.resolve(file));
      const mwInstance = new mwClass();

      // mark middleware with missing order with max number
      if (mwInstance.order == null) {
        mwInstance.order = Number.POSITIVE_INFINITY;
      }

      middleware.push([mwInstance, file]);
    });

    middleware.sort((a, b) => {
      if (a[0].order === Number.POSITIVE_INFINITY && b[0].order === Number.POSITIVE_INFINITY) {
        if (a[0].constructor.name < b[0].constructor.name) {
          return -1;
        } else if (a[0].constructor.name > b[0].constructor.name) {
          return 1;
        } else {
          return 0;
        }
      } else {
        return a[0].order - b[0].order;
      }
    });

    for (let i = 0; i < middleware.length; i++) {
      let mwInstance = middleware[i][0];

      // log middleware with deprecated function name, don't load
      if (mwInstance.mw) {
        this._logger.info(
          `Middleware ${mwInstance.constructor.name} uses deprecated function ".mw" to load. Use ".pre" or ".post"`
        );
      }

      // skip middleware based on active configuration profiles
      let p = mwInstance.profiles;
      if (p) {
        let match;
        if (Array.isArray(p)) {
          match = Config.isProfileActive(...p);
        } else if (typeof p === "string") {
          match = Config.isProfileActive(...p.split(",").map(p => p.trim()));
        } else {
          throw new BaseError(
            `Unsupported declaration type of middleware profiles in ${
              mwInstance.constructor.name
            }. Use Array or String.`
          );
        }
        if (!match) {
          mwInstance.__disabledByProfileCheck = true; // pass info to logging below
          continue;
        }
      }

      if (mwInstance.pre) {
        if (typeof mwInstance.pre === "function" && mwInstance.pre.length !== 3) {
          throw new BaseError(
            `Unsupported number of parameters in ${mwInstance.constructor.name} pre function. Use (req, res, next).`
          );
        }
        preControllerMiddleware.push(this._autoBind(mwInstance, mwInstance.pre));
      }

      if (mwInstance.post) {
        if (typeof mwInstance.post === "function" && mwInstance.post.length !== 3) {
          throw new BaseError(
            `Unsupported number of parameters in ${mwInstance.constructor.name} post function. Use (req, res, next).`
          );
        }
        postControllerMiddleware.unshift(this._autoBind(mwInstance, mwInstance.post));
      }

      if (mwInstance.onError) {
        if (typeof mwInstance.onError === "function" && mwInstance.onError.length !== 4) {
          throw new BaseError(
            `Unsupported number of parameters in ${
              mwInstance.constructor.name
            } onError function. Use (err, req, res, next).`
          );
        }
        postControllerMiddleware.unshift(this._autoBind(mwInstance, mwInstance.onError));
      }

      if (mwInstance.ensure) {
        if (typeof mwInstance.ensure === "function" && mwInstance.ensure.length !== 2) {
          throw new BaseError(
            `Unsupported number of parameters in ${mwInstance.constructor.name} ensure function. Use (req, res).`
          );
        }
        ensureFunctions.unshift(this._autoBind(mwInstance, mwInstance.ensure));
      }
    }

    // flatten
    preControllerMiddleware = [].concat.apply([], preControllerMiddleware);
    postControllerMiddleware = [].concat.apply([], postControllerMiddleware);
    ensureFunctions = [].concat.apply([], ensureFunctions);

    // log the loaded middleware in order
    middleware.forEach(mwArr => {
      let mw = mwArr[0];
      if (mw.doNotLog || mw.__disabledByProfileCheck) return;
      let mwPath = mwArr[1];
      this._logger.info(
        `[${mw.order === Number.POSITIVE_INFINITY ? "No Order" : mw.order}] => ${Loader.convertPathToNamespace(
          mwPath
        )}${mw.constructor.name}`
      );
    });

    this._logger.info("Middleware loaded.");
    return {
      preControllerMiddleware,
      postControllerMiddleware,
      ensureFunctions
    };
  }

  _autoBind(instance, mw) {
    if (Array.isArray(mw)) return mw;
    if (typeof mw === "function") return mw.bind(instance);
    throw new BaseError(
      `Unsupported type "${typeof mw}" of ${instance.constructor} middleware. Use function or array of functions.`
    );
  }
}

/**
 * Module exports a single instance of MiddlewareLoader that is initialized
 * at application startup (when the first relevant require call is resolved).
 * @type {MiddlewareLoader}
 */
module.exports = new MiddlewareLoader();
