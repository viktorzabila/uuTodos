"use strict";

const DeepMerge = require("deepmerge");
const Fs = require("fs");
const Path = require("path");
const { Config, BaseError, Finder } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");

/**
 * Class handles loading of mappings.json in application and its libraries (node_modules).
 * The correct placement is config/mappings.json in application / library root.
 * Other placements are ignored. MappingsLoader deserializes the files into objects
 * and attempts to merge them, throwing a BaseError whenever duplicities are found among
 * library mappings. Application mappings precede and overwrite library mappings.
 * The only public interface is the load function, which returns an object containing
 * the merged mappings under the data property and an array of their sources in the sources
 * property.
 */
class MappingsLoader {
  /**
   * Runs the loading process after getting current configuration.
   * @returns {Object} {data: merged mappings, sources: Array of mappings source paths}
   */
  load() {
    this._getConfiguration();
    let appMaps = this._getApplicationMappings(this._appMappingsPath);
    let libraryMappings = this._getLibraryMappings();
    let mergedLib = this._mergeLibraryMappings(libraryMappings);
    return this._buildAllMappings(appMaps, mergedLib);
  }

  /**
   * Gets mappings and appends source to each useCase
   * for consumption by ControllerLoader
   * down the line and for logging purposes.
   * @param source
   * @returns {Object} mappings
   * @private
   */
  _getMappings(source) {
    let mappings = require(source);
    let products = Object.keys(mappings);
    for (let i = 0; i < products.length; i++) {
      let product = products[i];
      let useCases = Object.keys(mappings[product].useCaseMap);
      for (let j = 0; j < useCases.length; j++) {
        let useCase = useCases[j];
        mappings[product].useCaseMap[useCase].source = source;
      }
    }
    return mappings;
  }

  /**
   * Merges application mappings and library mappings using the DeepMerge library.
   * Application mappings take precedence.
   * @param appMappings
   * @param libraryMappings
   * @returns {Object}
   * @private
   */
  _buildAllMappings(appMappings, libraryMappings) {
    libraryMappings.sources.push(appMappings.source);
    delete appMappings.source;
    this._getLogger().debug(`Mappings loaded from the following sources:\n${libraryMappings.sources.join("\n")}`);
    return DeepMerge(libraryMappings, appMappings);
  }

  /**
   * Loads application mappings.
   * Throws BaseError if there's no mappings.json at config/mappings.json.
   * @param source
   * @returns {{source: String, data: Object}} Source represents path to mappings.json.
   * @private
   */
  _getApplicationMappings(source) {
    if (Fs.existsSync(source)) {
      return {
        data: this._getMappings(source),
        source
      };
    } else {
      throw new BaseError("Unable to get application mappings. Application root does not exist. Path: " + source);
    }
  }

  /**
   * Using server_root from Config, it creates necessary paths and saves them to
   * the MappingsLoader object. Throws BaseError if server_root is not available in Config.
   * @private
   */
  _getConfiguration() {
    this._root = Config.get("server_root");
    if (!this._root) {
      throw new BaseError("Server root is not defined. Unable to resolve location of mappings.json.");
    }
    this._appMappingsPath = Finder.findConfigInProject(this._root, `{app,src,}/config/mappings.json`);
    if (!this._appMappingsPath) {
      this._appMappingsPath = Path.join(this._root, "app", "config", "mappings.json");
    }
  }

  /**
   * Loads library mappings into an array (of Objects).
   * Goes through the node_modules folder in application root and checks
   * whether mappings.json exists in any library at config/mappings.json.
   * @returns {Array}
   * @private
   */
  _getLibraryMappings() {
    let libraryMappings = [];

    let mappingPaths = Finder.findConfigInModules(this._root, "{app,src,}/config/mappings.json");

    mappingPaths.forEach(source =>
      libraryMappings.push({
        data: this._getMappings(source),
        source
      })
    );

    return libraryMappings;
  }

  // TODO Merging based on the PRIMARY key of Mappings.json
  /**
   * Merges library mappings into a single mappings object (data).
   * Needs to be reworked to observe the primary key of mappings to enable
   * prioritizing certain libraries.
   * Throws BaseError whenever duplicities in mappings are found.
   * @param libraryMappings
   * @returns {{data: {}, sources: Array}}
   * @private
   */
  _mergeLibraryMappings(libraryMappings) {
    let merged = {
      data: {},
      sources: []
    };
    for (let i = 0; i < libraryMappings.length; i++) {
      let current = libraryMappings[i];
      merged.sources.push(current.source);
      let products = Object.keys(current.data);
      for (let j = 0; j < products.length; j++) {
        let product = products[j];
        if (!current.data[product]["useCaseMap"]) {
          this._getLogger().warn(
            `Mapping file ${current.source} does not contain useCaseMap section in product: ${product}.`
          );
          break;
        }
        if (!merged.data[product]) {
          merged.data[product] = current.data[product];
          continue;
        }
        let useCases = Object.keys(current.data[product].useCaseMap);
        for (let k = 0; k < useCases.length; k++) {
          let useCase = useCases[k];
          let mergedEndpoint = merged.data[product]["useCaseMap"][useCase];
          let loopEndpoint = current.data[product]["useCaseMap"][useCase];
          if (mergedEndpoint === undefined) {
            merged.data[product]["useCaseMap"][useCase] = loopEndpoint;
          } else {
            let endpointProperties = Object.keys(loopEndpoint);
            for (let l = 0; l < endpointProperties.length; l++) {
              let property = endpointProperties[l];
              if (mergedEndpoint[property] !== loopEndpoint[property]) {
                throw new BaseError(
                  "Unable to merge mappings due to duplicity.\n" +
                    `product: ${product}\n` +
                    `useCase: ${useCase}\n` +
                    `source: ${current.source}\n`
                );
              }
            }
          }
        }
      }
    }
    return merged;
  }

  _getLogger() {
    if (!this._logger) {
      this._logger = LoggerFactory.get("UuApp.AppServer");
    }
    return this._logger;
  }
}

/**
 * Module exports a single instance of MappingsLoader that is initialized
 * at application startup (when the first relevant require call is resolved).
 * @type {MappingsLoader}
 */
module.exports = new MappingsLoader();
