"use strict";

const Os = require("os");
const Fs = require("fs");
const Path = require("path");
const Crypto = require("crypto");
const Archiver= require("archiver");
const Http = require("http");
const Https = require("https");
const {URL} = require("url");
const FormData = require("form-data");
const {Config, OptsReader, Mutex, BaseError} = require("uu_appg01_core-utils");
const {LoggerFactory} = require("uu_appg01_core-logging");
const {Validator, ValidationHelper} = require("uu_appg01_core-validation");
const Sys = require("./sys.js");
const Errors = require("../error/diagnostic-report-error.js");

const WARNINGS = {
  uploadUrlNotConfigured: {
    code: `${Errors.Generate.UC_CODE}uploadUrlNotConfigured`,
    message: "Diagnostic report upload URL is not configured. Report is available only in configured container location."
  }
};

const ENV_NODE_NAME = "UU_CLOUD_NODE_NAME";

const CFG_REPORT_LOCATION = "uu_app_diagnostic_report_location";

const CFG_UPLOAD_URL = "uu_app_diagnostic_report_upload_url";

const CFG_UPLOAD_AUTH = "uu_app_diagnostic_report_upload_auth";

const CFG_UPLOAD_PARAM = "uu_app_diagnostic_report_upload_param";

const CFG_UPLOAD_METHOD = "uu_app_diagnostic_report_upload_method";

const CFG_UPLOAD_CON_TIMEOUT = "uu_app_diagnostic_report_upload_con_timeout";

const CFG_UPLOAD_REQ_TIMEOUT = "uu_app_diagnostic_report_upload_req_timeout";

const CFG_REPORT_CLEANUP = "uu_app_diagnostic_report_cleanup";

const DEFAULT_REPORT_LOCATION = "diagnosticReports";

const DEFAULT_UPLOAD_CON_TIMEOUT = 5; // 5 seconds

const DEFAULT_UPLOAD_REQ_TIMEOUT = 5 * 60; // 5 minutes

const DEFAULT_REPORT_CLEANUP = "always";

const DEFAULT_HEADER_USER_AGENT = "uuAppClient (Node.js)";

class GenerateDiagnosticReport {

  constructor() {
    this._logger = LoggerFactory.get("UuApp.Appserver.DiagnosticReport");
    this._validator = Validator.load();
    let opts = new OptsReader(Config);
    this._asid = opts.getString("asid", "00000000000000000000000000000000");
    this._reportLocation = opts.getString(CFG_REPORT_LOCATION, Path.join(Os.tmpdir(), DEFAULT_REPORT_LOCATION));
    this._uploadUrl = opts.getString(CFG_UPLOAD_URL);
    this._uploadAuth = opts.getString(CFG_UPLOAD_AUTH);
    this._uploadParam = opts.getString(CFG_UPLOAD_PARAM);
    this._uploadMethod = opts.getString(CFG_UPLOAD_METHOD, this._uploadParam ? "POST" : "PUT");
    this._uploadConTimeout = opts.getNumber(CFG_UPLOAD_CON_TIMEOUT, DEFAULT_UPLOAD_CON_TIMEOUT) * 1000;
    this._uploadReqTimeout = opts.getNumber(CFG_UPLOAD_REQ_TIMEOUT, DEFAULT_UPLOAD_REQ_TIMEOUT) * 1000;
    this._reportCleanup = opts.getString(CFG_REPORT_CLEANUP, DEFAULT_REPORT_CLEANUP);
    this._mutex = new Mutex();
    if (!this._uploadUrl && this._reportCleanup === "always") {
      this._logger.debug("Diagnostic report disabled. Report upload URL is not configured and report cleanup is set to 'always'. Report would be inaccessible.");
    } else {
      try {
        this._nodeOomHeapdump = require("node-oom-heapdump")({heapdumpOnOOM: false});
      } catch (e) {
        this._nodeOomHeapdumpError = e;
      }
    }
  }

  async call(ucEnv) {
    Sys.authorize(ucEnv);
    if (!this._nodeOomHeapdump) {
      throw new Errors.Generate.MissingLibrary("Cannot generate diagnostic report. Missing library for creating heapdump.", this._nodeOomHeapdumpError);
    }
    if (!this._uploadUrl && this._reportCleanup == "always") {
      throw new Errors.Generate.InvalidConfiguration("Cannot generate diagnostic report. Report upload URL is not configured and report cleanup is set to 'always'. Report would be inaccessible.");
    }

    let snapshotReportLocation = this._getDiagnosticReportLocation(ucEnv.getUri());
    this._logger.info(`Generating diagnostic report to ${snapshotReportLocation}`);
    this._mutex.runInBand(this._generateDiagnosticReport.bind(this), snapshotReportLocation);

    let dtoOut = {};
    if (!this._uploadUrl) {
      this._logger.warn(`Diagnostic report upload URL is not configured, report is available only directly in ${snapshotReportLocation}`);
      dtoOut.uuApperroMap = {};
      dtoOut.uuApperroMap[WARNINGS.uploadUrlNotConfigured.code] = {
        message: WARNINGS.uploadUrlNotConfigured.message,
        type: "warning",
        timestamp: new Date().toISOString(),
        id: Crypto.randomBytes(16).toString("hex")
      }
    }
    return dtoOut;
  }

  async _generateDiagnosticReport(snapshotReportLocation) {
    let heapDumpFile = await this._createHeapdump(snapshotReportLocation);
    if (!heapDumpFile) {
      return;
    }

    let diagnosticReport = await this._compressDiagnosticReport(snapshotReportLocation);
    if (diagnosticReport || this._reportCleanup == "always") {
      Fs.rmdirSync(snapshotReportLocation, {recursive: true});
    }

    let uploadSuccessful = false;
    if (diagnosticReport && this._uploadUrl) {
      uploadSuccessful = await this._uploadDiagnosticReport(diagnosticReport);
    }

    if (this._reportCleanup == "always" || (uploadSuccessful && this._reportCleanup == "onSuccessfulUpload")) {
      Fs.unlinkSync(diagnosticReport);
    }
  }

  _getDiagnosticReportLocation(uri) {
    let nodeName = process.env[ENV_NODE_NAME];
    if (!nodeName) {
      nodeName = `${uri.getProduct()}-${this._asid}`
    }
    let randomId = Crypto.randomBytes(4).toString("hex");
    let reportDir = `${nodeName}-${Math.round(Date.now() / 1000)}-${randomId}`;
    return Path.join(this._reportLocation, reportDir);
  }

  async _createHeapdump(dumpLocation) {
    this._logger.debug("Creating heap dump");
    let dumpFile = Path.join(dumpLocation, `nodejs_pid${process.pid}`);
    try {
      dumpFile = await new Promise((resolve, reject) => {
        Fs.mkdirSync(dumpLocation, {recursive: true});
        this._nodeOomHeapdump.createHeapSnapshot(dumpFile).then(resultPath => {
          resolve(resultPath);
        }).catch(error => {
          reject(error);
        })
      });
    } catch (e) {
      this._logger.error("Creating of heap dump failed.", e);
      return null;
    }
    this._logger.debug(`Heap dump ${dumpFile} created`);
    return dumpFile;
  }

  async _compressDiagnosticReport(reportLocation) {
    this._logger.debug(`Compressing diagnostic report ${reportLocation}`);
    let reportArchive = `${reportLocation}.tar.gz`;
    try {
      await new Promise((resolve, reject) => {
        let output = Fs.createWriteStream(reportArchive);
        let archive = new Archiver('tar', {gzip: true, gzipOptions: {level: 9}});
        output.on("close", () => {resolve()});
        output.on("end", () => {resolve()});
        archive.on("warning", (error) => {resolve()});
        archive.on("error", (error) => {reject(error)});
        archive.pipe(output);
        let files = Fs.readdirSync(reportLocation);
        files.forEach((file) => {
          archive.file(Path.join(reportLocation, file), { name: file });
        });
        archive.finalize();
      });
    } catch (e) {
      this._logger.error(`Compression of diagnostic report ${reportLocation} failed.`, e);
      if (Fs.existsSync(reportArchive)) {
        Fs.unlinkSync(reportArchive);
      }
      return null;
    }
    this._logger.debug(`Diagnostic report compressed as ${reportArchive}`);
    return reportArchive;
  }

  async _uploadDiagnosticReport(diagnosticReportPath) {
    this._logger.debug(`Uploading diagnostic report ${diagnosticReportPath} to ${this._uploadUrl}`);
    try {
      return await new Promise((resolve, reject) => {
        let httpHeaders = {};
        httpHeaders["user-agent"] = DEFAULT_HEADER_USER_AGENT;
        httpHeaders["accept"] = "*/*";
        if (this._uploadAuth) {
          httpHeaders["authorization"] = this._uploadAuth;
        }
        let httpMethod = this._uploadMethod;
        let requestOptions = {
          method: httpMethod,
          headers: httpHeaders,
          timeout: this._uploadConTimeout
        };
        let finalUploadUrl;
        let requestBody;
        if (this._uploadParam) {
          finalUploadUrl = this._uploadUrl;
          let fileStream = Fs.createReadStream(diagnosticReportPath);
          requestBody = new FormData();
          requestBody.append(this._uploadParam, fileStream, {contentType: "application/octet-stream"});
          Object.assign(httpHeaders, requestBody.getHeaders());
        } else {
          finalUploadUrl = `${this._uploadUrl.replace("/+$", "")}/${Path.basename(diagnosticReportPath)}`;
          httpHeaders["content-type"] = "application/octet-stream";
          requestBody = Fs.createReadStream(diagnosticReportPath);
        }
        let url = new URL(finalUploadUrl);
        requestOptions.hostname = url.hostname;
        requestOptions.port = url.port;
        requestOptions.path = url.pathname + url.search;
        let request = (url.protocol == "https:" ? Https : Http).request(requestOptions, (response) => {
          response.on("data", (data) => {});
          response.on("end", () => {
            if (response.statusCode >=200 && response.statusCode < 300) {
              this._logger.info(`Diagnostic report uploaded to ${finalUploadUrl}`);
              resolve(true);
            } else {
              this._logger.error(`Upload of diagnostic report to ${finalUploadUrl} failed with response status ${response.statusCode}.`);
              resolve(false);
            }
          });
        });
        request.setTimeout(this._uploadReqTimeout, () => {
          reject(new BaseError("Request timed out."))
        });
        request.on("error", (error) => {
          reject(error);
        });
        requestBody.pipe(request);
      });
    } catch (e) {
      this._logger.error("Upload of diagnostic report to " + this._uploadUrl + " failed.", e);
      return false;
    }
  }

}

module.exports = new GenerateDiagnosticReport();
