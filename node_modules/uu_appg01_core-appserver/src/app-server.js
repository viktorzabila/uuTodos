"use strict";

const Fs = require("fs");
const Path = require("path");

// get default server root
const SERVER_ROOT = getServerRoot();
// set CWD as soon as possible
process.chdir(SERVER_ROOT);

// set server_root to Config
const { Config, BaseError, Finder, Json } = require("uu_appg01_core-utils");
Config.set("server_root", SERVER_ROOT);

// set configuration profile at require time to avoid errors with missing config
const DEFAULT_PROFILES = "development,production";
process.env["CONFIG_PROFILE"] = process.env["NODE_ENV"] || DEFAULT_PROFILES;

// profile activation
let profiles = process.env["CONFIG_PROFILE"];
profiles = profiles.split(",").map(p => p.trim());
Config.activateProfiles(...profiles);

// get and set server_host and server_port from activated profiles
const SERVER_PORT = Config.get("server_port") || Config.get("port") || process.env["PORT"] || 6221;
Config.set("server_port", parseInt(SERVER_PORT));
const SERVER_HOST = Config.get("server_host") || process.env["SERVER_HOST"] || "0.0.0.0";
Config.set("server_host", SERVER_HOST);

// TODO default request timeout is temporary set to 1 hour so the appServer can handle async requests (which may took up to 1 hour according to async gateway configuration).
// This is just a workaround to make async commands work. Timeout for async cmds should be configured in async runtimestack and the default value should be lowered to the sync one.
const DEFAULT_REQUEST_TIMEOUT = 3600000;

const { LoggerFactory } = require("uu_appg01_core-logging");
let logger;

const Http = require("http");
const Https = require("https");
const ExpressBuilder = require("./express-builder.js");

const ClientConfigurator = require("./runner/client-configurator.js");
const StartupListenersRunner = require("./runner/startup-listeners-runner.js");

/**
 * AppServer class deals with creation and closing of application servers with a preset configuration
 * that may either be passed directly to AppServer using an options object or automatically loaded
 * via the uu_appg01_core-utils/config module.
 *
 * To simplify instantiation and closing, startServer and stopServer static methods are provided and exported.
 */
class AppServer {

  static injectLibrary(libraryPath) {
    Finder.injectExternalModule(libraryPath);
  }

  constructor() {
    logger = LoggerFactory.get("UuApp.AppServer");

    this._running = false;

    process.on("unhandledRejection", cause => {
      const throwable = cause instanceof Error;
      const logMsg =
        "An unhandled promise rejection was intercepted." +
        "Please make sure that you correctly .catch() all" +
        "rejectable promises and wrap all async function invocations" +
        "that may throw in a try / catch block.";

      // log cause always
      if (!throwable) {
        try {
          cause = Json.stringify(cause);
        } catch (e) {
          // do nothing
        } finally {
          logger.fatal(logMsg + " Cause: " + cause);
        }
      } else {
        logger.fatal(logMsg, cause);
      }

      // rethrow cause on server startup
      if (!this._running) {
        if (throwable) {
          throw cause;
        } else {
          throw new BaseError("Unexpected error during server startup:", cause);
        }
      }
    });
  }

  /**
   * Starts a web server provided by Node.js http module at a given port and running Express.
   * Whenever started using Node child_process.fork, it will send a message to the parent
   * process in the format { port: portNumber } where portNumber is the number of the
   * assigned port. This is especially useful when letting the OS randomly assign port,
   * which may be achieved by setting port to 0 in the server.listen() function.
   */
  async createServer(initCallback = null) {
    if (!Config.isProfileActive("test") || logger.isInfoLoggable()) {
      logger.log("Initializing server.");
    }
    logger.info(`Server root: ${SERVER_ROOT}`);
    logger.info(`Configuration profile(s): ${profiles}`);
    let app = ExpressBuilder.build();
    let certConfig = Config.getArray("uu_app_server_ssl_cert", "string");
    if (certConfig) {
      let opts = {cert: resolveSslConfig(certConfig)};
      let keyConfig = Config.getArray("uu_app_server_ssl_key", "string");
      if (keyConfig) {
        opts.key = resolveSslConfig(keyConfig);
      }
      let caConfig = Config.getArray("uu_app_server_ssl_ca", "string");
      if (caConfig) {
        opts.ca = resolveSslConfig(caConfig);
      }
      let passphraseConfig = Config.getString("uu_app_server_ssl_pass");
      if (passphraseConfig) {
        opts.passphrase = resolveSslConfig(passphraseConfig);
      }
      this._server = Https.createServer(opts, app);
    } else {
      this._server = Http.createServer(app);
    }
    if (initCallback) {
      this._server = initCallback(this._server) || this._server;
    }
    let port = Config.get("server_port");
    await StartupListenersRunner.run();
    await ClientConfigurator.configureClient();

    const timeout = Config.getNumber("uu_app_server_request_timeout") || DEFAULT_REQUEST_TIMEOUT;
    this._server.setTimeout(timeout);
    this._server.listen(port, SERVER_HOST, () => {
      // if started as a child process, listen for stop server message.
      if (process.send) {
        process.on("message", m => {
          if (m === "killTestServerSubProcess") {
            process.exit();
          }
        });
      }
      setTimeout(() => (this._running = true), 5000);
    });
    this._server.on("listening", () => {
      // update Config to ensure correct server_port after start with random port number
      let address = this._server.address();
      address.protocol = "http";
      Config.set("server_port", address.port);
      // inform about actual address and that server is ready to receive requests
      if (process.send) {
        process.send(address);
      }
      if (!Config.isProfileActive("test") || logger.isInfoLoggable()) {
        logger.log(`Server started (port ${address.port})`);
      }
    });
  }

  /**
   * Closes the web server stored in this AppServer instance.
   */
  closeServer() {
    this._server.close(() => {
      if (!Config.isProfileActive("test") || logger.isInfoLoggable()) {
        logger.log("Server closed.");
      }
    });
  }
}

/**
 * This module makes available the AppServer class itself and also two helper methods.
 * AppServer should be used directly only when multiple server instances are necessary.
 * Otherwise, simplified startServer / stopServer API should be used.
 * @type {AppServer}
 */

let serverInstance = null;

module.exports = AppServer;
module.exports.startServer = (initCallback = null) => {
  if (!serverInstance) {
    serverInstance = new AppServer();
  }
  try {
    serverInstance.createServer(initCallback);
  } catch (error) {
    logger.fatal("Server startup failed.", error);
    throw error;
  }
  return serverInstance;
};
module.exports.stopServer = () => {
  serverInstance.closeServer();
};
module.exports.disableMiddleware = identifier => {
  require("./runner/middleware-disabler.js").disableMiddleware(identifier);
};

/**
 * Locates app.js (or other application entrypoint) using Node.js module.filename property,
 * by travelling up its parent modules (the first modules that originally required this module).
 * @returns {string} String representation of entrypoint directory.
 * @private
 */
function getServerRoot() {
  let rootModule = module;
  while (rootModule.parent != null) {
    rootModule = rootModule.parent;
    if (rootModule.filename.match(/^app\.js$/)) {
      break;
    }
  }
  let caller = rootModule.filename;
  return Path.dirname(caller);
}

function resolveSslConfig(paramValue) {
  let result;
  if (Array.isArray(paramValue)) {
    result = [];
    paramValue.forEach(value => {
      if (Fs.existsSync(value)) {
        result.push(Fs.readFileSync(value).toString().trim());
      } else {
        result.push(value);
      }
    });
  } else {
    if (Fs.existsSync(paramValue)) {
      result = Fs.readFileSync(paramValue).toString().trim();
    } else {
      result = paramValue;
    }
  }
  return result;
}
