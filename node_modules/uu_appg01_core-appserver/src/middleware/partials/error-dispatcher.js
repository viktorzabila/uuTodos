"use strict";
const ejs = require("ejs");
const fs = require("fs");
const path = require("path");

const httpStatusCodes = require("../../http/http-status-codes.js");
const { LoggerFactory } = require("uu_appg01_core-logging");
const errorConverter = require("../../utils/error-converter");

/**
 * ErrorDispatcher is a helper class that takes care of error serialization.
 * Both ErrorHandler and NoResponse middleware depend on this module.
 */
class ErrorDispatcher {
  /**
   * Dispatch method uses Express res.format API to correctly serialize
   * errors based on request accept headers. HTML and JSON error responses
   * are supported.
   * @param {BaseError, UseCaseError} err
   * @param {Object} res
   * @param {Object} opts
   */
  dispatch(err, res, opts) {
    let { htmlEnabled, verbose } = opts;
    let { dtoOut, status, headers, errorCode, errorMessage } = errorConverter.buildErrorDtoOut(err, verbose);
    res.locals.dispatchedError = err;
    res.locals.dispatchedErrorCode = errorCode;
    res.locals.dispatchedErrorMessage = errorMessage;

    if (status >= 500) {
      this._getLogger().fatal("Request failed.", err);
    } else {
      this._getLogger().error("Request failed.", err);
    }
    res.format({
      json: () => {
        res.status(status);
        res.set(headers);
        res.json(dtoOut);
      },
      html: () => {
        res.status(status);
        res.set(headers);
        if (htmlEnabled) {
          let params = this._buildHttpErrorResponse(err, status, verbose);
          fs.readFile(path.join(__dirname, "..", "..", "views", `error-${status}.ejs`), "utf8", (err, text) => {
            if (err) {
              if (err.code === "ENOENT") {
                this._getLogger().debug("No error template found in views folder. Using default set of templates.");
                fs.readFile(path.join(__dirname, "..", "..", "views", "error-default.ejs"), "utf8", (err, text) => {
                  res.send(ejs.compile(text)(params));
                });
              } else {
                throw err;
              }
            } else {
              res.send(ejs.compile(text)(params));
            }
          });
        } else {
          res.json(dtoOut);
        }
      },
      default: () => {
        // default is a reserved keyword
        res.status(status);
        res.set(headers);
        res.json(dtoOut);
      }
    });
  }

  /**
   * Builds standardized error message, assigning default values
   * and headers where missing.
   * @param {BaseError, UseCaseError} error
   * @param {Boolean} verbose
   * @returns {{errorMessage: (*|{}), status: number, headers: {}}}
   * @private
   */
  _buildErrorMessage(error, verbose = false) {
    let status = error.status || 500;
    let headers = error.headers || {};
    headers["Connection"] = headers["Connection"] || "close";
    let errorMessage = error.dtoOut || {};
    let code = error.code || "uu-appg01/server/internalServerError";
    errorMessage["uuAppErrorMap"] = errorMessage["uuAppErrorMap"] || {};

    let messageBody = {};
    let raisedErrorMessage = {
      [code]: messageBody
    };

    if (error.id) {
      messageBody.id = error.id;
    }
    if (error.timestamp) {
      messageBody["timestamp"] = error.timestamp.toISOString();
    }
    if (error.type) {
      messageBody.type = error.type;
    } else {
      messageBody.type = "error";
    }
    if (verbose || error.message !== error.constructor.name) {
      messageBody.message = error.message;
    } else {
      messageBody.message = "Unexpected error";
    }
    if (error.paramMap && typeof error.paramMap === "object" && Object.keys(error.paramMap).length) {
      messageBody.paramMap = error.paramMap;
    }
    if (verbose) {
      messageBody.trace = error.stack;
      if (error.cause) {
        messageBody.cause = this._buildErrorMessage(error.cause, verbose).errorMessage;
      }
    } else {
      if (error.cause && error.cause.code) {
        messageBody.cause = this._buildErrorMessage(error.cause, verbose).errorMessage;
      }
    }

    delete errorMessage.uuAppErrorMap.code;
    errorMessage.uuAppErrorMap = Object.assign(raisedErrorMessage, errorMessage.uuAppErrorMap);

    return {
      errorMessage,
      status,
      headers,
      errCode: code,
      errMessage: messageBody.message
    };
  }

  /**
   * Prepares a data object for serialization (rendering) using EJS template.
   * @param {BaseError, UseCaseError} error
   * @param {Number} status
   * @param {Boolean} verbose
   * @returns {{verbose: boolean, statusCode: number, statusText: string, error: {message: string, trace, code: string, id: uuid}}}
   * @private
   */
  _buildHttpErrorResponse(error, status, verbose = false) {
    return {
      verbose,
      statusCode: status,
      statusText: httpStatusCodes[status],
      error: {
        message: error.message,
        trace: error.stack,
        code: error.code || "",
        id: error.id
      }
    };
  }

  _getLogger() {
    if (!this._logger) {
      this._logger = LoggerFactory.get("UuApp.AppServer");
    }
    return this._logger;
  }
}

/**
 * Module exports a single instance of ErrorDispatcher that is initialized
 * at application startup (when the first relevant require call is resolved).
 * @type {ErrorDispatcher}
 */
module.exports = new ErrorDispatcher();
