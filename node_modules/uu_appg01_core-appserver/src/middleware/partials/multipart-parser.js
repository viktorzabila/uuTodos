const Busboy = require("busboy");
const onFinished = require("on-finished");
const BadRequest = require("../../error/bad-request.js");
const { Json } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const logger = LoggerFactory.get("UuApp.AppServer");

const RE_MIME = /^(?:multipart\/.+)$/i;

/**
 * MultipartParser uses Busboy to parse multipart bodies.
 */
function multipartParser(req, res, next) {
  // filter out non-multipart requests
  if (req.method === "GET" || req.method === "HEAD" || !_hasBody(req) || !RE_MIME.test(_mime(req))) return next();

  // perhaps allow external configuration here in the future?
  let cfg = {
    limits: {
      files: 1
    }
  };
  cfg.headers = req.headers;

  // init Busboy and other request scoped variables
  let busboy;
  let isDone = false;
  let nextCalled = false;
  let fileRead = false;
  // done function makes sure that next() is not called multiple times
  let done = err => {
    if (isDone) return;
    isDone = true;

    // clean up
    req.unpipe(busboy);
    _drainStream(req);
    busboy.removeAllListeners();

    // call next() after cleanup is done
    onFinished(req, () => {
      nextCalled || next(err);
    });
  };

  try {
    busboy = new Busboy(cfg);
  } catch (err) {
    return next(new BadRequest("Unable to parse multipart body.", err));
  }

  // prepare storage for the parsed body and file stream
  req.body = {};
  req.multipart = Object.create(null);
  // attach abort (done) function to request
  req.multipart.abortStream = done;

  // handle multipart fields (anything that's not a file)
  busboy.on("field", (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) => {
    if (fileRead) return;

    if (fieldnameTruncated) return done(new BadRequest("Exceeded size limit for a fieldname."));
    if (valTruncated) return done(new BadRequest(`Exceeded size limit for value in field: ${fieldname}`));
    // try converting JSON value to Object
    if (mimetype === "application/json") {
      try {
        val = Json.parse(val);
      } catch (err) {
        return done(new BadRequest(`Unable to parse multipart body. Field: ${fieldname} contains invalid JSON.`, err));
      }
    }

    req.body[fieldname] = val;

    logger.debug("Field [" + fieldname + "]: value: " + Json.stringify(val));
  });

  // handle Busboy file events
  busboy.on("file", (fieldname, file, filename, encoding, mimetype) => {
    file.on("end", () => {
      logger.debug("File [" + fieldname + "] Finished");
      return done();
    });

    file.on("error", err => {
      return done(new BadRequest("Unable to parse multipart body.", err));
    });

    if (fileRead) return;

    // remove empty files
    if (!filename) return file.resume();

    // attach file stream to body object under its fieldname
    req.body[fieldname] = file;

    let stream = req.body[fieldname];

    // attach file metadata to the stream object
    stream.filename = filename;
    stream.contentType = mimetype;

    logger.debug(
      "File [" + fieldname + "]: filename: " + filename + ", encoding: " + encoding + ", mimetype: " + mimetype
    );

    // read no more fields if file stream started
    fileRead = true;

    // make sure next is not called multiple times
    nextCalled = true;
    return next();
  });

  // clean up
  busboy.on("finish", () => {
    logger.debug("Done parsing multipart form!");
    return done();
  });

  // handle error events
  busboy.on("error", err => {
    return done(new BadRequest("Unable to parse multipart body.", err));
  });

  // pipe request to Busboy for parsing
  req.pipe(busboy);
}

function _hasBody(req) {
  let encoding = "transfer-encoding" in req.headers,
    length = "content-length" in req.headers && req.headers["content-length"] !== "0";
  return encoding || length;
}

function _mime(req) {
  let str = req.headers["content-type"] || "";
  return str.split(";")[0];
}

function _drainStream(stream) {
  stream.on("readable", stream.read.bind(stream));
}

/**
 * Module exports multipartParser function.
 * @type {function}
 */
module.exports = multipartParser;
