"use strict";

const ErrorDispatcher = require("./partials/error-dispatcher.js");
const { Config } = require("uu_appg01_core-utils");
const { Perflog } = require("uu_appg01_core-perflog");

const MIDDLEWARE_ORDER = -500;

/**
 * ErrorHandler encapsulates ErrorDispatcher into a middleware function,
 * passing relevant options.
 */
class ErrorHandler {
  constructor() {
    this.order = MIDDLEWARE_ORDER;
    this._htmlEnabled = Config.get("html_error_response_enabled") || true;
    this._verbose = Config.isProfileActive("test", "development");
  }

  /**
   * Handle errors and serialize error response.
   * @param err
   * @param req
   * @param res
   * @param next
   * @returns {*}
   */
  onError(err, req, res, next) {
    // init response serialization measuring
    Perflog.measureSection("UU_APP_SERVER_HANDLE_RESPONSE", section => {
      let close = section.close;
      res.locals.handleResponseMeasuredSection = () => close.apply(section);
      section.close = () => {
        // Override close method
      };
    });

    // delegate error handling to Express in case of an error in a streaming response
    if (res.headersSent) {
      return next(err);
    }
    // handle using ErrorDispatcher otherwise
    let opts = {
      htmlEnabled: this._htmlEnabled,
      verbose: this._verbose
    };
    ErrorDispatcher.dispatch(err, res, opts);
  }

  /**
   * Terminate response serialization measuring.
   * @param req
   * @param res
   */
  ensure(req, res) {
    let stop = res.locals.handleResponseMeasuredSection;
    stop && stop();
  }
}

/**
 * Module exports ErrorHandler constructor.
 * @type {ErrorHandler}
 */
module.exports = ErrorHandler;
