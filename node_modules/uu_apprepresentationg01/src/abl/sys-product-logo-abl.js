"use strict";

const fs = require("fs");
const { promisify } = require("util");
const Path = require("path");
const { Readable } = require("stream");

const MimeTypes = require("mime-types");

const { LruCache, Config } = require("uu_appg01_core-utils");
const { Validator } = require("uu_appg01_core-validation");
const { DaoFactory, ObjectStoreError, ObjectNotFound } = require("uu_appg01_objectstore");
const { ValidationHelper } = require("uu_appg01_core-appserver");
const { LoggerFactory } = require("uu_appg01_core-logging");

const logger = LoggerFactory.get("UuAppRepresentation.ProductLogoAbl");

const Errors = require("../api/errors/sys-product-logo-errors");

const APP_PRODUCT_LOGO_CACHE_TTL_CONFIG_NAME = "uu_app_representation_product_logo_cache_ttl";
const APP_PRODUCT_LOGO_CACHE_TTL_DEFAULT_VALUE = 5 * 24 * 60 * 60 * 1000;

const APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_TYPE = "16x9";
const APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_LANGUAGE = "en";

const DEFAULT_MAXIMUM_LOGO_MAX_SIZE = 1000 * 1000; // 1MB
const DEFAULT_LOGO_TYPES = ["image/jpeg", "image/png", "image/svg+xml"];
const POSSIBLE_EXTENSIONS = ["jpeg", "jpg", "svg", "png"];

class SysProductLogoAbl {
  constructor() {
    let maxAge =
      Config.get(APP_PRODUCT_LOGO_CACHE_TTL_CONFIG_NAME) !== null
        ? Config.getNumber(APP_PRODUCT_LOGO_CACHE_TTL_CONFIG_NAME) * 1000
        : APP_PRODUCT_LOGO_CACHE_TTL_DEFAULT_VALUE;
    this.productLogoCache = new LruCache({ maxAge });
    this.validator = Validator.load();
    this.dao = DaoFactory.getDao("sysProductLogo");

    this._rootPath = Path.join(Config.get("server_root"));
    this.asid = Config.get("asid");
  }

  /**
   * create empty collection with indexes
   * @returns {Promise<void>}
   */
  async createSchema() {
    await this.dao.createSchema();
  }

  /**
   * Sets product logo of uuAppWorkspace.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async setProductLogo(awid, dtoIn, uuAppErrorMap = {}) {
    const asidCall = awid === this.asid;
    const ucErrors = Errors(asidCall).SetProductLogo;

    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysProductLogoSetType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      ucErrors.getUnsupportedKeysWarningCode(),
      ucErrors.InvalidDtoInError
    ); // A1, A2

    // HDS 2. - For every logo in dtoIn (dtoIn.logo or dtoIn.logosArchive) checks,
    // whether the logo fulfils valid format conditions.
    // HDS 2.1. - Checks whether the logo is valid file type (jpg, png) (A3)
    let sysProductLogo = {};
    sysProductLogo.contentType = MimeTypes.lookup(dtoIn.logo.filename);

    if (!DEFAULT_LOGO_TYPES.includes(sysProductLogo.contentType)) {
      throw new ucErrors.LogoFileTypeNotSupportedError(
        { uuAppErrorMap },
        {
          // A3
          logoType: sysProductLogo.contentType,
          supportedTypes: DEFAULT_LOGO_TYPES,
        }
      );
    }

    // HDS 2.2. - Encodes the logo (binary file) to Base64 format.
    const logoBuffer = await this._streamToBuffer(dtoIn.logo, ucErrors);
    sysProductLogo.logo = logoBuffer.toString("base64");

    // HDS 2.3. - Checks that logo size is not greater than 1000 kB (A4)
    sysProductLogo.size = logoBuffer.length;
    if (sysProductLogo.size > DEFAULT_MAXIMUM_LOGO_MAX_SIZE) {
      throw new ucErrors.LogoExceededSizeLimitError(
        { uuAppErrorMap },
        {
          // A4
          logoSize: sysProductLogo.size,
          sizeLimit: DEFAULT_MAXIMUM_LOGO_MAX_SIZE,
        }
      );
    }

    // HDS 2.4. - System updates sysProductLogo uuObject (sysProductLogo DAO updateByTypeAndLanguage). (A5, A7)
    sysProductLogo.awid = awid;
    sysProductLogo.filename = dtoIn.logo.filename;
    sysProductLogo.language = dtoIn.language;
    sysProductLogo.type = dtoIn.type;

    let dtoOut;

    try {
      dtoOut = await this.dao.updateByTypeAndLanguage(sysProductLogo);
    } catch (e) {
      if (e instanceof ObjectNotFound) {
        try {
          // A5 - Creates new sysProductLogo uuObject (sysProductLogo DAO create) (A6)
          dtoOut = await this.dao.create(sysProductLogo);
        } catch (e) {
          if (e instanceof ObjectStoreError) {
            // A6
            throw new ucErrors.SysProductLogoDaoCreateFailedError({ uuAppErrorMap }, e);
          }
          throw e;
        }
      } else if (e instanceof ObjectStoreError) {
        // A7
        throw new ucErrors.SysProductLogoDaoUpdateFailedError({ uuAppErrorMap }, e);
      } else {
        throw e;
      }
    }

    // HDS 3. - System updates cache. (TTL 5 days - 432000)
    this._addToCache(sysProductLogo);

    // HDS 4. - Returns properly filled dtoOut.
    delete dtoOut.logo;

    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   * Returns stored product logo of uuAppWorkspace.
   * If it doesn't exist, uuCmd tries to load default logo from static resources (-hi project).
   * Specifically from ./public/assets/logos/${dtoIn.type}.png or ./public/assets/logo.png.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @param {Object} uuAppErrorMap
   * @returns {Promise<{}>}
   */
  async getProductLogo(awid, dtoIn, uuAppErrorMap = {}) {
    const asidCall = awid === this.asid;
    const ucErrors = Errors(asidCall).GetProductLogo;

    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysProductLogoGetType", dtoIn);
    uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      ucErrors.getUnsupportedKeysWarningCode(),
      ucErrors.InvalidDtoInError
    ); // A1, A2

    // HDS 1.4. - Keys that are missing from dtoIn and a default value is required for them (see default values table),
    // will be provided with a respective default value.
    dtoIn.type = dtoIn.type || APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_TYPE;
    dtoIn.language = dtoIn.language || APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_LANGUAGE;

    // HDS 2. - System loads uuObject from cache. (A3)
    let fileStream;
    let sysProductLogo = await this._getProductLogo(awid, dtoIn.language, dtoIn.type);

    if (!sysProductLogo && !asidCall) {
      // load asid logo if set
      sysProductLogo = await this._getProductLogo(this.asid, dtoIn.language, dtoIn.type);
    }

    if (!sysProductLogo) {
      let filePath;
      for (let i = 0; i < POSSIBLE_EXTENSIONS.length; i++) {
        filePath = Path.resolve(this._rootPath, `./public/assets/logos/${dtoIn.type}.${POSSIBLE_EXTENSIONS[i]}`);
        fileStream = await this._getFileIfExists(filePath);
        if (fileStream) break;
      }
      if (!fileStream && dtoIn.type === APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_TYPE) {
        for (let i = 0; i < POSSIBLE_EXTENSIONS.length; i++) {
          filePath = Path.resolve(this._rootPath, `./public/assets/logo.${POSSIBLE_EXTENSIONS[i]}`);
          fileStream = await this._getFileIfExists(filePath);
          if (fileStream) break;
        }
      }
      if (!fileStream) {
        // A8
        throw new ucErrors.DefaultLogoDoesNotExist({ uuAppErrorMap }, { awid });
      }
    }

    // HDS 4. - Returns properly filled out dtoOut
    let dtoOut = {};

    if (sysProductLogo) {
      const imgBuffer = Buffer.from(sysProductLogo.logo, "base64");

      dtoOut.stream = this._streamData(imgBuffer);
      dtoOut.filename = sysProductLogo.filename;
      dtoOut.contentType = sysProductLogo.contentType;
      dtoOut.contentLength = imgBuffer.length;
    } else if (fileStream) {
      // TODO possible optimization - store even default logo to cache (by converting it to buffer)
      dtoOut.stream = fileStream;
      dtoOut.filename = Path.parse(fileStream.path).base;
      dtoOut.contentType = MimeTypes.lookup(fileStream.path);
    }
    return dtoOut;
  }

  async _getProductLogo(awid, language, type) {
    let sysProductLogo = this.productLogoCache.get(`${awid}_${language}_${type}`);
    if (!sysProductLogo) {
      sysProductLogo = await this.dao.getByTypeAndLanguage(awid, type, language);
      if (!sysProductLogo) {
        // if logo with user defined language is not available, check english version first
        if (language !== APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_LANGUAGE) {
          sysProductLogo = await this.dao.getByTypeAndLanguage(awid, type, APP_WORKSPACE_DEFAULT_PRODUCT_LOGO_LANGUAGE);
        }
        // if there is not english logo in the db, get any
        if (!sysProductLogo) {
          sysProductLogo = await this.dao.getByType(awid, type);
        }
      }

      if (sysProductLogo) {
        this._addToCache(sysProductLogo);
      }
    }
    return sysProductLogo;
  }

  /**
   * Store sysProductLogo info in the cache.
   *
   * @param {Object} sysProductLogo
   */
  _addToCache(sysProductLogo) {
    this.productLogoCache.set(
      `${sysProductLogo.awid}_${sysProductLogo.language}_${sysProductLogo.type}`,
      sysProductLogo
    );
  }

  /**
   * Creates readStream if a file exist.
   *
   * @param {String} path
   */
  async _getFileIfExists(path) {
    const fsReadFile = promisify(fs.readFile);
    try {
      await fsReadFile(path);
      return fs.createReadStream(path);
    } catch (error) {
      logger.warn(`File ${path}, not found.`);
    }
    return null;
  }

  /**
   * Converts streamed data into Buffer.
   *
   * @param {Object} stream
   * @param {Object} ucErrors
   */
  async _streamToBuffer(stream, ucErrors) {
    const chunks = [];
    let totalLength = 0;
    return new Promise((resolve, reject) => {
      stream.on("data", (chunk) => {
        totalLength += chunk.length;
        if (totalLength > 10000 * 1000) {
          // Workaround for 502 gateway error caused by Apache if response is send before whole request is read.
          // We try to load data up to size 10MB to return proper error to the user.
          stream.destroy();
          reject(
            new ucErrors.LogoExceededSizeLimitError({
              logoSize: totalLength,
              sizeLimit: DEFAULT_MAXIMUM_LOGO_MAX_SIZE,
            })
          );
        } else {
          chunks.push(chunk);
        }
      });
      stream.on("error", reject);
      stream.on("end", () => resolve(Buffer.concat(chunks)));
    });
  }

  /**
   * Creates a new readable stream from given Buffer.
   *
   * @param {Object} data
   */
  _streamData(data) {
    let stream = new Readable({
      read: () => {
        stream.push(data);
        stream.push(null);
      },
    });

    return stream;
  }
}

module.exports = new SysProductLogoAbl();
