/*!
 * UAF COMMERCIAL LICENSE
 * ----------------------
 * 1. PREAMBLE and Definitions
 *   1.1 These UAF Commercial License Terms ("UAF CLT") govern licensing of the Unicorn Application Framework (UAF).
 *     The Customer and Unicorn concluded an agreement for the provision of Solution that is using UAF or its parts
 *     (the "Agreement").
 *   1.2 The provisions of these UAF CLT shall govern the relationship between the Customer and Unicorn regarding
 *     the UAF License granted under the Agreement. For the avoidance of doubt, in case of any conflict between these
 *     UAF CLT and the Agreement, the provisions of the Agreement always prevail.
 *   1.3 The "UAF Components", and each of them individually as "UAF Component", shall mean the components of the Unicorn
 *     Application Framework, which are listed and described in the Attachment I to these UAF CLT.
 *   1.4 "UAF" shall mean the Unicorn Application Framework the scope of which is described in Attachment I, including all
 *     associated documentation and preparatory design materials, in particular blueprints, models, user manuals,
 *     training materials, comprehensive instructions and guidelines for drafting, production, operation and maintenance of
 *     software solutions, reference architecture, ready-made components and tools, use cases and tutorials.
 *   1.5 The "Knowledge Base" shall mean the online materials, internet fora and other resources made available by Unicorn
 *     online with regard to the UAF, intended for the broad customer and developer community.
 *   1.6 The "License" shall mean the binding terms and conditions for use of the UAF by the Customer. The License is
 *     described in Clause 2 and may be further specified or modified by the Agreement.
 *   1.7 The "Solution" shall mean any product or service developed under the Agreement using the UAF or any of
 *     UAF Components or its other parts, further specified in the Agreement.
 * 2. LICENSE GRANT
 *   2.1 The Customer shall be hereby granted a non-exclusive and non-transferable worldwide license to use the UAF for
 *     the purpose of the Solution described in the Agreement. For this purpose, the Customer shall be entitled to modify
 *     the UAF and create derivative works based on the UAF.
 *   2.2 The Customer is entitled to grant third parties a sub-license allowing them to use the UAF or any derivative works
 *     based on the UAF under commercial terms of its choice, provided that:
 *     2.2.1 use of the UAF and any derivative works based on the UAF by third parties is limited to testing, handover and
 *       operation of the Solution or its use as a service,
 *     2.2.2 third parties are not entitled to use the UAF or any derivative works based on the UAF independently of
 *       the Solution,
 *     2.2.3 third parties are not provided access to source code of the UAF unless such right is granted by the Agreement
 *       or if they conclude a commercial license agreement with Unicorn.
 *   2.3 The Solution or its parts based on the UAF shall bear a prominent copyright notice "Based on Unicorn Application
 *     Framework Copyright (c) Unicorn" integrated
 *     2.3.1 in the graphical user interface of the Solution or its relevant part or
 *     2.3.2 in accompanying file if the Solution or its relevant part do not have graphical user interface or
 *     2.3.3 in Solution's documentation.
 *   2.4 The License shall be valid for the whole duration of copyright to the UAF, unless other duration of the License is
 *     specified in the Agreement.
 *   2.5 The Customer is entitled to access the Knowledge Base only if expressly agreed in the Agreement.
 *   2.6 The Unicorn retains all rights to the UAF not covered by the provisions of this Clause 2. Unless explicitly
 *     permitted by applicable law, the Customer may not use the UAF in any other way than provided by the provisions of
 *     this Clause 2 and may not allow such use on its behalf by any of its employees or agents.
 *   2.7 The price for the License is included in the price stipulated in the Agreement.
 * 3. MODIFICATIONS
 *   3.1 The Customer explicitly acknowledges that the UAF is under continuous development and any UAF Component or other
 *     part of the UAF may be modified, replaced or removed by the Unicorn from the UAF in any of its future versions.
 *   3.2 This License covers also any new version of UAF if some parts of the UAF are modified or replaced.
 *   3.3 If any part of the UAF is removed by Unicorn in any of its future versions, the License for such version of
 *     the UAF is reduced appropriately and covers only the remaining parts of UAF. Sub-licenses previously granted to
 *     third parties in accordance with Clause 2.2 remain unaffected.
 * 4. THIRD PARTY LICENSE TERMS
 *   4.1 UAF is using third party software tools (the "Third Party Software") that is an integral part of the UAF. Some of
 *     these tools are free software or open-source SW.
 *   4.2 The list of Third Party Software used in the UAF including its license terms and authors is provided as part of
 *     Attachment I to these UAF CLT.
 *   4.3 For the use of the above mentioned Third Party Software, the Customer acknowledges its license terms referred to
 *     in Attachment I to these UAF CLT.
 * 5. NO TRADEMARK OR PATENT LICENSE
 *   5.1 These UAF CLT cover only copyright use of the UAF. If not expressly agreed otherwise, the Customer shall not be
 *     granted any trademark and/or patent license here under and nothing in these UAF CLT shall be interpreted in a way it
 *     does so.
 * 6. LIMITED WARRANTY
 *   6.1 IF NOT STIPULATED OTHER WISE OR REQUIRED BY APPLICABLE LAW, THE UAF IS PROVIDED ON "AS IS" BASIS,
 *     WITH NO WARRANTY OF, INCLUDING WITHOUT LIMITATION, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
 *     RISK AS TO THE QUALITY AND PERFORMANCE OF THE UAF IS CARRIED SOLELY BY THE CUSTOMER, UNLESS OTHERWISE AGREED BETWEEN
 *     THE UNICORN AND THE CUSTOMER IN THE AGREEMENT.
 * 7. LIMITATION OF LIABILITY
 *   7.1 TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE UNICORN WILL NOT BE HELD LIABLE FOR ANY DAMAGES CAUSED BY
 *     THE DISTRIBUTION OR USE OF THE UAF. THIS ALSO INCLUDES ANY CONSEQUENTIAL AND/OR INCIDENTAL DAMAGES, MONETARY OR NOT,
 *     THAT ARE CONNECTED WITH THE DISTRIBUTION OR USE OF THE UAF, UNLESS OTHERWISE AGREED BETWEEN THE UNICORN AND
 *     THE CUSTOMER IN THE AGREEMENT.
 * 8. THIRD PARTY CLAIMS
 *   8.1 The Unicorn will defend or settle, at its option and expense, any action brought against the Customer in a member
 *     state of the European Union which concerns an allegation that the UAF provided infringes a patent or copyright or
 *     misappropriates a trade secret in such jurisdiction. The Unicorn shall pay costs and damages finally awarded against
 *     the Customer that are attributable to such action. The Customer declares to understand and agrees that following
 *     conditions must be fulfilled in order to make Unicorn's obligations under this Clause 8 effective and enforceable:
 *     The Customer must (a) notify Unicorn promptly in writing of the action or any reasonable threat of it,
 *     (b) provide the Unicorn with all reasonable information and assistance it will request to settle or defend the action, and
 *     (c) grant the Unicorn sole authority and control of the defense or settlement of the action.
 *   8.2 If a claim is made under Clause 8.1 the Unicorn may, at its sole option and expense:
 *     (a) replace or modify the UAF so that it becomes non-infringing,
 *     (b) procure for the Customer the right to continue using the UAF unmodified.
 *   8.3 The Unicorn shall not be held liable to the Customer if the action is based on:
 *     (a) the combination of UAF with any product not provided by Unicorn,
 *     (b) the modification of the UAF other than by Unicorn,
 *     (c) the use of other than a current unaltered release of the UAF,
 *     (d) a product that the Customer makes, uses, or sells,
 *     (e) infringement by the Customer that is deemed willful. In the case under (e) the Customer shall reimburse
 *     the Unicorn for its reasonable attorney fees and other costs related to the action.
 *   8.4 THIS CLAUSE IS SUBJECT TO CLAUSE 7 AND STATES UNICORN'S ENTIRE LIABILITY, CUSTOMER'S SOLE AND EXCLUSIVE REMEDY,
 *     FOR DEFENSE, SETTLEMENT AND DAMAGES, WITH RESPECT TO ANY ALLEGED PATENT OR COPYRIGHT INFRINGEMENT OR TRADE SECRET
 *     MISAPPROPRIATION BY ANY ITEM PROVIDED UNDER THESE TERMS, UNLESS OTHERWISE AGREEMENT BETWEEN UNICORN AND THE CUSTOMER
 *     IN THE AGREEMENT.
 * 9. GENERAL PROVISIONS
 *   9.1 By entering into the Agreement, the Customer signifies its assent to and acceptance of these UAF CLT.
 *   9.2 The License is effective from the moment of execution of the Agreement, if the Agreement does not specify later
 *     date. Where the provisions of the Agreement regarding the License and provisions of these UAF CLT differ, provisions
 *     of the Agreement shall prevail.
 *   9.3 If any provision of the Agreement regarding the License or these UAF CLT is held by a court of competent
 *     jurisdiction to be void, invalid, unenforceable or illegal, such provision shall be severed from the Agreement or
 *     these UAF CLT and the remaining provisions will remain in full force and effect.
 *   9.4 The provisions of Clauses 7 and 8 shall survive any expiration or termination of the Agreement.
 *   9.5 All rights and obligations between the Unicorn and the Customer arising on the basis of these UAF CLT or
 *     in connection with them are governed by the laws of the Czech Republic with the exclusion of both the rules on
 *     the conflict of laws and the United Nations Convention on Contracts for the International Sale of Goods (CISG).
 *   9.6 The resolution of all disputes arising from or connected here to shall be under sole jurisdiction of the courts of
 *     the Czech Republic.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"));
	else if(typeof define === 'function' && define.amd)
		define("uu5stringg01", ["module"], factory);
	else if(typeof exports === 'object')
		exports["uu5stringg01"] = factory(require("module"));
	else
		root["Uu5String"] = factory(root["undefined"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var mod = __webpack_require__(2);

var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...

var floatingVersion = "/1.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/1.3.4/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  get Uu5String() {
    return __webpack_require__(4);
  },

  get Uu5Json() {
    return __webpack_require__(11);
  },

  get Uu5Data() {
    return __webpack_require__(10);
  }

};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var Uu5StringTools = __webpack_require__(5);

var Uu5StringObject = __webpack_require__(12);

var Uu5StringProps = __webpack_require__(14);

var _require = __webpack_require__(7),
    REGEXP = _require.REGEXP;

var defaultFactory = __webpack_require__(13);

var Uu5String = /*#__PURE__*/function () {
  // TODO to 2.0.0 remove templateDataMap from constructor!
  function Uu5String(uu5string) {
    var _this = this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        templateDataMap = _ref.templateDataMap,
        initialUu5DataMap = _ref.uu5DataMap,
        allowedTagsRegExp = _ref.allowedTagsRegExp,
        _ref$initFn = _ref.initFn,
        initFn = _ref$initFn === void 0 ? null : _ref$initFn;

    _classCallCheck(this, Uu5String);

    this._factory = arguments[1] && arguments[1]._factory || defaultFactory;
    this.templateDataMap = templateDataMap;
    this.initFn = initFn;
    /*
      Transform content of Uu5String into React components. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change tag and props used for rendering into components. Function is called for each descendant Uu5StringObject before creation of React component. This function cannot change data of Uu5StringObjects.
      @returns array of React components
      */

    this.toChildren = function () {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$templateDataMap = _ref2.templateDataMap,
          templateDataMap = _ref2$templateDataMap === void 0 ? _this.templateDataMap || {} : _ref2$templateDataMap,
          _ref2$uu5DataMap = _ref2.uu5DataMap,
          uu5DataMap = _ref2$uu5DataMap === void 0 ? initialUu5DataMap : _ref2$uu5DataMap,
          filterFn = _ref2.filterFn,
          buildChildFn = _ref2.buildChildFn;

      return Uu5StringTools.contentToChildren(_this.content, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
    };
    /*
      Transform content into string. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
      @returns string
    */


    this.toString = function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$templateDataMap = _ref3.templateDataMap,
          templateDataMap = _ref3$templateDataMap === void 0 ? _this.templateDataMap || null : _ref3$templateDataMap,
          filterFn = _ref3.filterFn;

      return Uu5StringTools.contentToString(_this.content, templateDataMap, filterFn);
    };
    /*
      Transform content into plain text. Returned string will not contain tags, but only text from their props. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - map with data for Uu5String templates
      @param filterFn({uu5Tag, props}) - function to change props used for printing into plain text. Function is called for each descendant Uu5StringObject before print props into plain text.
      @returns string
    */


    this.toPlainText = function () {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$templateDataMap = _ref4.templateDataMap,
          templateDataMap = _ref4$templateDataMap === void 0 ? _this.templateDataMap || {} : _ref4$templateDataMap,
          _ref4$uu5DataMap = _ref4.uu5DataMap,
          uu5DataMap = _ref4$uu5DataMap === void 0 ? initialUu5DataMap : _ref4$uu5DataMap,
          filterFn = _ref4.filterFn;

      return Uu5StringTools.contentToPlainText(_this.content, templateDataMap, uu5DataMap, filterFn);
    };
    /*
      Returns new instance of Uu5String. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
       @param opts.templateDataMap - data for Uu5StringTemplates
      @returns Uu5String instance.
    */


    this.clone = function () {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$templateDataMap = _ref5.templateDataMap,
          templateDataMap = _ref5$templateDataMap === void 0 ? _this.templateDataMap : _ref5$templateDataMap,
          _ref5$uu5DataMap = _ref5.uu5DataMap,
          uu5DataMap = _ref5$uu5DataMap === void 0 ? initialUu5DataMap : _ref5$uu5DataMap,
          _ref5$initFn = _ref5.initFn,
          initFn = _ref5$initFn === void 0 ? _this.initFn : _ref5$initFn;

      var result = _this._factory.createString(null, {
        templateDataMap: templateDataMap,
        uu5DataMap: uu5DataMap
      });

      if (!_this.content) return result;
      result.content = _this.content.map(function (item) {
        return typeof item === "string" ? item : item.clone({
          initFn: initFn
        });
      });
      return result;
    }; // constructor logic


    var buildItemFn = function buildItemFn(uu5Tag, props, opts) {
      return Uu5StringObject.create(uu5Tag, props, _objectSpread(_objectSpread({}, opts), {}, {
        initFn: initFn,
        uu5DataMap: initialUu5DataMap,
        allowedTagsRegExp: allowedTagsRegExp,
        _factory: _this._factory
      }));
    };

    this.content = !uu5string || typeof uu5string === "string" ? Uu5String.parse(uu5string, {
      buildItemFn: buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp: allowedTagsRegExp
    }) : Uu5String.parseTagPropsArray(Array.isArray(uu5string) ? uu5string : [uu5string], {
      buildItemFn: buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp: allowedTagsRegExp
    });
  }
  /* static functions */


  _createClass(Uu5String, null, [{
    key: "parse",
    value: function parse(uu5string) {
      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          buildItemFn = _ref6.buildItemFn,
          uu5DataMap = _ref6.uu5DataMap,
          allowedTagsRegExp = _ref6.allowedTagsRegExp;

      if (buildItemFn === undefined) {
        var _factory = arguments[1] && arguments[1]._factory || defaultFactory;

        buildItemFn = function buildItemFn(uu5Tag, propsString, opts) {
          return Uu5StringObject.create(uu5Tag, propsString, _objectSpread(_objectSpread({}, opts), {}, {
            _factory: _factory
          }));
        };
      }

      return Uu5StringTools.parseUu5String(uu5string, buildItemFn, uu5DataMap, allowedTagsRegExp);
    }
  }, {
    key: "parseTagPropsArray",
    value: function parseTagPropsArray(uu5object) {
      var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          buildItemFn = _ref7.buildItemFn,
          uu5DataMap = _ref7.uu5DataMap,
          allowedTagsRegExp = _ref7.allowedTagsRegExp;

      if (buildItemFn === undefined) {
        var _factory = arguments[1] && arguments[1]._factory || defaultFactory;

        buildItemFn = function buildItemFn(uu5Tag, props, opts) {
          return Uu5StringObject.create(uu5Tag, props, _objectSpread(_objectSpread({}, opts), {}, {
            _factory: _factory
          }));
        };
      }

      return Uu5StringTools.parseTagPropsArray(uu5object, buildItemFn, uu5DataMap, allowedTagsRegExp);
    }
  }, {
    key: "isValid",
    value: function isValid(uu5string) {
      return Uu5StringTools.isValidUu5String(uu5string);
    }
  }, {
    key: "toChildren",
    value: function toChildren(uu5string) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          templateDataMap = _ref8.templateDataMap,
          uu5DataMap = _ref8.uu5DataMap,
          filterFn = _ref8.filterFn,
          buildChildFn = _ref8.buildChildFn,
          allowedTagsRegExp = _ref8.allowedTagsRegExp;

      var _factory = arguments[1] && arguments[1]._factory || defaultFactory;

      return _factory.createString(uu5string, {
        allowedTagsRegExp: allowedTagsRegExp
      }).toChildren({
        templateDataMap: templateDataMap,
        uu5DataMap: uu5DataMap,
        filterFn: filterFn,
        buildChildFn: buildChildFn
      });
    }
  }, {
    key: "toString",
    value: function toString(uu5string) {
      var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          templateDataMap = _ref9.templateDataMap,
          filterFn = _ref9.filterFn,
          allowedTagsRegExp = _ref9.allowedTagsRegExp;

      var _factory = arguments[1] && arguments[1]._factory || defaultFactory;

      return _factory.createString(uu5string, {
        allowedTagsRegExp: allowedTagsRegExp
      }).toString({
        templateDataMap: templateDataMap,
        filterFn: filterFn
      });
    }
  }, {
    key: "toPlainText",
    value: function toPlainText(uu5string) {
      var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          templateDataMap = _ref10.templateDataMap,
          uu5DataMap = _ref10.uu5DataMap,
          filterFn = _ref10.filterFn,
          allowedTagsRegExp = _ref10.allowedTagsRegExp;

      var _factory = arguments[1] && arguments[1]._factory || defaultFactory;

      return _factory.createString(uu5string, {
        allowedTagsRegExp: allowedTagsRegExp
      }).toPlainText({
        templateDataMap: templateDataMap,
        uu5DataMap: uu5DataMap,
        filterFn: filterFn
      });
    }
  }, {
    key: "contentToChildren",
    value: function contentToChildren(content) {
      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          templateDataMap = _ref11.templateDataMap,
          uu5DataMap = _ref11.uu5DataMap,
          filterFn = _ref11.filterFn,
          buildChildFn = _ref11.buildChildFn;

      return Uu5StringTools.contentToChildren(content, templateDataMap, uu5DataMap, filterFn, buildChildFn);
    }
  }, {
    key: "contentToString",
    value: function contentToString(content) {
      var _ref12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          templateDataMap = _ref12.templateDataMap,
          filterFn = _ref12.filterFn;

      return Uu5StringTools.contentToString(content, templateDataMap, filterFn);
    }
  }, {
    key: "contentToPlainText",
    value: function contentToPlainText(content) {
      var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          templateDataMap = _ref13.templateDataMap,
          uu5DataMap = _ref13.uu5DataMap,
          filterFn = _ref13.filterFn;

      return Uu5StringTools.contentToPlainText(content, templateDataMap, uu5DataMap, filterFn);
    }
  }]);

  return Uu5String;
}();

Uu5String.Props = Uu5StringProps;
Uu5String.Object = Uu5StringObject;
Uu5String.REGEXP = {
  uu5string: REGEXP.uu5string,
  uu5json: REGEXP.uu5json,
  uu5data: REGEXP.uu5data
};
Object.defineProperties(Uu5String, {
  // "private" for uu5g04
  _textEntityMap: {
    get: function get() {
      return __webpack_require__(9);
    }
  }
});
defaultFactory.init(Uu5String, Uu5StringObject, Uu5StringProps);
module.exports = Uu5String;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var SYMBOLS = __webpack_require__(6);

var _require = __webpack_require__(8),
    TAG = _require.TAG,
    TEMPLATE_REG_EXP = _require.TEMPLATE_REG_EXP,
    UU5STRING_REGEXP = _require.UU5STRING_REGEXP,
    ATTR_REGEXP = _require.ATTR_REGEXP,
    ATTR_VALUE_TYPE_REGEXP = _require.ATTR_VALUE_TYPE_REGEXP,
    UU5DATA_REGEXP = _require.UU5DATA_REGEXP,
    JSCODE_REGEXP = _require.JSCODE_REGEXP,
    DEFAULT_SEPARATOR = _require.DEFAULT_SEPARATOR,
    DEFAULT_BOUNDARIES = _require.DEFAULT_BOUNDARIES,
    DEFAULT_VALUE_DELIMITER = _require.DEFAULT_VALUE_DELIMITER,
    FORBIDDEN_TAGS_REGEXP = _require.FORBIDDEN_TAGS_REGEXP,
    FORBIDDEN_ATTRS_REGEXP = _require.FORBIDDEN_ATTRS_REGEXP,
    UU5JSON_REGEXP = _require.UU5JSON_REGEXP;

var TextEntityMap = __webpack_require__(9);

var Uu5Data = __webpack_require__(10);

var Uu5Json = __webpack_require__(11);

var Tools = {
  /*
    Transform content into React components.
     @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for rendering into components. Function is called for each descendant Uu5StringObject before creation of React component. This function cannot change data of Uu5StringObjects.
    @returns array of React components
   */
  contentToChildren: function contentToChildren(content, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp) {
    if (!content || !content.length) {
      return null;
    }

    return content.map(function (item, index) {
      return typeof item === "string" ? Tools.printTemplateToChildren(TextEntityMap.replace(item), templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp) : Tools._contentWithKeyToChildren(item, index, templateDataMap, uu5DataMap, filterFn, buildChildFn);
    });
  },
  // render all children with stable key derivated from child index
  _contentWithKeyToChildren: function _contentWithKeyToChildren(item, index, templateDataMap, uu5DataMap, filterFn, buildChildFn) {
    // let props = item.props.clone();
    // let original = item.props;
    var props = item.props.toObject({
      uu5DataMap: uu5DataMap
    });

    if (!props.key) {
      item.props.props.push({
        name: "key",
        value: props.id || "uu5string-child_".concat(index)
      });
    } // item.props = props;


    var result = item.toChildren({
      templateDataMap: templateDataMap,
      uu5DataMap: uu5DataMap,
      filterFn: filterFn,
      buildChildFn: buildChildFn
    }); // item.props = original;

    if (!props.key) {
      item.props.props.pop();
    }

    return result;
  },

  /*
    Transform content into string.
     @param content - array of Uu5StringObjects, strings, numbers, booleans and Uu5StringTemplates
    @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant Uu5StringObject before print into string. This function cannot change data of Uu5StringObjects.
    @returns string
  */
  contentToString: function contentToString(content, templateDataMap, filterFn) {
    if (!content || !content.length) {
      return "";
    }

    if (typeof content === "string") {
      return Tools.printTemplateToString(content, templateDataMap);
    }

    var result = "";
    content.forEach(function (item) {
      return result += typeof item === "string" ? Tools.printTemplateToString(item, templateDataMap) : item.toString({
        templateDataMap: templateDataMap,
        filterFn: filterFn
      });
    });
    return result;
  },

  /*
    Transform content into plain text. Returned string will not contain tags, but only text from their props. If parameter templateDataMap is undefined, templateDataMap passed into constructor will be used instead.
     @param templateDataMap - map with data for Uu5String templates
    @param filterFn({uu5Tag, props}) - function to change props used for printing into plain text. Function is called for each descendant Uu5StringObject before print props into plain text.
    @returns string
  */
  contentToPlainText: function contentToPlainText(content, templateDataMap, uu5DataMap, filterFn) {
    if (!content || !content.length) {
      return "";
    }

    if (typeof content === "string") {
      return Tools.printTemplateToString(content, templateDataMap);
    }

    var result = "";
    content.forEach(function (item) {
      result += (result ? " " : "") + (typeof item === "string" ? Tools.printTemplateToString(item, templateDataMap) : item.toPlainText({
        templateDataMap: templateDataMap,
        uu5DataMap: uu5DataMap,
        filterFn: filterFn
      }));
    });
    return result.replace(/\s+/g, " ").trim();
  },
  printTemplateToString: function printTemplateToString(string, templateDataMap) {
    if (!templateDataMap) {
      return string;
    }

    var result = Tools._printTemplate(string, templateDataMap);

    return result.length === 1 ? result[0] : result.join("");
  },
  printTemplateToChildren: function printTemplateToChildren(string, templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp) {
    if (!templateDataMap) {
      return string;
    }

    var isChildren;

    var result = Tools._printTemplate(string, templateDataMap, function (matchValue) {
      var result = matchValue;
      var exact = false;

      if (typeof matchValue === "string" && matchValue.match(UU5STRING_REGEXP) && Tools.isValidUu5String(matchValue)) {
        isChildren = true; // create component by buildChildFn (e.g. UU5.Common.Tools.findComponent)

        result = Tools.parseUu5String(matchValue, Tools._buildChildItem.bind(Tools, buildChildFn), uu5DataMap, allowedTagsRegExp);
      } else if (typeof matchValue === "string" && matchValue.match(UU5JSON_REGEXP)) {
        try {
          result = Uu5Json.parse(matchValue);
          exact = true;
        } catch (e) {// ignore (result will be matchValue)
        }
      }

      return {
        value: result,
        exact: exact
      };
    }); // result contains parsed Uu5String - return array


    if (isChildren) return result;
    return result.length === 1 ? result[0] : result.join("");
  },
  buildChild: function buildChild(buildChildFn, uu5Tag, props, children) {
    var result;

    if (typeof buildChildFn === "function") {
      result = buildChildFn(uu5Tag, props, children);
    } else {
      result = {
        uu5Tag: uu5Tag,
        tag: uu5Tag,
        props: props,
        children: children
      };
    }

    return result;
  },
  _buildChildItem: function _buildChildItem(buildChildFn, uu5Tag, propsString) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        children = _ref.children,
        uu5DataMap = _ref.uu5DataMap,
        allowedTagsRegExp = _ref.allowedTagsRegExp;

    if (!uu5Tag) return children;
    var propsArray = propsString ? Tools.parseUu5StringProps(propsString, Tools._buildChildItem.bind(Tools, buildChildFn), uu5DataMap, allowedTagsRegExp) : [];
    var props = {};
    propsArray.forEach(function (item) {
      return props[item.name] = item.value;
    });
    return Tools.buildChild(buildChildFn, uu5Tag, props, children);
  },
  _printTemplate: function _printTemplate(string, templateDataMap, matchHandler) {
    // check if string is single template - in this case return template result ( posible another type then string )
    // let isTemplate = string.match(CHECK_IS_TEMPLATE);
    var useMatchHandler = typeof matchHandler === "function";
    var result = [];
    var templateRegExp = new RegExp(TEMPLATE_REG_EXP); // must be new instance (regexp-s mutate their .lastIndex in successive .exec() calls and we don't want it to be remembered for another uu5string / for matchHandler call)

    var templateMatch = templateRegExp.exec(string);
    var startIndex = 0;
    var endIndex = 0;
    /*
    template[1] - name
    template[2] - default value prefixed by :
    template[3] - default value
    */

    while (templateMatch) {
      var templateName = templateMatch[1];
      var value = void 0;
      endIndex = templateRegExp.lastIndex - templateMatch[0].length;

      if (endIndex > startIndex) {
        result.push(string.substring(startIndex, endIndex));
      }

      startIndex = templateRegExp.lastIndex;

      if (templateDataMap[templateName]) {
        // check data
        var template = templateDataMap[templateName];
        value = typeof template === "function" ? template(templateMatch[3]) : template;
      } else if (SYMBOLS[templateName]) {
        // check symbols
        var _template = SYMBOLS[templateName];
        value = typeof _template === "function" ? _template(templateMatch[3]) : _template;
      } else {
        // replace template by default value or empty string
        value = templateMatch[3] === undefined ? templateMatch[0] : templateMatch[3];
      }

      if (useMatchHandler) {
        var _matchHandler = matchHandler(value),
            matchResult = _matchHandler.value,
            exact = _matchHandler.exact;

        if (exact) {
          result.push(matchResult);
        } else if (Array.isArray(matchResult)) {
          matchResult.forEach(function (item) {
            return result.push(item);
          });
        } else {
          result.push(matchResult);
        }
      } else {
        result.push(value);
      }

      templateMatch = templateRegExp.exec(string);
    } // add string after end of last match


    if (startIndex < string.length) {
      result.push(string.substring(startIndex));
    }

    return result;
  },
  isValidUu5String: function isValidUu5String(uu5string) {
    if (typeof uu5string !== "string") return false;

    try {
      Tools.parseUu5String(uu5string);
      return true;
    } catch (e) {
      return false;
    }
  },
  parseUu5String: function parseUu5String(uu5string, buildItemFn, uu5DataMap, allowedTagsRegExp) {
    if (!uu5string || typeof uu5string !== "string" || uu5string.length === 0) {
      return [];
    }

    uu5string = uu5string.trim().replace(/\r\n/g, "\n");
    var childStack = [{
      uu5Tag: "_root",
      children: [],
      index: 0
    }];
    var pointer = childStack[0];
    var cIndex = -1;
    var pIndex = 0;
    var pre = false;
    var preTag = "";
    var matchS;
    var matchUu5String = uu5string.match(UU5STRING_REGEXP);

    if (matchUu5String) {
      // !!!!! Never put uu5stringRe to constants, otherwise it gets stuck - because of exec method on regexp
      // groups: comp name, attrs, -, -, -, self-closing, closing tag comp name, content upto next tag
      var tagRe = new RegExp(TAG, "g");
      pIndex = tagRe.lastIndex = matchUu5String[0].length;
      matchS = tagRe.exec(uu5string);

      while (matchS) {
        cIndex = matchS.index;

        if (cIndex > pIndex) {
          var head = uu5string.substring(pIndex, cIndex);
          var text = head; // let text = pre ? TextEntityMap.replaceHtmlEntity(head) : TextEntityMap.replace(head);

          pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
            children: text,
            uu5DataMap: uu5DataMap,
            allowedTagsRegExp: allowedTagsRegExp
          }) : text);
          Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
        }

        var childTag = matchS[1] || matchS[9];
        var attrs = matchS[2];
        var isClosing = !!matchS[9];
        var isSelfClosing = !!matchS[8];
        var tagObj = void 0;

        if (pre && !(childTag === preTag && isClosing) || childTag && childTag.match(FORBIDDEN_TAGS_REGEXP)) {
          var _text = matchS[0]; // let text = TextEntityMap.replaceHtmlEntity(matchS[0]);

          pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
            children: _text,
            uu5DataMap: uu5DataMap,
            allowedTagsRegExp: allowedTagsRegExp
          }) : _text);
          Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
        } else {
          if (isClosing) {
            //closing tag
            tagObj = childStack.pop();

            if (tagObj.uu5Tag !== childTag) {
              var err = new Error("Invalid uu5string: Tag ".concat(tagObj.uu5Tag, " at position ").concat(tagObj.index, " is not closed."));
              err.code = "uu5StringInvalid";
              err.context = {
                uu5string: uu5string,
                uu5Tag: tagObj.uu5Tag,
                tag: tagObj.uu5Tag,
                index: tagObj.index
              };
              throw err;
            }

            pointer = childStack[childStack.length - 1];

            if (pre) {
              pre = false;

              var _text2 = tagObj.children.join(""); // let text = TextEntityMap.replaceHtmlEntity(tagObj.children.join(''));


              pointer.children[pointer.children.length - 1] = typeof buildItemFn === "function" ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                children: _text2,
                uu5DataMap: uu5DataMap,
                allowedTagsRegExp: allowedTagsRegExp
              }) : _text2;
              Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
            } else {
              if (tagObj.forbidden) {
                tagObj.children = "Error: Tag <".concat(tagObj.uu5Tag, " /> is not allowed.");
                tagObj.attrs = " uu5Tag=\"".concat(tagObj.uu5Tag, "\" tag=\"").concat(tagObj.uu5Tag, "\"");
                tagObj.uu5Tag = tagObj.tag = "invalidTag";
              }

              pointer.children[pointer.children.length - 1] = typeof buildItemFn === "function" ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                children: tagObj.children,
                isPairedTag: true,
                uu5DataMap: uu5DataMap,
                allowedTagsRegExp: allowedTagsRegExp
              }) : tagObj;
              Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
            }
          } else {
            // prevent parsing json inside uu5json
            pre = childTag === "uu5string.pre" || childTag === "uu5json";
            preTag = childTag;
            tagObj = {
              uu5Tag: childTag,
              children: [],
              index: matchS.index
            };

            if (allowedTagsRegExp && !allowedTagsRegExp.test(childTag)) {
              tagObj.forbidden = true;
            } else if (attrs) {
              tagObj.attrs = attrs;
            }

            if (isSelfClosing) {
              //self-closing tag
              pre = false;

              if (childTag.indexOf("uu5string.") === 0) {
                //meta-tag uu5string.*
                var s = Tools.execMetaTag(childTag, tagObj.attrs);

                if (s) {
                  s.forEach(function (item) {
                    pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
                      children: item,
                      uu5DataMap: uu5DataMap,
                      allowedTagsRegExp: allowedTagsRegExp
                    }) : item);
                    Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
                  });
                }
              } else {
                if (tagObj.forbidden) {
                  tagObj.children = "Error: Tag <".concat(tagObj.uu5Tag, " /> is not allowed.");
                  tagObj.attrs = " uu5Tag=\"".concat(tagObj.uu5Tag, "\" tag=\"").concat(tagObj.uu5Tag, "\"");
                  tagObj.uu5Tag = tagObj.tag = "invalidTag";
                }

                pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(tagObj.uu5Tag, tagObj.attrs, {
                  children: tagObj.children,
                  isPairedTag: false,
                  uu5DataMap: uu5DataMap,
                  allowedTagsRegExp: allowedTagsRegExp
                }) : tagObj);
                Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1], tagObj.uu5Tag);
              }
            } else {
              //common tag
              pointer.children.push(tagObj);
              childStack.push(tagObj);
              pointer = tagObj;
            }
          }
        }

        pIndex = cIndex + matchS[0].length;
        matchS = tagRe.exec(uu5string);
      } // handle ending text


      if (pIndex < uu5string.length) {
        var _text3 = uu5string.substr(pIndex); // text = pre ? TextEntityMap.replaceHtmlEntity(text) : TextEntityMap.replace(text);


        pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
          children: _text3,
          uu5DataMap: uu5DataMap,
          allowedTagsRegExp: allowedTagsRegExp
        }) : _text3);
        Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
      }

      if (childStack.length > 1) {
        var _tagObj = childStack.pop();

        var _err = new Error("Invalid uu5string: Tag ".concat(_tagObj.uu5Tag, " at position ").concat(_tagObj.index, " is not closed."));

        _err.code = "uu5StringInvalid";
        _err.context = {
          uu5string: uu5string,
          uu5Tag: _tagObj.uu5Tag,
          tag: _tagObj.uu5Tag,
          index: _tagObj.index
        };
        throw _err;
      }
    } else {
      pointer.children.push(typeof buildItemFn === "function" ? buildItemFn(null, null, {
        children: uu5string,
        uu5DataMap: uu5DataMap,
        allowedTagsRegExp: allowedTagsRegExp
      }) : uu5string);
      Tools.syncUu5TagAfterApiCall(pointer.children[pointer.children.length - 1]);
    }

    return pointer.children;
  },
  parseUu5StringProps: function parseUu5StringProps(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp) {
    var attrs = []; // group1 = separator
    // group2 = attribute name
    // group3 = name and value separator
    // group4 = attribute value
    // group5 = indication that attribute value is not wrapped into quotes / single quotes

    var attrsReg = new RegExp(ATTR_REGEXP.source, "g");
    var matchAttrs = attrsReg.exec(attrsString);

    while (matchAttrs) {
      var separator = matchAttrs[1];
      var name = matchAttrs[2];
      var valueDelimiter = matchAttrs[3];
      var valueBoundaries = "";
      var value = true;
      var uu5DataKey = undefined;
      var valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json

      var matchValue = matchAttrs[4];
      var isUnquoted = !!matchAttrs[5];

      if (!name.match(FORBIDDEN_ATTRS_REGEXP)) {
        if (isUnquoted) {
          if (matchValue === "true") {
            //true
            value = true;
          } else if (matchValue === "false") {
            //false
            value = false;
          } else if (isFinite(matchValue)) {
            //number
            value = +matchValue;
          } else {
            //any other -> null | undefined
            value = matchValue === "undefined" ? undefined : null;
          }
        } else if (matchValue != null) {
          // unescape quoted value
          if (matchValue[0] === "'") {
            valueBoundaries = "'";
            matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\'])/g, "$1");
          } else if (matchValue[0] === '"') {
            valueBoundaries = '"';
            matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\"])/g, "$1");
          }

          var matchValueType = matchValue.match(ATTR_VALUE_TYPE_REGEXP);

          if (matchValueType[1]) {
            //uu5JSON
            valueType = "uu5json";

            try {
              value = Uu5Json.parse(matchValue);
            } catch (e) {
              e.context.prop = name;
              throw e;
            }
          } else if (matchValueType[2]) {
            //uu5String
            valueType = "uu5string";
            value = Tools.parseUu5String(matchValue, buildItemFn, uu5DataMap, allowedTagsRegExp);
          } else if (matchValueType[3]) {
            //uu5Data
            valueType = "uu5data";
            uu5DataKey = matchValue.replace(UU5DATA_REGEXP, "");
            value = Uu5Data.parse(matchValue, uu5DataMap);
          } else {
            //as-is
            if (name === "href") {
              matchValue = matchValue.replace(JSCODE_REGEXP, "");
            }

            value = matchValue;
          }
        }

        attrs.push({
          name: name,
          value: value,
          valueDelimiter: valueDelimiter,
          separator: separator,
          valueBoundaries: valueBoundaries,
          valueType: valueType,
          uu5DataKey: uu5DataKey
        });
      }

      matchAttrs = attrsReg.exec(attrsString);
    }

    return attrs;
  },
  parseUu5StringPropsObject: function parseUu5StringPropsObject(attrsObject, buildItem, uu5DataMap, allowedTagsRegExp) {
    var attrs = [];

    for (var attr in attrsObject) {
      var separator = DEFAULT_SEPARATOR;
      var name = attr;
      var attrValue = attrsObject[attr];
      var valueDelimiter = DEFAULT_VALUE_DELIMITER;
      var valueBoundaries = DEFAULT_BOUNDARIES;
      var value = null;
      var uu5DataKey = undefined;
      var valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json

      if (name && !name.match(FORBIDDEN_ATTRS_REGEXP)) {
        if (typeof attrValue === "string") {
          var matchValueType = attrValue.match(ATTR_VALUE_TYPE_REGEXP);

          if (matchValueType[1]) {
            //uu5JSON
            valueType = "uu5json";

            try {
              value = Uu5Json.parse(attrValue);
            } catch (e) {
              e.context.prop = name;
              throw e;
            }
          } else if (matchValueType[2]) {
            //uu5String
            valueType = "uu5string";
            value = Tools.parseUu5String(attrValue, buildItem, uu5DataMap, allowedTagsRegExp);
          } else if (matchValueType[3]) {
            //uu5Data
            valueType = "uu5data";
            uu5DataKey = attrValue.replace(UU5DATA_REGEXP, "");
            value = Uu5Data.parse(attrValue, uu5DataMap);
          } else {
            //as-is
            if (name === "href") {
              value = attrValue.replace(JSCODE_REGEXP, "");
            } else {
              value = attrValue;
            }
          }
        } else if (attrValue && _typeof(attrValue) === "object" && (attrValue.uu5Tag || attrValue.tag)) {
          value = [this.parseTagPropsObject(attrValue, buildItem, uu5DataMap, allowedTagsRegExp)];
        } else if (Array.isArray(attrValue)) {
          value = this.parseTagPropsArray(attrValue, buildItem, uu5DataMap, allowedTagsRegExp);
        } else {
          value = attrValue;
        }

        attrs.push({
          name: name,
          value: value,
          valueDelimiter: valueDelimiter,
          separator: separator,
          valueBoundaries: valueBoundaries,
          valueType: valueType,
          uu5DataKey: uu5DataKey
        });
      }
    }

    return attrs;
  },
  parseTagPropsArray: function parseTagPropsArray(tagPropsArray, buildItem, uu5DataMap, allowedTagsRegExp) {
    var _this = this;

    if (!tagPropsArray || !Array.isArray(tagPropsArray) || !tagPropsArray.length) {
      return [];
    }

    return tagPropsArray.map(function (item) {
      return _this.parseTagPropsObject(item, buildItem, uu5DataMap, allowedTagsRegExp);
    });
  },
  parseTagPropsObject: function parseTagPropsObject(tagPropsObject, buildItem, uu5DataMap, allowedTagsRegExp) {
    if (!tagPropsObject) return null;
    if (!tagPropsObject || !tagPropsObject.uu5Tag && !tagPropsObject.tag) return tagPropsObject;
    var uu5Tag = tagPropsObject.uu5Tag || tagPropsObject.tag;

    if (uu5Tag && uu5Tag.match(FORBIDDEN_TAGS_REGEXP)) {
      var result = buildItem(null, null, {
        children: "<".concat(uu5Tag, " />"),
        uu5DataMap: uu5DataMap,
        allowedTagsRegExp: allowedTagsRegExp
      });
      return result;
    }

    if (allowedTagsRegExp && !allowedTagsRegExp.test(uu5Tag)) {
      var _result = buildItem("invalidTag", " uu5Tag=\"".concat(uu5Tag, "\" tag=\"").concat(uu5Tag, "\""), {
        children: "Error: Tag <".concat(uu5Tag, " /> is not allowed."),
        uu5DataMap: uu5DataMap,
        isPairedTag: false,
        allowedTagsRegExp: allowedTagsRegExp
      });

      Tools.syncUu5TagAfterApiCall(_result, "invalidTag");
      return _result;
    }

    var children = this.parseTagPropsArray(tagPropsObject.children, buildItem, uu5DataMap, allowedTagsRegExp);
    return buildItem(uu5Tag, tagPropsObject.props, {
      children: children,
      uu5DataMap: uu5DataMap,
      allowedTagsRegExp: allowedTagsRegExp,
      isPairedTag: !!(children && children.length)
    });
  },
  execMetaTag: function execMetaTag(tag, args) {
    //TODO implement each metaTag as separate function, call functions dynamically (witch safety keyword guard)
    var metaTag = tag.slice(10);
    var r = [];

    switch (metaTag) {
      case "now":
        r.push(SYMBOLS.now());
        break;

      case "codeHex32":
        r.push(SYMBOLS.idHex32());
        break;

      case "codeHex64":
        r.push(SYMBOLS.idHex64());
        break;

      default:
        r.push(null);
    }

    return r;
  },
  syncUu5TagAfterApiCall: function syncUu5TagAfterApiCall(tagObj, origUu5Tag) {
    // for backward compatibility - "older" API methods (filterFn, buildItemFn, ...) could change
    // "tag" instead of "uu5Tag" field => use the changed "tag" in such case, otherwise prefer "uu5Tag"
    if (!tagObj || _typeof(tagObj) !== "object") return;

    if (!tagObj.uu5Tag || tagObj.uu5Tag !== tagObj.tag && tagObj.uu5Tag === origUu5Tag && tagObj.tag) {
      tagObj.uu5Tag = tagObj.tag;
    } else {
      tagObj.tag = tagObj.uu5Tag;
    }
  },
  isAllowedTagAndAttrCombination: function isAllowedTagAndAttrCombination(tag, attrName, attrValue) {
    if (tag === "UU5.Bricks.Iframe") {
      if (attrName === "srcDoc") return false; // NOTE Even "src" gets sometimes internally used as "srcDoc" => forbid if it contains "<".

      if (attrName === "src" && attrValue && (typeof attrValue !== "string" || !attrValue.match(/^https?:\/\/[^<]*$/))) {
        return false;
      }
    } else if (tag === "Plus4U5.Bricks.Iframe") {
      if (attrName === "src" && attrValue) {
        if (typeof attrValue !== "string" || attrValue.match(/</)) return false;

        if (typeof document !== "undefined" && typeof window !== "undefined") {
          var a = document.createElement("a");
          a.href = attrValue; // browser normalizes

          var normalizedUrl = a.href;
          var legacyEnv = (window.UU5 || {}).Environment || {};
          var trustedDomainRegExpStr = (window.uu5Environment || {}).uu5g05_trustedUriRegExp || legacyEnv.trustedDomainRegexp || "^";
          var trustedDomainRegExp = new RegExp(trustedDomainRegExpStr, "i");
          var curBase = window.location.protocol + "//" + window.location.host + "/";
          if (!normalizedUrl.match(trustedDomainRegExp) && !normalizedUrl.startsWith(curBase)) return false;
        }
      }
    }

    return true;
  },
  escapeEntities: function escapeEntities(text) {
    if (typeof text !== "string") return text; // TODO Maybe unescape emojis too.
    // NOTE TextEntityMap doesn't have unescaping mechanism and it contains
    // multiple mappings to the same character, e.g. &lt; and &#060; are both mapped to ">".

    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
};
module.exports = Tools;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var Tools = __webpack_require__(7);

var SYMBOLS = {
  now: function now() {
    var date = new Date(Date.now());
    return date.toISOString();
  },
  idHex32: function idHex32(defValue) {
    return defValue || Tools.generateId(32);
  },
  idHex64: function idHex64(defValue) {
    return defValue || Tools.generateId(64);
  }
};
module.exports = SYMBOLS;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

var REGEXP_XY = /[xy]/g;
var Tools = {};
Tools.REGEXP = {
  uu5string: /^\s*<uu5string\s*\/>/,
  uu5stringTemplate: /\$\{([0-9a-zA-Z.\-_]+)\s*(:\s*([0-9a-zA-Z.\-_ ()\[\]<>\\\/]+))?\}/,
  uu5json: /^\s*<uu5json\s*\/>/,
  uu5data: /^\s*<uu5data\s*\/>/,
  jsCode: /^(javascript:\s*)*/i
};

Tools.generateId = function (length) {
  length = Math.max(length, 8);
  var uuidCore = "x4xxxyxx";
  var additionalCharLength = length - uuidCore.length;

  for (var i = 0; i < additionalCharLength; ++i) {
    if (i % 2 === 0) uuidCore = uuidCore + "x";else uuidCore = "x" + uuidCore;
  }

  return uuidCore.replace(REGEXP_XY, function (char) {
    var r = Math.random() * 16 % 16 | 0;
    return (char === "x" ? r : r & 0x3 | 0x8).toString(16);
  });
};

module.exports = Tools;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var _templateObject, _templateObject2, _templateObject3, _templateObject4;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var _require = __webpack_require__(7),
    REGEXP = _require.REGEXP;

var UU5STRING_REGEXP = REGEXP.uu5string;
var UU5JSON_REGEXP = REGEXP.uu5json;
var UU5DATA_REGEXP = REGEXP.uu5data;
var JSCODE_REGEXP = REGEXP.jsCode;
var FORBIDDEN_TAGS_REGEXP = /^(applet|base|body|embed|form|frame|frameset|iframe|head|html|link|meta|noframes|object|script|template)$/i;
var FORBIDDEN_ATTRS_REGEXP = /^(dangerouslySetInnerHTML)$/i;
var COMPONENT_NAME = String.raw(_templateObject || (_templateObject = _taggedTemplateLiteral(["[-w.]+"], ["[-\\w.]+"])));
var ATTR = String.raw(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["(s+)([-w]+)(?:(s*=s*)(\"(?:\\.|[^\"\\])*\"|'(?:\\.|[^'\\])*'|([^\"'>s/][^>s/]*)))?"], ["(\\s+)([-\\w]+)(?:(\\s*=\\s*)(\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|([^\"'>\\s/][^>\\s/]*)))?"]))); // groups: attr separator, attr name, value separator, attr value, indication whether without quotes

var TAG = String.raw(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<(", ")((?:", ")*)s*(/)?>|</(", ")>"], ["<(", ")((?:", ")*)\\s*(/)?>|</(", ")>"])), COMPONENT_NAME, ATTR, COMPONENT_NAME); // groups: comp name, attrs, -, -, -, self-closing, closing tag

var ATTR_REGEXP = new RegExp(ATTR); // groups: see ATTR

var ATTR_VALUE_TYPE_REGEXP = new RegExp(String.raw(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["(", ")|(", ")|(", ")|"])), REGEXP.uu5json.source, REGEXP.uu5string.source, REGEXP.uu5data.source)); // groups: uu5json, uu5string, uu5data

var TEMPLATE_REG_EXP = new RegExp(REGEXP.uu5stringTemplate.source, "g");
var CHECK_IS_TEMPLATE = new RegExp("^".concat(REGEXP.uu5stringTemplate.source, "$"));
var DEFAULT_SEPARATOR = " ";
var DEFAULT_BOUNDARIES = '"';
var DEFAULT_VALUE_DELIMITER = "=";
module.exports = {
  UU5STRING_REGEXP: UU5STRING_REGEXP,
  UU5JSON_REGEXP: UU5JSON_REGEXP,
  UU5DATA_REGEXP: UU5DATA_REGEXP,
  JSCODE_REGEXP: JSCODE_REGEXP,
  FORBIDDEN_TAGS_REGEXP: FORBIDDEN_TAGS_REGEXP,
  FORBIDDEN_ATTRS_REGEXP: FORBIDDEN_ATTRS_REGEXP,
  COMPONENT_NAME: COMPONENT_NAME,
  ATTR: ATTR,
  TAG: TAG,
  ATTR_REGEXP: ATTR_REGEXP,
  ATTR_VALUE_TYPE_REGEXP: ATTR_VALUE_TYPE_REGEXP,
  TEMPLATE_REG_EXP: TEMPLATE_REG_EXP,
  CHECK_IS_TEMPLATE: CHECK_IS_TEMPLATE,
  DEFAULT_SEPARATOR: DEFAULT_SEPARATOR,
  DEFAULT_BOUNDARIES: DEFAULT_BOUNDARIES,
  DEFAULT_VALUE_DELIMITER: DEFAULT_VALUE_DELIMITER
};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var HtmlEntityMap = {
  re: /(&#?[a-z0-9]+;)/g,
  items: {
    "&amp;": "&",
    "&#38;": "&",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&lt;": "<",
    "&#060;": "<",
    "&gt;": ">",
    "&#062;": ">",
    "&hellip;": "…",
    "&#133;": "…",
    "&mdash;": "—",
    "&#8212;": "—",
    "&pi;": "π",
    "&#8719;": "π",
    "&reg;": "®",
    "&#174;": "®",
    "&#8730;": "√",
    "&radic;": "√",
    "&#8734;": "∞",
    "&infin;": "∞",
    "&#160;": " ",
    "&nbsp;": " ",
    "&#8592;": "←",
    "&larr;": "←",
    "&#8594;": "→",
    "&rarr;": "→",
    "&#8595;": "?",
    "&darr;": "?",
    "&#169;": "©",
    "&copy;": "©",
    "&trade;": "™",
    "&pound;": "£",
    "&euro;": "€",
    "&prod;": "∏",
    "&sum;": "∑",
    "&int;": "∫",
    "&le;": "≤",
    "&ge;": "≥",
    "&#92;": "\\",
    "&sup2;": "²",
    "&sup3;": "³"
  }
};
var AsciiEmojiMap = {
  //:) :D :O :* :( :| :S :Z :$ :P :/   ;-)     :'-(   ,:-(   ,:-)   O:-)       8-) X-)    :-")  :'-)        :,'-(          ";-(   ]:-)   <3
  re: /(:-[)(DOo*|$SsZzP/@]|;-\)|:[',]-\(|,:-\(|,:-\)|[0oO]:-\)|[B8Xx]-\)|:-"\)|:[',]-[)D]|:(?:,'|',)-\(|";-\(|]:-\)|<\/?3)/g,
  items: {
    ":-)": "😃",
    ";-)": "😉",
    ":-(": "😦",
    ":'-(": "😢",
    ":,-(": "😢",
    ":-D": "😄",
    ":-o": "😮",
    ":-O": "😮",
    ":-*": "😘",
    ",:-(": "😓",
    ",:-)": "😅",
    "0:-)": "😇",
    "O:-)": "😇",
    "o:-)": "😇",
    "8-)": "😎",
    "B-)": "😎",
    ':-")': "😊",
    ":-$": "😒",
    ":'-)": "😂",
    ":'-D": "😂",
    ":,-)": "😂",
    ":,-D": "😂",
    ":,'-(": "😭",
    '";-(': "😭",
    ":-/": "😕",
    ":-@": "😡",
    ":-P": "😛",
    ":-S": "😒",
    ":-Z": "😒",
    ":-s": "😒",
    ":-z": "😒",
    ":-|": "😐",
    "]:-)": "😈",
    "X-)": "😆",
    "x-)": "😆",
    "</3": "💔",
    "<3": "💗"
  }
};
var ExtendedEmojiMap = {
  re: /#\(([a-z\-]+)\)/g,
  items: {
    baby: "👶",
    boy: "👦",
    girl: "👧",
    man: "👨",
    woman: "👩",
    "old-man": "👴",
    "old-woman": "👵",
    cow: "🐄",
    horse: "🐎",
    tiger: "🐅",
    elephant: "🐘",
    "unicorn-face": "🦄",
    pig: "🐖",
    "pig-face": "🐷",
    "pig-nose": "🐽",
    rat: "🐀",
    mouse: "🐁",
    "hamster-face": "🐹",
    bat: "🦇",
    chicken: "🐔",
    dolphin: "🐬",
    fish: "🐟",
    crocodile: "🐊",
    snake: "🐍",
    whale: "🐋",
    octopus: "🐙",
    spider: "🕷",
    "panda-face": "🐼",
    "bear-face": "🐻",
    boar: "🐗",
    dog: "🐕",
    "dog-face": "🐶",
    cat: "🐈",
    "cat-face": "🐱",
    snail: "🐌",
    butterfly: "🦋",
    ant: "🐜",
    fire: "🔥",
    "skull-with-crossbones": "☠",
    bomb: "💣",
    "light-bulb": "💡",
    hammer: "🔨",
    wrench: "🔧",
    key: "🔑",
    gear: "⚙",
    coffin: "⚰",
    moai: "🗿",
    beer: "🍺",
    volcano: "🌋",
    "pile-of-poo": "💩",
    shit: "💩",
    "broken-heart": "💔",
    heart: "❤️",
    love: "💘",
    alien: "👽",
    "robot-face": "🤖",
    skull: "💀",
    ghost: "👻",
    cloud: "☁",
    "thumbs-up": "👍",
    "thumbs-down": "👎",
    "index-finger": "☝️",
    "sign-of-the-horns": "🤘",
    "vulcan-salute": "🖖",
    "clapping-hands": "👏",
    handshake: "🤝",
    "ok-hand": "👌",
    "raised-hand": "✋",
    "five-finger-hand": "🖐",
    "middle-finger": "🖕",
    "raised-fist": "✊",
    "victory-hand": "✌",
    "crossed-fingers": "🤞",
    "writing-hand": "✍️",
    kiss: "💋",
    anchor: "⚓",
    airplane: "✈",
    sailboat: "⛵",
    car: "🚗",
    truck: "🚚",
    train: "🚆",
    tractor: "🚜",
    ship: "🚢",
    rocket: "🚀",
    helicopter: "🚁",
    ball: "⚽",
    czechia: "🇨🇿",
    "united-states": "🇺🇸",
    germany: "🇩🇪",
    ukraine: "🇺🇦",
    slovakia: "🇸🇰",
    netherlands: "🇳🇱",
    spain: "🇪🇸",
    "united-kingdom": "🇬🇧",
    croatia: "🇭🇷",
    "skin-light": "🏻",
    "skin-medium-light": "🏼",
    "skin-medium": "🏽",
    "skin-medium-dark": "🏾",
    "skin-dark": "🏿"
  }
};
var TextEntityMap = {
  _re: null,
  _htmlEntity: true,

  get htmlEntity() {
    return this._htmlEntity;
  },

  set htmlEntity(s) {
    if (s !== this._htmlEntity) {
      this._htmlEntity = s;
      this.recompile();
    }
  },

  _htmlEntityMap: HtmlEntityMap,
  replaceHtmlEntity: function replaceHtmlEntity(text) {
    var _this = this;

    var reg = new RegExp("(\\\\)?".concat(this._htmlEntityMap.re.source), "g");
    if (this.htmlEntity) text = text.replace(reg, function (m0, m1, m2) {
      return m1 ? m2 : _this._htmlEntityMap.items[m2] || m2;
    });
    return text;
  },
  _asciiEmoji: true,

  get asciiEmoji() {
    return this._asciiEmoji;
  },

  set asciiEmoji(s) {
    if (s !== this.asciiEmoji) {
      this._asciiEmoji = s;
      this.recompile();
    }
  },

  _asciiEmojiMap: AsciiEmojiMap,
  replaceAsciiEmoji: function replaceAsciiEmoji(text) {
    var _this2 = this;

    var reg = new RegExp("(\\\\)?".concat(this._asciiEmojiMap.re.source), "g");
    if (this.asciiEmoji) text = text.replace(reg, function (m0, m1, m2) {
      return m1 ? m2 : _this2._asciiEmojiMap.items[m2] || m2;
    });
    return text;
  },
  _extendedTextEntity: true,

  get extendedTextEntity() {
    return this._extendedTextEntity;
  },

  set extendedTextEntity(s) {
    if (s !== this._extendedTextEntity) {
      this._extendedTextEntity = s;
      this.recompile();
    }
  },

  _extendedTextEntityMapList: [ExtendedEmojiMap],
  _textEntityRegexGroups: {},
  replace: function replace(text) {
    var eteg = this._textEntityRegexGroups;
    var count = this._reGroupsCount;
    return text.replace(this._re, function (match, esc) {
      var r = match;
      if (esc) r = match.slice(1);else {
        for (var _len = arguments.length, groups = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          groups[_key - 2] = arguments[_key];
        }

        for (var i = 0; i < count; i++) {
          if (groups[i]) {
            r = eteg[i].items[groups[i]] || r;
            break;
          }
        }
      }
      return r;
    });
  },
  addExtendedTextEntityMap: function addExtendedTextEntityMap(map) {
    if (!this._extendedTextEntityMapList.some(function (item) {
      return item === map;
    })) this._extendedTextEntityMapList.push(map);
  },
  removeExtendedTextEntityMap: function removeExtendedTextEntityMap(map) {
    this._extendedTextEntityMapList = this._extendedTextEntityMapList.filter(function (item) {
      return item !== map;
    });
  },

  get extendedTextEntityMapList() {
    return this._extendedTextEntityMapList;
  },

  recompile: function recompile() {
    var _this3 = this;

    if (this.htmlEntity || this.asciiEmoji || this.extendedTextEntity) {
      var reA = [];
      var i = 0;
      this._textEntityRegexGroups = {};

      if (this.htmlEntity) {
        reA.push(this._htmlEntityMap.re.source);
        this._textEntityRegexGroups[i] = this._htmlEntityMap;
        i++;
      }

      if (this.asciiEmoji) {
        reA.push(this._asciiEmojiMap.re.source);
        this._textEntityRegexGroups[i] = this._asciiEmojiMap;
        i++;
      }

      if (this.extendedTextEntity) {
        this._extendedTextEntityMapList.forEach(function (item) {
          reA.push(item.re.source);
          _this3._textEntityRegexGroups[i] = item;
          i++;
        });
      }

      this._reGroupsCount = i;
      this._re = new RegExp("(\\\\)?(?:".concat(reA.join("|"), ")"), "g");
    } else this._re = null;
  }
}; //precompile regex

TextEntityMap.recompile();
module.exports = TextEntityMap;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var _require = __webpack_require__(8),
    UU5DATA_REGEXP = _require.UU5DATA_REGEXP;

var Uu5Data = /*#__PURE__*/function () {
  function Uu5Data() {
    _classCallCheck(this, Uu5Data);
  }

  _createClass(Uu5Data, null, [{
    key: "parse",
    value: function parse(uu5Data, uu5DataMap) {
      uu5Data = uu5Data.replace(UU5DATA_REGEXP, "");
      var parts = uu5Data.split(".");
      var data = uu5DataMap;

      while (data != null && parts.length > 0) {
        data = data[parts.shift()];
      }

      if (_typeof(data) === undefined && typeof self === "undefined") {
        console.warn("There is no component data in uu5DataMap for uu5Data: ".concat(uu5Data, " !"), {
          uu5Data: uu5Data
        });
      }

      return data;
    }
  }]);

  return Uu5Data;
}();

module.exports = Uu5Data;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var UU5_JSON_REGEXP = /^\s*<uu5json\s*\/>/;

var Uu5Json = /*#__PURE__*/function () {
  function Uu5Json(json) {
    _classCallCheck(this, Uu5Json);

    this._uu5json = json;
    this._object = Uu5Json.parse(json);
  }

  _createClass(Uu5Json, [{
    key: "toUu5Json",
    value: function toUu5Json() {
      return this._uu5json;
    }
  }, {
    key: "toJson",
    value: function toJson() {
      return this._uu5json;
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return this._object;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Uu5Json(this._uu5json);
    }
  }], [{
    key: "parse",
    value: function parse(uu5Json) {
      uu5Json = Uu5Json.toJson(uu5Json);
      var value = null;

      try {
        value = JSON.parse(uu5Json);
      } catch (err) {
        err.code = "uu5JsonInvalid";
        err.context = {
          json: uu5Json
        };
        throw err;
      }

      return value;
    }
  }, {
    key: "toJson",
    value: function toJson(uu5Json) {
      return uu5Json.replace(UU5_JSON_REGEXP, "");
    }
  }]);

  return Uu5Json;
}();

module.exports = Uu5Json;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var TextEntityMap = __webpack_require__(9);

var Uu5StringTools = __webpack_require__(5);

var defaultFactory = __webpack_require__(13);

var _require = __webpack_require__(8),
    FORBIDDEN_ATTRS_REGEXP = _require.FORBIDDEN_ATTRS_REGEXP;

var defaultPlainTextFilterFn = function defaultPlainTextFilterFn(_ref) {
  var uu5Tag = _ref.uu5Tag,
      tag = _ref.tag,
      props = _ref.props;
  tag = uu5Tag = uu5Tag || tag;

  if (props) {
    var result = {
      tag: tag,
      uu5Tag: uu5Tag,
      props: {}
    };

    if (props.header) {
      result.props.header = props.header;
    }

    if (props.uu5string) {
      result.props.uu5string = props.uu5string;
    }

    if (props.content || props.children) {
      result.props.children = props.content || props.children;
    }

    if (props.footer) {
      result.props.footer = props.footer;
    }

    return result;
  }
};

var Uu5StringObject = /*#__PURE__*/function () {
  /* constructor */
  function Uu5StringObject(uu5Tag, props) {
    var _this = this;

    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$children = _ref2.children,
        children = _ref2$children === void 0 ? [] : _ref2$children,
        _ref2$isPairedTag = _ref2.isPairedTag,
        isPairedTag = _ref2$isPairedTag === void 0 ? true : _ref2$isPairedTag,
        _ref2$initFn = _ref2.initFn,
        initFn = _ref2$initFn === void 0 ? null : _ref2$initFn,
        _ref2$parent = _ref2.parent,
        parent = _ref2$parent === void 0 ? null : _ref2$parent,
        initialUu5DataMap = _ref2.uu5DataMap,
        allowedTagsRegExp = _ref2.allowedTagsRegExp;

    _classCallCheck(this, Uu5StringObject);

    this._factory = arguments[2] && arguments[2]._factory || defaultFactory;
    /* public methods */

    /*
    Returns Uu5StringObject as a string
     @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a string
    */

    this.toString = function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          templateDataMap = _ref3.templateDataMap,
          filterFn = _ref3.filterFn;

      if (_this.uu5Tag === "uu5string.pre") {
        return "<uu5string.pre>".concat(_this.children.join(""), "</uu5string.pre>");
      } // let children = this.children;


      var children = _toConsumableArray(_this.children);

      var propsChildren = [];
      var filteredProps = [];

      for (var pi = 0; pi < _this.props.props.length; pi++) {
        var prop = _this.props.props[pi];

        if (prop.childrenProperty) {
          propsChildren.push(prop);
        } else {
          filteredProps.push(prop);
        }
      } // sort props children by index from lowest


      propsChildren.sort(function (child1, child2) {
        return child2.index - child1.index;
      });

      for (var _pi = 0; _pi < propsChildren.length; _pi++) {
        var _prop = propsChildren[_pi];

        var uu5stringObject = _this._factory.createObject(undefined, undefined, {
          allowedTagsRegExp: allowedTagsRegExp
        });

        uu5stringObject.uu5Tag = _prop.valueType === "string" ? "uu5string" : _prop.valueType;
        uu5stringObject.children = _prop.valueType === "uu5json" ? [Uu5StringTools.printTemplateToString(JSON.stringify(_prop.value, undefined, 2), templateDataMap)] : Uu5StringTools.contentToString(_prop.value, templateDataMap, filterFn);
        uu5stringObject.props.props.push({
          name: "propName",
          value: _prop.name,
          type: "string"
        }); // add item back into its original place - if index is larger then count of children, then we push it at the end of array

        if (_prop.index < children.length) {
          //insert back formating spaces
          if (_prop.spacesBefore) {
            children.splice(_prop.index, 0, _prop.spacesBefore, uu5stringObject);
          } else {
            children.splice(_prop.index, 0, uu5stringObject);
          }
        } else {
          //insert back formating spaces
          if (_prop.spacesBefore) {
            children.push(_prop.spacesBefore);
          }

          children.push(uu5stringObject);
        }
      } // use filteredProps for rest of the algorithm and then return back original props


      var originalProps = _this.props.props;
      _this.props.props = filteredProps;
      var uu5Tag = _this.uu5Tag;
      var result;

      if (filterFn) {
        var obj = {
          uu5Tag: uu5Tag,
          tag: uu5Tag,
          props: _this.props.toObject()
        };
        obj.props.children = children.slice(); // filter result by obj

        var _result = _this._filterProps(obj, filterFn); // check if filter returns false => do not render component


        if (_result === false) {
          return "";
        }

        var resultTag = _result.resultTag,
            resultProps = _result.resultProps;
        uu5Tag = resultTag; // remove children from props

        resultProps = resultProps.filter(function (item) {
          if (item.name === "children") {
            children = item.value;
            return false;
          }

          return true;
        });
        var propsArray = _this.props.props;
        _this.props.props = resultProps; // print filtered props

        result = "<".concat(uu5Tag).concat(_this.props.toString({
          templateDataMap: templateDataMap,
          filterFn: filterFn
        })); // return original props

        _this.props.props = propsArray;
      } else {
        result = "<".concat(uu5Tag).concat(_this.props.toString({
          templateDataMap: templateDataMap
        }));
      } // render children - children from props content was rendered with props


      if (_this._isPairTag(children)) {
        result += ">".concat(Uu5StringTools.contentToString(children, templateDataMap, filterFn), "</").concat(uu5Tag, ">");
      } else {
        result += "/>";
      } // return original props


      _this.props.props = originalProps;
      return result;
    };
    /*
    Returns Uu5StringObject as a plain text
     @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a string
    */


    this.toPlainText = function () {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          templateDataMap = _ref4.templateDataMap,
          uu5DataMap = _ref4.uu5DataMap,
          filterFn = _ref4.filterFn;

      if (_this.uu5Tag === "uu5string.pre") {
        return "".concat(_this.children.join(""));
      }

      var children = _this.children; // there is no need to special handling of props parsed from children

      var propsArray = _toConsumableArray(_this.props.props);

      var originalProps = _this.props.props; // add children into props

      if (children) {
        propsArray.push({
          name: "children",
          value: children.slice(),
          valueType: "uu5string"
        });
      }

      var result; // update filter function - use default if is not set other wise add default filter function as an another parameter into filterFn

      var modifiedFilterFn = defaultPlainTextFilterFn;

      if (filterFn) {
        modifiedFilterFn = function modifiedFilterFn() {
          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
          }

          return filterFn.apply(void 0, params.concat([defaultPlainTextFilterFn]));
        };
      } // handle props with children


      _this.props.props = propsArray;
      var uu5Tag = _this.uu5Tag;
      var obj = {
        uu5Tag: uu5Tag,
        tag: uu5Tag,
        props: _this.props.toObject({
          uu5DataMap: uu5DataMap
        })
      }; // filter result by obj

      var _result = _this._filterProps(obj, modifiedFilterFn, true); // check if filter returns false => do not render component


      if (_result === false) {
        return "";
      }

      _this.props.props = _result.resultProps; // print filtered props

      result = "".concat(_this.props.toPlainText({
        templateDataMap: templateDataMap,
        uu5DataMap: uu5DataMap,
        filterFn: filterFn
      })); // return original props

      _this.props.props = originalProps;
      return result;
    };
    /*
    Returns Uu5StringObject as a hierarchy of react component
     @param opts.templateDataMap - object with data for templates
    @param filterFn({uu5Tag, props}) - returns changed tag and props, if it returns false skip print of this component and its children - this method cannot change data of this component only change them for print
    @returns Uu5StringObject as a React component
    */


    this.toChildren = function () {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          templateDataMap = _ref5.templateDataMap,
          _ref5$uu5DataMap = _ref5.uu5DataMap,
          uu5DataMap = _ref5$uu5DataMap === void 0 ? initialUu5DataMap : _ref5$uu5DataMap,
          filterFn = _ref5.filterFn,
          buildChildFn = _ref5.buildChildFn;

      if (_this.uu5Tag === "uu5string.pre") {
        return _this.children.map(function (it) {
          if (typeof it === "string") return TextEntityMap.replaceHtmlEntity(it);
          return it;
        });
      }

      var result;
      var children = _this.children;
      var uu5Tag = _this.uu5Tag;

      if (filterFn) {
        // create shallow copy of component
        var obj = {
          uu5Tag: uu5Tag,
          tag: uu5Tag,
          props: _this.props.toObject({
            uu5DataMap: uu5DataMap
          })
        };
        obj.props.children = _this.children.slice(); // filter result by obj

        var _result = _this._filterProps(obj, filterFn); // check if filter returns false => do not render component


        if (_result === false) {
          return null;
        }

        var resultTag = _result.resultTag,
            resultProps = _result.resultProps; // remove children from props

        resultProps = resultProps.filter(function (item) {
          if (item.name === "children") {
            children = item.value;
            return false;
          }

          return true;
        });
        var propsArray = _this.props.props;
        _this.props.props = resultProps; // process filtered props

        result = {
          uu5Tag: resultTag,
          tag: resultTag,
          props: _this.props.toChildren({
            templateDataMap: templateDataMap,
            uu5DataMap: uu5DataMap,
            filterFn: filterFn,
            buildChildFn: buildChildFn
          })
        }; // return original props

        _this.props.props = propsArray;
      } else {
        result = {
          uu5Tag: uu5Tag,
          tag: uu5Tag,
          props: _this.props.toChildren({
            templateDataMap: templateDataMap,
            uu5DataMap: uu5DataMap,
            undefined: undefined,
            buildChildFn: buildChildFn
          })
        };
      }

      var usedChildren = Uu5StringTools.contentToChildren(children, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
      var returnValue = Uu5StringTools.buildChild(buildChildFn, result.uu5Tag, result.props, usedChildren);
      return returnValue;
    };
    /*
    Deep clone of this component.
     @returns new instance of Uu5StringObject
    */


    this.clone = function () {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$initFn = _ref6.initFn,
          initFn = _ref6$initFn === void 0 ? _this.initFn : _ref6$initFn;

      // filter props by filter function
      var uu5Tag = _this.uu5Tag;
      var result = {
        uu5Tag: uu5Tag,
        tag: uu5Tag,
        props: _this.props.clone({
          initFn: initFn
        })
      }; // clone children at first

      result.children = _this.children.map(function (item) {
        return typeof item === "string" ? item : item.clone({
          initFn: initFn
        });
      }); // create new object - props are already cloned so do not send them into constructor

      var newUu5StringObject = _this._factory.createObject(result.uu5Tag, null, {
        children: result.children,
        isPairedTag: _this._isPairTag(),
        initFn: initFn,
        allowedTagsRegExp: allowedTagsRegExp
      });

      newUu5StringObject.props = result.props;
      return newUu5StringObject;
    };
    /*
    Returns index of this component in the parent. If component does not have parent returns -1.
     @returns number
    */


    this.getIndex = function () {
      return _this.parent ? _this.parent.children.indexOf(_this) : -1;
    };
    /* private methods */


    this._initContent = function () {
      // set parent to children
      if (_this.children && Array.isArray(_this.children)) {
        _this.children.forEach(function (item) {
          if (item && _typeof(item) === "object") item.parent = _this;
        });
      }

      if (_this.props && _this.props.props) {
        var content = _this.props.props.find(function (item) {
          return item.name === "content";
        });

        if (content && Array.isArray(content.value)) {
          content.value.forEach(function (item) {
            if (item && _typeof(item) === "object") item.parent = _this;
          });
        }
      }
    };

    this._filterProps = function (propsObj, filterFn, preserveObjectOrder) {
      var uu5TagOrig = propsObj ? propsObj.uu5Tag : undefined;
      var tagOrig = propsObj ? propsObj.tag : undefined;
      var filterObj = filterFn(propsObj);
      if (filterObj === false) return false;
      var uu5Tag = uu5TagOrig || tagOrig;

      if (filterObj) {
        propsObj = filterObj;
        Uu5StringTools.syncUu5TagAfterApiCall(propsObj, uu5TagOrig);
        uu5Tag = propsObj.uu5Tag;
      } // some props values may be false or undefined - for filtering we need to have some value evaluated as a true


      var filteredProps = {};
      var counter = 1;

      for (var propName in propsObj.props) {
        filteredProps[propName] = counter++;
      } // filter result by obj


      var propsArray = _this.props.props.filter(function (prop) {
        return filteredProps[prop.name];
      });

      if (preserveObjectOrder) {
        propsArray.sort(function (prop1, prop2) {
          return filteredProps[prop1.name] - filteredProps[prop2.name];
        });
      } // update values


      var _loop = function _loop(_propName) {
        var prop = propsArray.find(function (item) {
          return item.name === _propName;
        });

        if (prop) {
          // update value
          prop.value = propsObj.props[_propName];
        } else {
          // add new props
          propsArray.push({
            name: _propName,
            value: propsObj.props[_propName]
          });
        }
      };

      for (var _propName in propsObj.props) {
        _loop(_propName);
      }

      return {
        resultTag: uu5Tag,
        resultProps: propsArray
      };
    };

    this._isPairTag = function () {
      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.children;
      var isPairTag = children.length > 0 || _this._pairTag;
      _this._pairTag = isPairTag;
      return _this._pairTag;
    }; // constructor logic


    this.uu5Tag = uu5Tag;
    Object.defineProperty(this, "tag", {
      get: function get() {
        return _this.uu5Tag;
      },
      set: function set(v) {
        return _this.uu5Tag = v;
      },
      enumerable: true
    });
    this.props = this._factory.createProps(props, {
      buildItemFn: function buildItemFn(uu5Tag, props, opts) {
        return Uu5StringObject.create(uu5Tag, props, _objectSpread(_objectSpread({}, opts), {}, {
          initFn: initFn,
          uu5DataMap: initialUu5DataMap,
          allowedTagsRegExp: allowedTagsRegExp,
          _factory: _this._factory
        }));
      },
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp: allowedTagsRegExp
    });
    this.parent = parent;
    this.children = [];

    if (!isPairedTag && children.length === 0) {
      var childPropIndex = this.props.props.findIndex(function (it) {
        return it.name === "children";
      });

      if (childPropIndex !== -1) {
        var value = this.props.props[childPropIndex].value;
        this.children = value == null ? [] : Array.isArray(value) ? value : typeof value === "string" ? [Uu5StringTools.escapeEntities(value)] // <b children="<hello>" />    =>   <b>&lt;hello&gt;</b>
        : [value];
        this.props.props.splice(childPropIndex, 1);
      }
    }

    if (typeof children === "string") {
      this.children.push(children);
    } else {
      // filter props set inside children from children and add them into children
      var childProps = {};
      children.forEach(function (child, index) {
        var childTag = child.uu5Tag || child.tag;

        if (childTag === "uu5string" || childTag === "uu5json") {
          // find property propName
          var propName = child.props.props.find(function (prop) {
            return prop.name === "propName";
          });

          if (propName) {
            childProps[propName.value] = {
              child: child,
              index: index
            };

            if (index > 0 && typeof children[index - 1] === "string" && children[index - 1].match(/^\s+$/)) {
              // remove spaces from array oof children
              childProps[propName.value].spacesBefore = _this.children.pop(); // lower index of component

              childProps[propName.value].index--;
            }

            if (childTag === "uu5json") {
              child.children = JSON.parse(child.children);
            } else if (child.children.length === 1 && typeof child.children[0] === "string") {
              child.children = child.children[0];
              child.uu5Tag = child.tag = "string";
            }
          } else {
            _this.children.push(child);
          }
        } else {
          _this.children.push(child);
        }
      }); // iterate over all props and update already existing props by the ones from children

      for (var pi = 0; pi < this.props.props.length; pi++) {
        var prop = this.props.props[pi];

        if (childProps[prop.name] !== undefined) {
          prop.value = childProps[prop.name].child.children;
          prop.type = childProps[prop.name].child.uu5Tag || childProps[prop.name].child.tag;
          prop.childrenProperty = true;
          prop.index = childProps[prop.name].index;
          prop.spacesBefore = childProps[prop.name].spacesBefore;
          delete childProps[prop.name];
        }
      } // add new props for rest of props children


      for (var propName in childProps) {
        this.props.props.push({
          name: propName,
          value: childProps[propName].child.children,
          valueType: childProps[propName].child.uu5Tag || childProps[propName].child.tag,
          childrenProperty: true,
          index: childProps[propName].index,
          spacesBefore: childProps[propName].spacesBefore
        });
      }
    } // remove all forbidden props


    for (var _pi2 = this.props.props.length - 1; _pi2 >= 0; _pi2--) {
      var _prop2 = this.props.props[_pi2];

      if (_prop2.name.match(FORBIDDEN_ATTRS_REGEXP) || !Uu5StringTools.isAllowedTagAndAttrCombination(this.uu5Tag, _prop2.name, _prop2.value)) {
        console.warn("Provided value is not allowed in uu5string for '".concat(this.uu5Tag, "' prop '").concat(_prop2.name, "': ").concat(_prop2.value));
        this.props.props.splice(_pi2, 1);
      }
    } // this.children = (typeof children === "string" ? [children] : children) || [];


    this.initFn = initFn;
    this._pairTag = isPairedTag;

    this._initContent(); // use filter function to let user update component tag and props


    if (typeof initFn === "function") {
      initFn(this);
    }
  }
  /* static methods */


  _createClass(Uu5StringObject, null, [{
    key: "create",
    value: function create(uu5Tag, props) {
      var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          children = _ref7.children,
          isPairedTag = _ref7.isPairedTag,
          initFn = _ref7.initFn,
          parent = _ref7.parent,
          uu5DataMap = _ref7.uu5DataMap,
          allowedTagsRegExp = _ref7.allowedTagsRegExp;

      if (!uu5Tag) return children;

      var _factory = arguments[2] && arguments[2]._factory || defaultFactory;

      return _factory.createObject(uu5Tag, props, {
        children: children,
        isPairedTag: isPairedTag,
        initFn: initFn,
        parent: parent,
        uu5DataMap: uu5DataMap,
        allowedTagsRegExp: allowedTagsRegExp
      });
    }
  }]);

  return Uu5StringObject;
}();

module.exports = Uu5StringObject;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Uu5String;
var Uu5StringObject;
var Uu5StringProps; // NOTE This serves as classes factory. uu5g04 uses its own (because g04 uses different method APIs
// for Uu5String, Uu5StringObject and Uu5StringProps). The factory is injected into classes via options
// (_factory field) where needed.
// If uu5g04 is no longer supported, this can be removed together with _factory fields.

module.exports = /*#__PURE__*/function () {
  function Factory() {
    _classCallCheck(this, Factory);
  }

  _createClass(Factory, null, [{
    key: "init",
    value: function init(Uu5String0, Uu5StringObject0, Uu5StringProps0) {
      // initializes variables (prevents cyclic dependencies); should be called on 1st use
      Uu5String = Uu5String0;
      Uu5StringObject = Uu5StringObject0;
      Uu5StringProps = Uu5StringProps0;
    }
  }, {
    key: "createString",
    value: function createString() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _construct(Uu5String, args);
    }
  }, {
    key: "createObject",
    value: function createObject() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _construct(Uu5StringObject, args);
    }
  }, {
    key: "createProps",
    value: function createProps() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _construct(Uu5StringProps, args);
    }
  }]);

  return Factory;
}();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (C) 2019 Unicorn a.s.
 *
 * This program is free software; you can use it under the terms of the UAF Open License v01 or
 * any later version. The text of the license is available in the file LICENSE or at www.unicorn.com.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See LICENSE for more details.
 *
 * You may contact Unicorn a.s. at address: V Kapslovne 2767/2, Praha 3, Czech Republic or
 * at the email: info@unicorn.com.
 */
var Uu5StringTools = __webpack_require__(5);

var Uu5Data = __webpack_require__(10);

var Uu5StringObject = __webpack_require__(12);

var defaultFactory = __webpack_require__(13);

var _require = __webpack_require__(8),
    DEFAULT_SEPARATOR = _require.DEFAULT_SEPARATOR,
    DEFAULT_BOUNDARIES = _require.DEFAULT_BOUNDARIES,
    DEFAULT_VALUE_DELIMITER = _require.DEFAULT_VALUE_DELIMITER;

var Uu5StringProps = /*#__PURE__*/function () {
  /* constructor */
  function Uu5StringProps(props) {
    var _this = this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        buildItemFn = _ref.buildItemFn,
        initialUu5DataMap = _ref.uu5DataMap,
        allowedTagsRegExp = _ref.allowedTagsRegExp;

    _classCallCheck(this, Uu5StringProps);

    this._factory = arguments[1] && arguments[1]._factory || defaultFactory;
    /* public methods */

    /*
      Returns props as an array of objects {name, value, separator}.
       @returns array
    */

    this.toArray = function () {
      return _this.props;
    };
    /*
      Returns props as a map of name: value
       @returns object
    */


    this.toObject = function () {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$uu5DataMap = _ref2.uu5DataMap,
          uu5DataMap = _ref2$uu5DataMap === void 0 ? initialUu5DataMap : _ref2$uu5DataMap;

      var result = {};

      _this.props.forEach(function (item) {
        var value = item.value;
        if (item.valueType === "uu5data") value = Uu5Data.parse("<uu5data/>" + item.uu5DataKey, uu5DataMap);
        result[item.name] = value;
      });

      return result;
    };

    this.toChildren = function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          templateDataMap = _ref3.templateDataMap,
          _ref3$uu5DataMap = _ref3.uu5DataMap,
          uu5DataMap = _ref3$uu5DataMap === void 0 ? initialUu5DataMap : _ref3$uu5DataMap,
          filterFn = _ref3.filterFn,
          buildChildFn = _ref3.buildChildFn;

      var result = {};

      _this.props.forEach(function (item) {
        return result[item.name] = Uu5StringProps._renderItemValueToChildren(item, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
      });

      return result;
    };
    /*
      Returns props as a string with separators.
       @returns string
    */


    this.toString = function () {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          templateDataMap = _ref4.templateDataMap,
          filterFn = _ref4.filterFn;

      var result = "";

      _this.props.forEach(function (item) {
        if (item.value !== undefined || item.valueType === "uu5data") {
          result += "".concat(item.separator || DEFAULT_SEPARATOR).concat(item.name).concat(Uu5StringProps._renderItemValueToString(item, templateDataMap, filterFn));
        }
      });

      result += _this.lastSeparator;
      return result;
    };
    /*
      Returns props as a string with separators.
       @returns string
    */


    this.toPlainText = function () {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          templateDataMap = _ref5.templateDataMap,
          uu5DataMap = _ref5.uu5DataMap,
          filterFn = _ref5.filterFn;

      var result = [];

      _this.props.forEach(function (item) {
        result.push(Uu5StringProps._renderItemValueToPlainText(item, templateDataMap, uu5DataMap, filterFn));
      });

      return result.join(" ");
    };

    this.clone = function () {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          initFn = _ref6.initFn;

      var newPropsObject = _this._factory.createProps(undefined, {
        allowedTagsRegExp: allowedTagsRegExp
      }); // set last separator


      newPropsObject.lastSeparator = _this.lastSeparator; // set all props as a new array

      newPropsObject.props = _this.props.map(function (item) {
        var newItem = {}; // clone all attributes

        for (var attr in item) {
          newItem[attr] = item[attr];
        } // clone object in value attribute - other attributes has only string values


        if (newItem.value) {
          var isArray = Array.isArray(newItem.value);
          var value = (isArray ? newItem.value : [newItem.value]).map(function (valueItem) {
            if (_typeof(valueItem) === "object") {
              // instead of: valueItem instanceof Uu5StringObject
              if (typeof valueItem.clone === "function") {
                return valueItem.clone({
                  initFn: initFn
                });
              } else {
                return _objectSpread({}, valueItem); // clone object
              }
            } // return other values


            return valueItem;
          });
          newItem.value = isArray ? value : value[0];
        }

        return newItem;
      });
      return newPropsObject;
    }; // constructor logic
    // parse props string into array of props - each prop have its name, value and separator - props are ordered by its order in string


    this.props = props ? typeof props === "string" ? Uu5StringProps.parse(props, {
      buildItemFn: buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp: allowedTagsRegExp
    }) : Uu5StringProps.parseObject(props, {
      buildItemFn: buildItemFn,
      uu5DataMap: initialUu5DataMap,
      allowedTagsRegExp: allowedTagsRegExp
    }) : [];
    this.lastSeparator = props && typeof props === "string" ? props.match(/\s*$/)[0] : "";
  }
  /* static methods */


  _createClass(Uu5StringProps, null, [{
    key: "parse",
    value: function parse(attrsString) {
      var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          buildItemFn = _ref7.buildItemFn,
          uu5DataMap = _ref7.uu5DataMap,
          allowedTagsRegExp = _ref7.allowedTagsRegExp;

      return Uu5StringTools.parseUu5StringProps(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp);
    }
  }, {
    key: "parseObject",
    value: function parseObject(attrsString) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          buildItemFn = _ref8.buildItemFn,
          uu5DataMap = _ref8.uu5DataMap,
          allowedTagsRegExp = _ref8.allowedTagsRegExp;

      return Uu5StringTools.parseUu5StringPropsObject(attrsString, buildItemFn, uu5DataMap, allowedTagsRegExp);
    }
    /* private static methods */

  }, {
    key: "_renderItemValueToString",
    value: function _renderItemValueToString(item, templateDataMap, filterFn) {
      if (!item.valueDelimiter && item.value === true) return "";
      var result;

      if (item.valueType === "uu5string") {
        result = "<uu5string/>" + Uu5StringTools.contentToString(item.value, templateDataMap, filterFn);
      } else if (item.valueType === "uu5json") {
        result = "<uu5json/>" + Uu5StringTools.printTemplateToString(JSON.stringify(item.value, undefined, 2), templateDataMap);
      } else if (item.valueType === "uu5data") {
        result = "<uu5data/>" + item.uu5DataKey;
      } else if (typeof item.value === "string") {
        result = Uu5StringTools.printTemplateToString(item.value, templateDataMap);
      } else if (item.value && _typeof(item.value) === "object") {
        // same as uu5json
        if (Array.isArray(item.value) && item.value.some(function (elem) {
          return elem instanceof Uu5StringObject;
        })) {
          result = "<uu5string/>";
          item.value.forEach(function (elem) {
            return result += elem.toString({
              templateDataMap: templateDataMap,
              filterFn: filterFn
            });
          });
        } else {
          result = "<uu5json/>" + Uu5StringTools.printTemplateToString(JSON.stringify(item.value, undefined, 2), templateDataMap);
        }
      } else if (item.value !== true) {
        result = item.value;
      } // escape boundaries in prop value


      var boundaries = "";

      if (typeof result === "string") {
        if (item.valueBoundaries === undefined) {
          boundaries = DEFAULT_BOUNDARIES;
        } else if (item.valueBoundaries) {
          boundaries = item.valueBoundaries;
        } // escape content


        if (boundaries === "'") {
          result = result.replace(/([\\'])/g, "\\$1");
        } else if (boundaries === '"') {
          result = result.replace(/([\\"])/g, "\\$1");
        }
      }

      return result === undefined ? "" : "".concat(item.valueDelimiter || DEFAULT_VALUE_DELIMITER).concat(boundaries).concat(result).concat(boundaries);
    }
    /* private static methods */

  }, {
    key: "_renderItemValueToPlainText",
    value: function _renderItemValueToPlainText(item, templateDataMap, uu5DataMap, filterFn) {
      if (typeof item.value === "boolean") return "";
      var result;

      if (item.valueType === "uu5string") {
        result = Uu5StringTools.contentToPlainText(item.value, templateDataMap, uu5DataMap, filterFn);
      } else if (item.valueType === "uu5json") {
        result = JSON.stringify(item.value, undefined, 2);
      } else if (typeof item.value === "string") {
        result = Uu5StringTools.printTemplateToString(item.value, templateDataMap);
      } else {
        result = item.value + "";
      }

      return result;
    }
  }, {
    key: "_renderItemValueToChildren",
    value: function _renderItemValueToChildren(item, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp) {
      if (item.valueType === "uu5string") {
        return Uu5StringTools.contentToChildren(item.value, templateDataMap, uu5DataMap, filterFn, buildChildFn, allowedTagsRegExp);
      } else if (item.valueType === "uu5json") {
        return item.value ? JSON.parse(Uu5StringTools.printTemplateToString(JSON.stringify(item.value), templateDataMap)) : {};
      } else if (item.valueType === "uu5data") {
        item.value = Uu5Data.parse("<uu5data/>" + item.uu5DataKey, uu5DataMap);
        return item.value;
      }

      return typeof item.value === "string" ? Uu5StringTools.printTemplateToChildren(item.value, templateDataMap, uu5DataMap, buildChildFn, allowedTagsRegExp) : item.value;
    }
  }]);

  return Uu5StringProps;
}();

module.exports = Uu5StringProps;

/***/ })
/******/ ]);
});