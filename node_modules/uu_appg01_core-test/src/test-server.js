"use strict";

const Path = require("path");
const { fork, execSync } = require("child_process");
const { Config, BaseError, Json } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const autobind = require("auto-bind");

const DEFAULT_HOSTNAME = "0.0.0.0";
const DEFAULT_IPV6_HOSTNAME = "::";
const DEFAULT_PORT = 0;
const DEFAULT_PROTOCOL = "http";

const DEBUGGER_REGEXP = /^Debugger (listening|attached)/;

class TestServer {
  constructor(pathToApp, options = {}) {
    this._path = pathToApp || Path.join(process.cwd(), "app.js");
    this._port = options.port || DEFAULT_PORT;
    this._hostname = options.hostname || DEFAULT_HOSTNAME;
    this._protocol = options.protocol || DEFAULT_PROTOCOL;
    this._verbose = options.verbose || false;
    this._process = null;
    this._confirmedAddress = null;
    this._originalConfig = null;
    autobind(this);
  }

  async start() {
    let config = Config.chain ? Config.chain._custom : {};
    this._originalConfig = Object.assign({}, config);
    if (!this._verbose) {
      Config.set("log_level", "ERROR");
      Config.set("uuapp.sysmon.logger.log_level", "OFF");
      Config.set("uuapp.perflog.logger.log_level", "OFF");
      Config.set("uuapp.appserver.monitoring.accesslog.log_level", "OFF");
      LoggerFactory.configureAll();
      config = Config.chain._custom;
    }
    process.env["SERVER_CFG"] = Json.stringify(config);
    let m;
    try {
      m = await this._spawnApplication();
    } catch (e) {
      throw new BaseError("Unable to spawn a subprocess and start the server: " + e.message, e);
    }
    if (this._confirmedAddress) {
      let a = this._confirmedAddress;
      if (a.protocol === m.protocol && a.address === m.address && a.port === m.port) return m;
      throw new BaseError(
        `Pre-instantiated server gateway does not match the spawned one.\nOriginal:\n${Json.stringify(
          a
        )}\nSpawned:\n${Json.stringify(m)}`
      );
    } else {
      return (this._confirmedAddress = m);
    }
  }

  async stop() {
    await this._kill();
    if (this._originalConfig) {
      Config.chain._custom = this._originalConfig;
      if (!this._verbose) {
        LoggerFactory.configureAll();
      }
      this._originalConfig = null;
    }
    return this._killed;
  }

  getPort() {
    if (this._confirmedAddress) {
      return this._confirmedAddress.port;
    } else {
      return this._port;
    }
  }

  getGatewayUrl() {
    if (this._confirmedAddress) {
      let { address, protocol, port } = this._confirmedAddress;
      if (address === DEFAULT_HOSTNAME || address === DEFAULT_IPV6_HOSTNAME) address = "127.0.0.1";
      return `${protocol}://${address}:${port}`;
    } else {
      return `${this._protocol}://${this._hostname}:${this._port}`;
    }
  }

  async _spawnApplication() {
    let execArgv = process.execArgv.map(arg => {
      let inspectMatch = arg.match(/--inspect(-brk)?(=(\d+))?/);
      if (inspectMatch) {
        let parentPort = inspectMatch[3];
        let childPort = null;
        if (!parentPort || parentPort === "0") {
          childPort = 0;
        } else {
          childPort = parseInt(parentPort) + 1;
        }
        return `--inspect=${childPort}`;
      }
      return arg;
    });

    let opts = {
      env: {
        ...process.env,
        PORT: this._port,
        server_port: this._port,
        server_host: this._hostname,
        server_protocol: this._protocol
      },
      cwd: Path.dirname(this._path),
      execArgv,
      silent: true
    };

    return new Promise((resolve, reject) => {
      this._process = fork(this._path, opts);

      let promiseResolved = false;
      this._process.once("error", e => {
        promiseResolved = true;
        reject(e);
      });
      this._process.once("message", m => {
        promiseResolved = true;
        resolve(m);
      });
      this._process.stdout.on("data", chunk => {
        console.log(chunk.toString());
      });
      let errorMsg = "";
      this._process.stderr.on("data", chunk => {
        let msg = chunk.toString();
        if (DEBUGGER_REGEXP.test(msg)) {
          process.stderr.write(msg);
        } else {
          if (!promiseResolved) {
            errorMsg += msg
          };
          console.error(msg);
        }
      });
      this._process.once("close", (status, b) => {
        if (status !== 0) {
          reject(new Error(errorMsg || `Error during child process spawn, status ${status}`));
        }
      });
    });
  }

  async _kill() {
    if (!this._process) {
      return;
    }

    return new Promise((resolve, reject) => {
      this._process.send("killTestServerSubProcess");

      let process = this._process;

      this._process.on("exit", () => {
        this._process = null;
        process = null;
        resolve();
      });

      setTimeout(() => {
        if (process) {
          // console.log("Server didn't response to exit message. It will be killed forcibly.");
          process.kill();
          resolve();
        }
      }, 500);
    });
  }

  get _killed() {
    return this._process ? this._process.killed : true;
  }
}

module.exports = TestServer;
