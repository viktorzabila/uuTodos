"use strict";

const Got = require("got");
const FormData = require("form-data");
const {Readable}= require("stream");
const { Json } = require("uu_appg01_core-utils");

class TestClient {

  static async get(url, headers = {}) {
    let result;
    try {
      result = await Got.get(url, {
        headers: headers,
        retries: 0,
        followRedirect: false,
        https: {
          rejectUnauthorized: false
        }
      });
    } catch (e) {
      if (e.response) {
        e.statusCode = e.response.statusCode;
        e.statusMessage = e.response.statusMessage;
        e.headers = e.response.headers;
        e.body = e.response.body;
      }
      throw e;
    }
    let data = TestClient._processResponseBody(result.body, result.headers);
    return { status: result.statusCode, headers: result.headers, data: data };
  }

  static async head(url, headers = {}) {
    let result;
    try {
      result = await Got.head(url, {
        headers: headers,
        retries: 0,
        followRedirect: false,
        https: {
          rejectUnauthorized: false
        }
      });
    } catch (e) {
      if (e.response) {
        e.statusCode = e.response.statusCode;
        e.statusMessage = e.response.statusMessage;
        e.headers = e.response.headers;
        e.body = e.response.body;
      }
      throw e;
    }
    return { status: result.statusCode, headers: result.headers, data: null };
  }

  static async post(url, parameters = null, headers = {}) {
    let body = TestClient._processRequestParams(parameters, headers);
    let result;
    try {
      result = await Got.post(url, {
        body: body ? body : undefined,
        headers: headers,
        retries: 0,
        followRedirect: false,
        https: {
          rejectUnauthorized: false
        }
      });
    } catch (e) {
      if (e.response) {
        e.statusCode = e.response.statusCode;
        e.statusMessage = e.response.statusMessage;
        e.headers = e.response.headers;
        e.body = e.response.body;
      }
      throw e;
    }
    let data = TestClient._processResponseBody(result.body, result.headers);
    return { status: result.statusCode, headers: result.headers, data: data };
  }

  static _processRequestParams(parameters, headers) {
    let contentType = headers["content-type"];
    if (!parameters || typeof parameters === "string") {
      return parameters;
    } else if (!contentType || /application\/json/.test(contentType)) {
      headers["content-type"] = "application/json";
      return Json.stringify(parameters);
    } else {
      return parameters;
    }
  }

  static _processResponseBody(body, headers) {
    if (/application\/json/.test(headers["content-type"])) {
      return Json.parse(body);
    } else {
      return body;
    }
  }

  static multipartBuilder() {
    let formData = new FormData();
    // TODO Workaround for https://github.com/form-data/form-data/issues/90 which is not
    //   fixed despite being closed (see https://github.com/form-data/form-data/pull/70
    //   and https://github.com/mscdex/busboy/issues/137)
    // Workaround forces form-data to not return its length when when other than
    // file stream is appended (which ensures got uses chunked transfer encoding)
    formData.origAppend = formData.append.bind(formData);
    formData.append = (function (name, value, ...otherArgs) {
      this.origAppend(name, value, ...otherArgs);
      if (value instanceof Readable && !value.hasOwnProperty('fd')) {
        formData.getLengthSync = (function() {return undefined;}).bind(formData);
        formData.getLength = (function(cb) {cb(null, this.getLengthSync())}).bind(formData);
      }
    }).bind(formData);
    return formData;
  }
}

module.exports = TestClient;
