const path = require("path");

let babel;
let Es6ExportsReader;

const MAGIC_COMMENT = "devkit-pure-exports";
const MAGIC_COMMENT_RE = new RegExp(String.raw`(^|\n)\s*(//[ \t]*${MAGIC_COMMENT}\b|/\*[ \t]*${MAGIC_COMMENT}\b)`);

module.exports = function (...args) {
  let callback = this.async();
  (async function () {
    let result;
    try {
      result = await normalFlow.apply(this, args);
      if (!result) result = [args[0], args[1]];
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, ...result);
  }.call(this));
};

async function normalFlow(content) {
  if (this.target !== "web" || typeof content !== "string") return;
  if (!content.match(MAGIC_COMMENT_RE)) return;

  // get exports from the file
  let { babelConfig } = this.query;
  if (!Es6ExportsReader) Es6ExportsReader = require("../../scripts/intellisense/es6-exports-reader.js");
  let exportsReader = new Es6ExportsReader(babelConfig, true);
  let { exports, complete, missingSources } = exportsReader.getExportsFromJs(content, this.context, {
    includeMeta: true,
  });

  // rewrite exports
  if (!babel) babel = require("@babel/core");
  let ast = babel.parseSync(content, babelConfig);
  let rootStatements = (ast.program || {}).body || [];
  for (let node of rootStatements) {
    let isRecognized =
      node.type === "ExportAllDeclaration" || (node.type === "ExportNamedDeclaration" && !node.declaration);
    if (!isRecognized) {
      this.emitWarning(
        new Error(
          `${require("chalk").yellow("WARN")} Skipping exports optimization (${MAGIC_COMMENT}) in ${
            this.resourcePath
          }` +
            ' - only `export ... from ...;` statements are allowed for the optimization. Separate more complex logic to e.g. extra-exports.js file and add `export * from "./extra-exports.js";` here.'
        )
      );
      return;
    }
  }
  let resultParts = [];
  let dependenciesP = [];
  resultParts.push(`module.exports = {`);
  for (let name in exports) {
    let { sourceName, sources } = exports[name];
    let source = sources[0];
    resultParts.push(`  get ${JSON.stringify(name)}() {
    return require(${JSON.stringify(source)})[${JSON.stringify(sourceName)}];
  },`);
    // add watching of relevant files
    dependenciesP.push(
      (async () => {
        let dir = this.context;
        for (let source of sources) {
          let filePath = await resolveImportPath.call(this, dir, source);
          if (filePath) this.addDependency(filePath);
          else this.addContextDependency(path.dirname(path.resolve(dir, source)));
          dir = filePath.replace(/^(.*)[/\\].*/, "$1");
        }
      })().catch((e) => null)
    );
  }
  resultParts.push(`};\n`);
  let modContent = resultParts.join("\n");

  for (let dep of missingSources) this.addContextDependency(path.dirname(dep.source));
  await Promise.all(dependenciesP);

  // NOTE This must be done after "this.add*Dependency(...)" calls so that fixing code in a dependency file
  // would trigger our recompilation too.
  if (missingSources.length > 0) {
    throw new Error(
      `${missingSources[0].from || this.resourcePath}: import / export \`${
        missingSources[0].sourceName
      }\` does not exist.`
    );
  }
  if (!complete) {
    this.emitWarning(
      new Error(
        `${require("chalk").yellow("WARN")} Skipping exports optimization (${MAGIC_COMMENT}) in ${this.resourcePath}` +
          ' - some exports could not be discovered (are you using `export * from "3rd-party-library";`?).'
      )
    );
    return;
  }

  // if (modContent) console.log(`PureExportsLoader - ${this.resourcePath} rewrote to:\n`, modContent);
  return [modContent];
}

function resolveImportPath(dir, importString) {
  return new Promise((resolve, reject) =>
    this.resolve(dir, importString, (err, filePath) => {
      if (err) resolve();
      else resolve(filePath);
    })
  );
}
