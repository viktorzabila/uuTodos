const path = require("path");
const fs = require("fs");
const util = require("util");

const fs_readFile = util.promisify(fs.readFile);
const fs_readdir = util.promisify(fs.readdir);

let StringUtil;
let uuAppJsonPath;

module.exports = function (...args) {
  let callback = this.async();
  (async function () {
    let content, map;
    try {
      [content, map] = await normalFlow.apply(this, args);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, content, map);
  }.call(this));
};

async function normalFlow(content, map) {
  if (this.target !== "web" || typeof content !== "string") {
    return [content, map];
  }
  if (!content.match(/__webpack_public_path__ =/)) {
    return [content, map]; // it's not an entry-point
  }

  if (!uuAppJsonPath) uuAppJsonPath = path.resolve(require("../paths.js").uuAppJsonPath);
  this.addDependency(uuAppJsonPath);

  let decorationFilePath = await regenerateDecorationFile(uuAppJsonPath, this.context);
  if (decorationFilePath) {
    content += `
var extraExports = { ...require("./${path.relative(this.context, decorationFilePath).replace(/\\/g, "/")}") };
Object.assign(module.exports, extraExports);
if (!module.exports.default) module.exports.default = {};
Object.assign(module.exports.default, extraExports);
`;
  }
  return [content, map];
}

async function regenerateDecorationFile(uuAppJsonPath, targetDir) {
  let uuAppJson = JSON.parse(await fs_readFile(uuAppJsonPath, "utf-8"));
  let projectFolderName = path.basename(path.resolve("."));
  let specificConfig = uuAppJson[projectFolderName];
  let { componentList = [] } = specificConfig || {};
  let generatedComponentFiles = [];
  for (let i = 0; i < componentList.length; i++) {
    let { code, decorationComponentName } = componentList[i];
    if (!decorationComponentName) continue;
    if (!code) {
      console.warn(
        `WARN uuapp.json $.${projectFolderName}.componentList[${i}] is a decoration component but it's missing "code" - skipping.`
      );
      continue;
    }
    if (code.indexOf(".") !== code.lastIndexOf(".")) {
      console.warn(
        `WARN uuapp.json $.${projectFolderName}.componentList[${i}].code is "${code}" - multiple dots in decoration component code is not supported, skipping.`
      );
      continue;
    }
    let filePath = await generateDecorationComponent(componentList[i], targetDir);
    generatedComponentFiles.push(filePath);
  }

  if (generatedComponentFiles.length > 0) {
    let decorationExports =
      generatedComponentFiles
        .map((filePath) => `export * from "./${path.relative(targetDir, filePath).replace(/\\/g, "/")}";`)
        .join("\n") + "\n";

    let decorationFilePath = path.join(targetDir, "__decoration.js");
    emitFile(decorationFilePath, decorationExports);
    return decorationFilePath;
  }
}

async function generateDecorationComponent(descriptor, targetDir) {
  if (!StringUtil) StringUtil = require("uu_appg01_devkit-common/src/tools/string-util.js");
  let fileName = "__decoration" + descriptor.code.replace(/\./g, "-") + ".js";
  let filePath = path.join(targetDir, fileName);
  let context = {
    uu5Tag: descriptor.code.split(".").pop(),
    decorationComponentName: descriptor.decorationComponentName,
    decorationComponentProps: JSON.stringify(descriptor.decorationComponentProps, null, 2),
  };
  let template = await readTemplate(descriptor.decorationComponentName);
  if (descriptor.decorationComponentName === "Image") await fillContextForImage(context, descriptor);
  let content = StringUtil.evalExpressions(template, context, filePath);
  emitFile(filePath, content);
  return filePath;
}

let templates = {};
async function readTemplate(component) {
  let fileName = component === "Image" ? "decoration-component-image.js" : "decoration-component.js";
  let template = templates[fileName];
  if (!template) {
    template = templates[fileName] = await fs_readFile(
      require.resolve(`uu_appg01_devkit-common/src/templates-generator/__uu5/${fileName}`),
      "utf-8"
    );
  }
  return template;
}

// NOTE Synchronous so that webpack doesn't have chance to pick up wrong mtime.
function emitFile(filePath, content) {
  fs.writeFileSync(filePath, content, "utf-8");

  // prevent re-compilation loop during first few seconds after "npm start"
  let timeInPast = Date.now() / 1000 - 10;
  fs.utimesSync(filePath, timeInPast, timeInPast);
}

async function fillContextForImage(context, descriptor) {
  let { src } = descriptor.decorationComponentProps || {};
  if (src) {
    let absPath = path.resolve("src/assets", src);
    let fileName = path.basename(absPath);
    let dirAbsPath = path.dirname(absPath);
    let parts = fileName.split(".");
    let extension = fileName.indexOf(".") !== -1 ? "." + parts.pop() : "";
    let prefix = parts.join(".");
    let files = (await fs_readdir(dirAbsPath)).filter(
      (fileName) => path.basename(fileName).startsWith(prefix + "-") && fileName.endsWith(extension)
    );
    let existingByAspectRatio = {};
    for (let file of files) {
      let parts = file.slice(0, file.length - extension.length).split(/-/);
      let aspectRatio = parts.pop();
      let size = parts.pop();
      if (!existingByAspectRatio[aspectRatio]) existingByAspectRatio[aspectRatio] = [];
      existingByAspectRatio[aspectRatio].push(size);
    }
    context.srcFileMapping = JSON.stringify(existingByAspectRatio);
  } else {
    context.srcFileMapping = JSON.stringify(null);
  }
}
