const path = require("path");
const fs = require("fs-extra");

const paths = require("./paths.js");

class HtmlTestResultsProcessor {
  constructor(config) {
    this.config = config || {};
  }

  process(testResult) {
    let outputPath = this.config.outputPath || paths.testResultsProcessorOutputPath;
    if (outputPath) {
      // testResult object: https://facebook.github.io/jest/docs/en/configuration.html#testresultsprocessor-string
      let template = fs.readFileSync(__dirname + "/jest-html-test-results-processor-template.html", "utf-8");
      let context = {
        testResultHtml: this._serializeToHtml(testResult),
      };
      let htmlResult = evalExpressions(template, context);

      fs.mkdirpSync(path.dirname(outputPath));
      fs.writeFileSync(outputPath, htmlResult, "utf-8");
      console.log(`Test results written to ${outputPath}`);
    }
  }

  _serializeToHtml(testResult) {
    let orderedTestResults = testResult.testResults;
    orderedTestResults.sort((a, b) => {
      // order: failed, skipped, passed (by-name)
      let failDiff = (a.numFailingTests > 0 ? 0 : 1) - (b.numFailingTests > 0 ? 0 : 1);
      if (failDiff) return failDiff;
      let skipDiff = (a.numPendingTests > 0 ? 0 : 1) - (b.numPendingTests > 0 ? 0 : 1);
      if (skipDiff) return skipDiff;
      if (testResult.consoleMap) {
        let consoleA = testResult.consoleMap[a.testFilePath] || [];
        let consoleB = testResult.consoleMap[b.testFilePath] || [];
        let diff;
        diff =
          consoleB.filter((it) => it.type === "error").length - consoleA.filter((it) => it.type === "error").length;
        if (diff) return diff;
        diff = consoleB.filter((it) => it.type === "warn").length - consoleA.filter((it) => it.type === "warn").length;
        if (diff) return diff;
        diff = consoleB.filter((it) => it.type === "log").length - consoleA.filter((it) => it.type === "log").length;
        if (diff) return diff;
      }
      return a.testFilePath < b.testFilePath ? -1 : a.testFilePath > b.testFilePath ? 1 : 0;
    });
    let usedTestResults = orderedTestResults.map((it) => ({ ...it, testResults: safeJsonStringify(it.testResults) })); // extra stringify so that HTML page parses the root level faster
    let obj = {
      ...testResult,
      testResults: usedTestResults,
    };
    let json = JSON.stringify(obj, null, 2);
    let result = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return result;
  }
}

function evalExpressions(template, context) {
  return template.replace(/\$([a-zA-Z\-_]+)\$/g, (m, g1) => context[g1]);
}

function safeJsonStringify(value, fallbackValue) {
  try {
    if (value === undefined) return fallbackValue;
    return JSON.stringify(value);
  } catch (e) {
    if (e && typeof e.message === "string" && e.message.match(/circular/i)) {
      let cache = new Set();
      try {
        return JSON.stringify(value, (key, value) => {
          if (typeof value === "object" && value !== null) {
            if (cache.has(value)) return "<circular or duplicit reference>";
            cache.add(value);
          }
          return value;
        });
      } catch (e) {
        console.error(e);
      }
    } else {
      console.error(e);
    }
  }
  return fallbackValue;
}

// export API as required by Jest
module.exports = (testResult) => {
  let config = JSON.parse(fs.readFileSync("package.json", "utf-8"))["jest-html-test-results-processor"];
  let reporter = new HtmlTestResultsProcessor(config);
  reporter.process(testResult);
  return testResult;
};
