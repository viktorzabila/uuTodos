const fs = require("fs-extra");
const path = require("path");

const paths = require("../config/paths.js");
const helpers = require("../tools/helpers.js");
const Pack = require("uu_appg01_devkit-common/src/tools/package.js");

module.exports = class Package {
  constructor(config) {
    this.config = config;
  }

  async process() {
    // Ensure project is built before packaging
    await helpers.exec("npm run --loglevel=error build -- " + this.config.toCommandLineArgs().join(" ")); // TODO Args escaping.
    Pack.getSingletonSync("package.json").loadSync(); // reload as version might have changed

    let pack = Pack.getSingletonSync("package.json");
    let pkg = pack.get();
    let { type } = helpers.getTemplateInfo();

    // move transpiled stuff to root directory so that "npm pack" includes it
    // (it can't be reconfigured to use different folder)
    console.log("Creating npm package.");
    let npmPackFile = await this._preparePackFiles(pkg, type);
    console.log("  " + npmPackFile);

    console.log("Creating library pack with built npm packages (.tgz files).");
    const zip = require("../tools/zip.js");
    let libraryPackPath = path.join(paths.buildDir, pkg.name + "-" + pkg.version + "-library-pack.zip");
    await zip(libraryPackPath, (archive) => {
      archive.file(npmPackFile, { name: path.basename(npmPackFile) });
    });
    console.log(`  ${libraryPackPath}`);

    console.log("Creating library descriptor.");
    let loaderSettings;
    if (type !== "nodejs-lib") {
      if (!pkg.uuBuildSettings || !pkg.uuBuildSettings.skipExternalsDiscovery) {
        const DependencyProcessor = require("./common/dependency-processor");
        loaderSettings = {
          ...pkg.uuBuildSettings,
          externals: new DependencyProcessor("package.json").getExternals("lib"),
        };
      } else {
        loaderSettings = pkg.uuBuildSettings;
      }
    }
    const Generator = require("./common/library-descriptor-generator.js");
    let workspaceLibList = this.config.getWorkspaceLibraryList();
    let isLibInWorkspaceMultiLib = workspaceLibList.some((it) => it.name === pkg.name);
    let libDescGenerator = new Generator(
      path.resolve("."),
      pkg.name,
      pkg.version,
      paths.buildDir,
      this.config,
      pkg.dependencies,
      loaderSettings,
      type,
      isLibInWorkspaceMultiLib ? workspaceLibList.map(it => it.name) : undefined
    );
    let { descriptor, descriptorPath } = libDescGenerator.generateLibraryDescriptor();
    console.log("  " + descriptorPath);

    let isBeta = pkg.version.match(/[-.][a-zA-Z]/);
    if (type === "uu5-lib" || type === "lib") {
      const UuCloudLibraryConfig = require("./uu_cloud/uu-cloud-library-config");

      let uuCloudLibraryConfig = new UuCloudLibraryConfig(
        path.resolve("."),
        pkg.name,
        pkg.version,
        paths.buildDir,
        this.config
      );

      console.log("Creating CDN pack.");
      let projectName = pkg.name;
      let projectVersion = uuCloudLibraryConfig.getQualifiedVersion();
      let { vendor, nameNoVendor } = pack;
      let cdnPackName = vendor + "-" + nameNoVendor.replace(/_/g, "-");
      let cdnPackFile = `${projectName}-${projectVersion}-cdn-pack.zip`;
      await zip(path.join(paths.buildDir, cdnPackFile), (archive) => {
        let inZipDir = path.join(cdnPackName, projectVersion);
        archive.directory(paths.buildLibWebDir, inZipDir);
        if (isBeta) archive.file(npmPackFile, { name: pkg.name + ".tgz", prefix: inZipDir });
      });
      console.log(`  ${paths.buildDir}${path.sep}${cdnPackFile}`);

      if (!isLibInWorkspaceMultiLib) {
        console.log("Creating uuCloud descriptor.");
        let cloudDescriptorPath = uuCloudLibraryConfig.generateCloudDescriptor();
        uuCloudLibraryConfig.updateUuSubAppDescriptor();
        console.log("  " + cloudDescriptorPath);
      }
    }
  }

  async _preparePackFiles(pkg, type) {
    if (type === "uu5-lib") {
      return this._preparePackFilesInSeparateDir(pkg, type);
    }

    // prepare files for "npm pack" in current dir (where package.json is located)
    // - typically used in server-side / isomorphic libraries (which usually have only
    // src/ packaged)
    let ops = new ReversibleOps();
    let hasWebDir = await fs.pathExists(paths.buildLibWebDir);
    let hasNodeDir = await fs.pathExists(paths.buildLibNodeDir);
    let hasEsmDir = await fs.pathExists(paths.buildLibEsmDir);
    if (hasWebDir) ops.move(paths.buildLibWebDir, paths.npmPackTranspiledWebLibDir, { overwrite: true });
    if (hasNodeDir) ops.move(paths.buildLibNodeDir, paths.npmPackTranspiledNodeLibDir, { overwrite: true });
    if (hasEsmDir) ops.move(paths.buildLibEsmDir, paths.npmPackEsmDir, { overwrite: true });
    if (!(await fs.pathExists("LICENSE")) && await fs.pathExists("../LICENSE")) {
      ops.copy("../LICENSE", "LICENSE", { overwrite: true });
    }
    await ops.run();
    try {
      let packFile = (await helpers.exec("npm pack", { silent: true })).stdout.trim();
      fs.moveSync(packFile, path.join(paths.buildDir, packFile), { overwrite: true });
      return path.join(paths.buildDir, packFile);
    } finally {
      await ops.rollback(); // move files back / delete copied ones
    }
  }
  async _preparePackFilesInSeparateDir(pkg, type) {
    let ops = new ReversibleOps();
    // prepare files for "npm pack" in target/npm-pack/ dir because
    // we need files from target/dist-root/* to be in the same directory
    // as package.json (when in .tgz) and don't want to encounter possible naming conflicts
    // while in project root
    let npmPackDir = path.join(paths.buildDir, "npm-pack");
    fs.emptyDirSync(npmPackDir);

    let hasRootDir = await fs.pathExists(paths.buildLibRootDir);
    let hasNodeDir = await fs.pathExists(paths.buildLibNodeDir);
    let hasWebDir = await fs.pathExists(paths.buildLibWebDir);
    let hasEsmDir = await fs.pathExists(paths.buildLibEsmDir);
    if (hasRootDir) ops.move(paths.buildLibRootDir, npmPackDir);
    await ops.run();
    if (hasNodeDir) ops.move(paths.buildLibNodeDir, path.join(npmPackDir, "dist-node"));
    if (hasWebDir) ops.move(paths.buildLibWebDir, path.join(npmPackDir, "dist"));
    if (hasEsmDir) ops.move(paths.buildLibEsmDir, path.join(npmPackDir, "dist-esm"));
    if (!(await fs.pathExists("LICENSE")) && await fs.pathExists("../LICENSE")) {
      ops.copy("../LICENSE", path.join(npmPackDir, "LICENSE"), { overwrite: true });
    }
    await ops.run();

    // copy all files as given by "files" field in package.json to our npmPackDir
    let isExpectedPkgMain =
      type === "uu5-lib" || (typeof pkg.main === "string" && pkg.main.match(/^(dist-node|src)\/index(\.js)?$/));
    let packResult = await helpers.exec("npm pack --dry-run --json --loglevel=notice", { silent: true });
    let json = packResult.stdout.trim();
    let extraFiles;
    try {
      extraFiles = json ? (((JSON.parse(json) || [])[0] || {}).files || []).map((it) => it.path) : [];
    } catch (e) {
      // npm >= 7.x no longer supports "--json" flag therefore JSON.parse fails; but it does output something like:
      //   npm notice === Tarball Contents ===
      //   npm notice 9.7kB LICENSE
      //   npm notice 2.1kB package.json
      //   ...
      // in stderr, so try to parse that :-/
      let plainText = packResult.stderr.trim().replace(/\033\[[0-9;]+m/g, ""); // strip color codes
      extraFiles = [];
      plainText.replace(/(?:^|\n)npm notice\s+\d+(?:\.\d+)?[kmg]?B\s+(.*)/g, (m, g) => extraFiles.push(g.trim()));
      if (extraFiles.length === 0) {
        // old versions of npm also don't support "--json" or it's new version of npm with different output...
        // => estimate files to package
        extraFiles = ["package.json", "LICENSE", "README.md"];
        let isFatal;
        if (Array.isArray(pkg.files)) {
          let incompatible = pkg.files.filter(
            (f) => typeof f !== "string" || (f.indexOf("*") !== -1 && !f.match(/^dist(\*|-node\/\*|-esm\/\*|\/\*)?$/))
          );
          isFatal = incompatible.length > 0;
          if (!isFatal) extraFiles = extraFiles.concat(pkg.files.filter((f) => f.indexOf("*") === -1));
        }
        const chalk = require("chalk");
        if (isFatal) {
          console.error(
            "  " +
              chalk.red("ERROR") +
              ` Unable to create npm package - this project is using custom "files" value in package.json. Upgrade Node.js to >= 10.16.0 to fix this issue. If that is not possible then do not use glob patterns in "files" array (with the exception of "dist*" value).`
          );
          await ops.rollback();
          process.exit(1);
        }
        console.warn(
          "  " +
            chalk.yellow("WARN") +
            " This version of npm is not fully supported - try to upgrade it. Extracting list of files from `npm pack --dry-run` was unsuccessful, but it should still be OK (will use estimated list - you can check resulting .tgz file whether it contains all expected files)."
        );
        extraFiles = [...new Set(extraFiles)].filter((f) => fs.existsSync(f));
      }
    }
    extraFiles = extraFiles.filter((it) => !it.startsWith("dist"));
    if (isExpectedPkgMain) extraFiles = extraFiles.filter((it) => it !== pkg.main);
    extraFiles.forEach((file) => ops.copy(file, path.join(npmPackDir, file), { overwrite: false }));
    await ops.run();

    // update package.json
    let modPkg = JSON.parse(JSON.stringify(pkg));
    delete modPkg.files; // all files in folder will be included during "npm pack"
    if (isExpectedPkgMain) {
      modPkg.main = "index.js";
    }
    if (modPkg.module === "dist-esm/index.js" || modPkg.module === "dist-esm/index") {
      delete modPkg.module;
    }
    if (modPkg["jsnext:main"] === "dist-esm/index.js" || modPkg["jsnext:main"] === "dist-esm/index") {
      delete modPkg["jsnext:main"];
    }
    if (!modPkg["typings"] && await fs.pathExists(path.join(npmPackDir, "index.d.ts"))) {
      modPkg["typings"] = "index.d.ts"; // must be explicitly present for JetBrains IDEs (VSCode does not need it)
    }
    fs.writeFileSync(path.join(npmPackDir, "package.json"), JSON.stringify(modPkg, null, 2), "utf-8");

    try {
      let packFile = (await helpers.exec("npm pack", { silent: true, cwd: path.resolve(npmPackDir) })).stdout.trim();
      fs.moveSync(path.join(npmPackDir, packFile), path.join(paths.buildDir, packFile), { overwrite: true });
      return path.join(paths.buildDir, packFile);
    } finally {
      await ops.rollback(); // move files back / delete copied ones
    }
  }
};

class ReversibleOps {
  constructor() {
    this._ops = [];
    this._rollbackList = [];
  }
  async copy(...args) {
    let op = async () => fs.copy(...args);
    this._ops.push(op);
    this._rollbackList.push(() => this.remove(args[1]));
    return op;
  }
  async move(...args) {
    let op = async () => fs.move(args[0], args[1], { overwrite: true, ...args[2] }, ...args.slice(3));
    this._ops.push(op);
    this._rollbackList.push(() => this.move(args[1], args[0], { overwrite: true, ...args[2] }, ...args.slice(3)));
    return op;
  }
  async remove(...args) {
    let op = async () => fs.remove(...args);
    this._ops.push(op);
    return op;
  }
  async run(parallel = true) {
    let ops = this._ops;
    this._ops = [];
    if (parallel) return Promise.all(ops.map((op) => op()));
    for (let op of ops) await op();
  }
  async rollback() {
    let rollbackList = this._rollbackList;
    this._rollbackList = [];
    rollbackList.splice(-this._ops.length, this._ops.length); // remove un-executed op rollbacks
    this._ops = [];
    rollbackList.reverse().forEach((op) => op());
    return this.run(false); // in succession
  }
}
