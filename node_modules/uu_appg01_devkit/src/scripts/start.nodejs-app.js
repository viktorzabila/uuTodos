const path = require("path");
const fs = require("fs");
const os = require("os");
const net = require("net");
const util = require("util");
const child_process = require("child_process");
const Pack = require("uu_appg01_devkit-common/src/tools/package.js");
const helpers = require("../tools/helpers.js");
const configLoader = require("../tools/simple-config-loader.js");
const connectionHelper = require("../tools/connection-helper.js");
const Muri = require("muri");

const fsAccess = util.promisify(fs.access);

let TestMongo = null;
try {
  TestMongo = require("uu_appg01_datastore-test").TestMongo;
} catch (e) {
  console.warn("Library uu_appg01_datastore-test is not installed, embedded database will not be started.", e);
}

module.exports = class Start {

  constructor(config) {
    this.config = config || {};
  }

  async process() {
    // Ensure project is built before starting
    // Build server itself
    await helpers.exec("npm run --loglevel=error build -- --no-build-client " + this.config.toCommandLineArgs().join(" ")); // TODO Escaping.
    Pack.getSingletonSync("package.json").loadSync(); // reload as version might have changed

    // Trigger rebuilding of client project
    let serverDir = process.cwd();
    let buildCheckFile = path.join(serverDir, "public", ".finished");
    let clientDir = serverDir.match(/-server$/) ? path.join("..", path.basename(serverDir).replace(/-server$/, "-hi")) : null;
    if (clientDir && !fs.existsSync(clientDir)) {
      clientDir = path.join("..", path.basename(serverDir).replace(/-server$/, "-client"));
    }
    let hasClient = clientDir && fs.existsSync(clientDir) && fs.existsSync(path.join(clientDir, "package.json"));
    if (hasClient) {
      console.log("Building client project (with automatic rebuild on changes).");
      if (fs.existsSync(buildCheckFile)) {
        // Delete file used for checking of build finish, so that server is not started
        // before build process is started (causing delete of public during server start)
        fs.unlinkSync(buildCheckFile);
      }
      child_process.spawn("npm", ["run", "build", "--", "--watch", "--mode=development"],
        {stdio: ["ignore", "ignore", "inherit"], shell: true, cwd: path.resolve(clientDir)}
      );
    }

    // Load project configuration
    let runtimeEnvironment = this.config.environment || "development,production";
    console.log(`\nLoading configuration for \"${runtimeEnvironment}\" runtime environment`);
    process.env["NODE_ENV"] = runtimeEnvironment;
    let loadedConfig = configLoader.loadConfiguration(runtimeEnvironment);

    if (TestMongo) {
      // Process database configurations
      let dataStoreMap = loadedConfig["uuSubAppDataStoreMap"] || {};
      let projectName = path.basename(path.resolve(".")).replace(/\-[a-zA-Z0-9]+$/, "");
      let dbBaseName = projectName.replace(/(_\w)/g, function (match) {
        return match[1].toUpperCase();
      });
      let embeddedDataStores = {};
      for (let dataStore in dataStoreMap) {
        let connectionUri = dataStoreMap[dataStore];
        if (!connectionUri.startsWith("mongo")) {
          continue;
        }

        let parsedUri = null;
        try {
          parsedUri = Muri(connectionUri);
        } catch (e) {}

        if (parsedUri) {
          let host = parsedUri.hosts[0].host;
          let port = parsedUri.hosts[0].port;
          if (parsedUri.db === "admin") parsedUri.db = null;
          let dbName = parsedUri.db || (`/${dbBaseName}${dataStore.replace(/\\b\\w/g, l => l.toUpperCase())}`).substr(1);

          if (!(await connectionHelper.isServiceListening(port, host))) {
            embeddedDataStores[dataStore] = dbName;
          }
        } else {
          let dbName = `${dbBaseName}${dataStore.replace(/\\b\\w/g, l => l.toUpperCase())}`;
          embeddedDataStores[dataStore] = dbName;
        }
      }

      // Start embedded database if necessary
      if (Object.keys(embeddedDataStores).length != 0) {
        console.log(`\nStarting embedded database for datastores [${Object.keys(embeddedDataStores)}]...`);
        let targetPath = path.join(path.resolve("."), 'target');
        if (!fs.existsSync(targetPath)) {
          fs.mkdirSync(targetPath);
        }
        let storagePath = path.join(path.resolve("."), 'target', 'db_data');
        if (!fs.existsSync(storagePath)) {
          fs.mkdirSync(storagePath);
        }
        let embeddedDb = new TestMongo({
          db: "admin",
          port: await connectionHelper.findFreePort(27017),
          dbPath: storagePath,
          storageEngine: "wiredTiger"
        });
        await embeddedDb.start();
        let dbPort = embeddedDb.getPort();
        for (let dataStore of Object.keys(embeddedDataStores)) {
          embeddedDataStores[dataStore] = `mongodb://127.0.0.1:${dbPort}/${embeddedDataStores[dataStore]}`;
        }
        dataStoreMap = Object.assign(dataStoreMap, embeddedDataStores);
        process.env["SERVER_CFG"] = JSON.stringify({uuSubAppDataStoreMap: dataStoreMap});
        console.log(`Embedded database running at mongodb://127.0.0.1:${dbPort}`);
      }
    }

    // Start application server
    let serverPort = loadedConfig["port"] || (await connectionHelper.findFreePort(6221));
    let pckg = Pack.getSingletonSync("package.json").get();
    let baseName = pckg.name.split("-").slice(0, -1).join("-");
    let appRoute = baseName.toLowerCase().replace(/[\-_]/g, '-');
    process.env["PORT"] = serverPort;
    let startServer = () => {
      return new Promise((resolve, reject) => {
        console.log(`\nStarting application server with automatic restart on changes...\n`);
        let nodemon = helpers.npmScriptBinFile("nodemon");
        let watchedSources = ["--watch", "app.js", "--watch", "app", "--watch", "src"];
        let spawnedChild = child_process.spawn(nodemon, ["app.js", ...watchedSources, ...(this.config._commandLineArgs || [])],
          {stdio: ["inherit", "inherit", "inherit"], shell: true}
        );
        this._waitForServer(serverPort, () => {
          console.log(`\nApplication URI: http://localhost:${serverPort}/${appRoute}/${loadedConfig.tid ? `${loadedConfig.tid}-` : ""}${loadedConfig.asid}\n`);
        });
        spawnedChild.on("exit", (code) => {
          if (code) reject(code);
          else resolve();
        });
      });
    };
    // Start either immediately or wait for client project rebuild
    if (hasClient && !fs.existsSync(buildCheckFile)) {
      console.log("\nWaiting for finish of client build...");
      await this._waitForFile(buildCheckFile);
    }
    await startServer();
  }

  async _waitForFile(path) {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      try {
        await fsAccess(path, fs.constants.F_OK);
        break;
      } catch (e) {
        // ignore (try again)
      }
      await new Promise((resolve) => setTimeout(resolve, 250));
    }
  }

  _waitForServer(port, callback) {
    let socket = null;
    let waitOrRun = (err) => {
      if (err) {
        setTimeout(() => {
          socket = net.createConnection(port).on("connect", waitOrRun).on("error", waitOrRun);
        }, 250);
      } else {
        socket.end();
        callback();
      }
    };
    socket = net.createConnection(port).on("connect", waitOrRun).on("error", waitOrRun);
  }

};
