const path = require("path");

const upgrade = require("uu_appg01_devkit-common/src/upgrade.js");
const helpers = require("../tools/helpers.js");

module.exports = class UuAppDevKitUpgrade {
  constructor(config) {
    this.config = config;
    this._readlineIfc = null;
  }

  async process() {
    if (process.env.UU_APPG01_DEVKIT_UPGRADE_CONF !== "1") {
      let { stdout } = await helpers.exec("git status --porcelain", { silent: true }).catch((e) => ({}));
      if (stdout) {
        let answer = await this._question(
          "Git workspace is not clean - if upgrade fails, you might not be able to get back to original state. Continue with upgrade y/n?",
          "n"
        );
        if (answer === "n") process.exit(0);
        if (this._readlineIfc) this._readlineIfc.close();
      }
      process.env.UU_APPG01_DEVKIT_UPGRADE_CONF = "1";
    }
    let templateInfo = helpers.getTemplateInfo();
    let result = await upgrade(this.config, templateInfo);

    // run upgrade in workspace projects if the upgrade was run from the root
    if (templateInfo.type === "nodejs-multi" && (!result || !result.ranNewerUpgrade)) {
      let modules = this.config.getWorkspaceLibraryList();
      console.log("Upgrading projects: " + modules.map((it) => it.name).join(", "));

      for (let { name, pkg, type } of modules) {
        if (
          !pkg.scripts.uuAppDevKitUpgrade ||
          helpers.resolveByTemplateType(path.join(__dirname, "uu-app-dev-kit-upgrade.js"), type) == null
        ) {
          continue;
        }
        await helpers.exec("npm run uuAppDevKitUpgrade -- " + this.config.toCommandLineArgs().join(" "), {
          cwd: path.resolve(name),
        }); // TODO Escaping of arguments
      }
    }
  }

  _question(text, defValue = null) {
    if (!this._readlineIfc) {
      const readline = require("readline");
      this._readlineIfc = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });
    }
    if (defValue) text += " [" + defValue + "]:";
    text += " ";
    return new Promise((resolve) =>
      this._readlineIfc.question(text, (answer) => {
        let result = answer.trim();
        if (!result && defValue != null) result = defValue;
        resolve(result);
      })
    );
  }
};
