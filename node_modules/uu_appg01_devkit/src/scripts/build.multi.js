const path = require("path");
const fs = require("fs-extra");

const shell = require("shelljs");
const paths = require("../config/paths.js");
const helpers = require("../tools/helpers.js");
const buildHelpers = require("./common/build-helpers.js");

let chalk;

module.exports = class Build {
  constructor(config) {
    this.config = config;
  }

  async process() {
    if (!this.config.getMode()) this.config.setMode("production");

    shell.mkdir("-p", paths.buildDir);
    buildHelpers.checkBuildLock(this.config);

    let modules = this.config.getWorkspaceLibraryList();
    console.log("Building projects: " + modules.map((it) => it.name));

    // clean output directory
    let targetFolder = path.join(paths.buildDir, "build");
    fs.emptyDirSync(targetFolder);

    // wait for modules' build
    let parallel = false; // TODO Decide.
    let silent = parallel;
    if (!chalk) chalk = require("chalk");
    let processes = modules.reduce((r, it) => {
      let run = async () => {
        let { name, path: modulePath } = it;
        try {
          await helpers.exec("npm run build -- " + this.config.toCommandLineArgs().join(" "), {
            silent,
            copyToBuffer: true,
            cwd: path.resolve(modulePath),
          }); // TODO Escaping of arguments
          if (!silent) console.log("");
        } catch (e) {
          if (e && e.stdout && silent) process.stdout.write(e.stdout);
          if (e && e.stderr && silent) process.stderr.write(e.stderr);
          if (!silent) console.log("");
          console.error(`  ${chalk.red("ERROR")} ${chalk.red(name)} failed`);
          process.exit(1); // don't wait for anything
        }

        console.log(`  ${chalk.green(name)} done`);
      };
      let prevPromise = r[r.length - 1];
      r.push(prevPromise && !parallel ? prevPromise.then(run) : run());
      return r;
    }, []);
    await Promise.all(processes);
  }
};
