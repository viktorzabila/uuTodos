const path = require("path");
const fs = require("fs");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const UuCloudConfig = require("./uu-cloud-config.js");

const DEFAULT_SCHEMA_URI = "ues:SYSTEM:UU.OS/UUAPP-DEPLOY-SCHEMA-V2.3";
const DEFAULT_GATEWAY_URI = "https://cdn.plus4u.net";

class UuCloudLibraryConfig extends UuCloudConfig {
  constructor(projectRoot, projectName, projectVersion, targetDir, buildConfig, taskName) {
    super(projectRoot, projectName, projectVersion, targetDir, buildConfig, taskName);
    this.buildConfig = buildConfig;
    this.libraryDescriptor = null;
  }

  uuAppBoxConfig() {
    let result = super.uuAppBoxConfig();
    let appBoxNaming = this._getAppBoxNaming();
    result.libraryPackCode = `${appBoxNaming.code}/LIBRARY-PACK`;
    result.libraryPackPath = this._getLibraryPackPath();
    result.libraryDescriptorCode = `${appBoxNaming.code}/LIBRARY-DESCRIPTOR`;
    result.libraryDescriptorPath = this._getLibraryDescriptorPath();
    return result;
  }

  async uuDeployConfig() {
    return super.uuDeployConfig(false);
  }

  generateCloudDescriptor() {
    let qualifiedVersion = this.getQualifiedVersion();
    let descriptorPath = path.resolve(this.targetDir, `${this.projectName}-${qualifiedVersion}-deploy.json`);
    descriptorPath = path.relative(".", descriptorPath);

    let appBoxNaming = this._getAppBoxNaming();
    let cloudDescriptor = {};
    cloudDescriptor.schemaUri = DEFAULT_SCHEMA_URI;
    cloudDescriptor.data = {};
    cloudDescriptor.data.code = appBoxNaming.code;
    cloudDescriptor.data.name = appBoxNaming.name;
    // NOTE Not using unique version for CDN as it would have to be provided in URLs.
    cloudDescriptor.data.version = this.projectVersion;
    // TODO Improve (why is CDN deploy recognized by not having packs?).
    cloudDescriptor.data.packs = [];
    cloudDescriptor.data.nodeSets = [];

    fs.writeFileSync(descriptorPath, JSON.stringify(cloudDescriptor, null, 2));
    return descriptorPath;
  }

  getQualifiedVersion(version = null) {
    // for libraries don't include build timestamp in the version
    return version || this.projectVersion;
  }

  _getAppBoxNaming() {
    let parsedName = Package.parseProduct(this.projectName);
    return {
      code: parsedName.product.toUpperCase().replace(/[\-_]/g, "."),
      name: parsedName.name,
    };
  }

  _getCloudDescriptor(...args) {
    if (!this._isCdnPackRequired()) return null;
    return super._getCloudDescriptor(...args);
  }

  _getLibraryPackPath() {
    let qualifiedVersion = this.getQualifiedVersion();
    let expectedPath = path.resolve(this.targetDir, `${this.projectName}-${qualifiedVersion}-library-pack.zip`);
    if (fs.existsSync(expectedPath)) return expectedPath;
    return null;
  }

  _getLibraryDescriptorPath() {
    let qualifiedVersion = this.getQualifiedVersion();
    let expectedPath = path.resolve(this.targetDir, `${this.projectName}-${qualifiedVersion}-library-descriptor.json`);
    if (fs.existsSync(expectedPath)) return expectedPath;
    return null;
  }

  _getAppPackageCode(cloudDescriptor, defaultCodePrefix) {
    return `${defaultCodePrefix}/CDN-PACK`;
  }

  _getAppPackagePath() {
    if (!this.appPackagePath && typeof this.appPackagePath !== "string") {
      let baseVersion = this.projectVersion.replace(/([\.\-][a-zA-Z][a-zA-Z0-9]*)\.[0-9]+/, (match, g1) => {
        return g1;
      });
      if (!fs.existsSync(this.targetDir)) {
        throw new Error(`App package does not exist at location ${this.targetDir}. Run [package] task to create it.`);
      }
      let exactMatch;
      let files = fs.readdirSync(this.targetDir).filter((fn) => {
        let match = fn.match(new RegExp(`^${this.projectName}-${baseVersion}(|\\..*)-cdn-pack\\.zip$`));
        if (match && fn === `${this.projectName}-${this.projectVersion}-cdn-pack.zip`) exactMatch = fn;
        return match;
      });
      if (files.length == 0) {
        if (this._isCdnPackRequired()) {
          throw new Error(`App package does not exist at location ${this.targetDir}. Run [package] task to create it.`);
        } else {
          this.appPackagePath = "";
        }
      } else {
        this.appPackagePath = path.resolve(this.targetDir, exactMatch || files.sort().pop());
      }
    }
    return this.appPackagePath;
  }

  async _resolveAppUrl(tid = null, awid = null) {
    let parsedName = Package.parseProduct(this.projectName);
    let libNameWithVendor = parsedName.product.replace(/_/g, "-");
    let libVersion = this.projectVersion;
    let betaPrefix = libVersion.match(/[-.][a-zA-Z]/) ? "beta/" : "";
    let fileName;
    let fallbackFileName = `${this.projectName}.js`;
    let appPackagePath = this._getAppPackagePath();
    if (appPackagePath) {
      const zipFiles = await require("unzipper").Open.file(appPackagePath);
      let files = zipFiles.files
        .map((it) => it.path)
        .sort((a, b) => {
          let result = +b.endsWith("/" + fallbackFileName) - +a.endsWith("/" + fallbackFileName);
          if (result) return result;
          result = +b.endsWith(".js") - +a.endsWith(".js");
          if (result) return result;
          result = +b.split("/").pop().startsWith(this.projectName) - +a.split("/").pop().startsWith(this.projectName);
          if (result) return result;
          return a < b ? -1 : a === b ? 0 : 1;
        });
      fileName = files[0];
    }
    if (!fileName) fileName = `${libNameWithVendor}/${libVersion}/${fallbackFileName}`;
    let result = `${DEFAULT_GATEWAY_URI}/${betaPrefix}${fileName}`;
    return result;
  }

  _isCdnPackRequired() {
    let { type } = Package.getSingletonSync(path.join(this.projectRoot, "package.json")).templateInfo;
    return type !== "nodejs-lib" && type !== "nodejs-multi";
  }
}

module.exports = UuCloudLibraryConfig;
