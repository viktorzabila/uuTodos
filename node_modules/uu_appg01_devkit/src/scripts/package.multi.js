const path = require("path");
const fs = require("fs-extra");

const shell = require("shelljs");
const paths = require("../config/paths.js");
const helpers = require("../tools/helpers.js");
const Pack = require("uu_appg01_devkit-common/src/tools/package.js");
const { compareModificationTime } = require("../tools/helpers.js");
const { transformLegacyDescriptor } = require("./common/library-descriptor-generator.js");

let chalk;

module.exports = class Build {
  constructor(config) {
    this.config = config;
  }

  async process() {
    if (!this.config.getMode()) this.config.setMode("production");

    shell.mkdir("-p", paths.buildDir);

    let UpdateFromUuappJson = require("./update-from-uuapp-json.js");
    await new UpdateFromUuappJson(this.config).process();

    let modules = this.config.getWorkspaceLibraryList();
    console.log("Packaging projects: " + modules.map((it) => it.name).join(", "));

    // clean output directory
    let targetFolder = path.join(paths.buildDir, "package");
    fs.emptyDirSync(targetFolder);

    // wait for modules' packaging
    let parallel = false; // TODO Decide.
    let silent = parallel;
    let totalWarningCount = 0;
    if (!chalk) chalk = require("chalk");
    let processes = modules.reduce((r, it) => {
      let run = async () => {
        let { name, path: modulePath, version, pkg } = it;
        let stdout, stderr;
        try {
          ({ stdout, stderr } = await helpers.exec("npm run package -- " + this.config.toCommandLineArgs().join(" "), {
            silent,
            copyToBuffer: true,
            cwd: path.resolve(modulePath),
            env: {
              ...process.env,
              UU_APPG01_DEVKIT_SPECVC: "", // TODO Encapsulate and do for all xyz.multi.js scripts.
            },
          })); // TODO Escaping of arguments
          if (!silent) console.log("");
        } catch (e) {
          if (e && e.stdout && silent) process.stdout.write(e.stdout);
          if (e && e.stderr && silent) process.stderr.write(e.stderr);
          if (!silent) console.log("");
          console.error(`  ${chalk.red("ERROR")} ${chalk.red(name)} failed.`);
          process.exit(1); // don't wait for anything
        }

        let warningRegExp = /(^|\n\W*)W[aA][rR][nN]/;
        let warningCount = stdout.split(warningRegExp).length - 1;
        if (warningCount > 0) {
          if (silent) console.log(stdout);
          totalWarningCount += warningCount;
        }
        if (silent && stderr) console.error(stderr);

        // TODO We should build other project types into a folder containing only built files so that
        // we can copy the whole contents here. Since it's not like that now, we have to enumerate
        // which files to copy here :-/.
        let libDescriptor = `${pkg.name}-${version}-library-descriptor.json`;
        let fileMap = {
          npm: `${pkg.name}-${version}.tgz`,
          cdn: `${pkg.name}-${version}-cdn-pack.zip`,
          cdnLegacy: `${pkg.name}-${version}.zip`,
          libDescriptor: libDescriptor,
          libDescriptorLegacy: `${pkg.name}-uu5libraryregistry-${version}.json`,
        };
        for (let [k, fileName] of Object.entries(fileMap)) {
          let exists = fs.existsSync(path.join(modulePath, "target", fileName));
          fileMap[k] = exists ? path.join(modulePath, "target", fileName) : null;
        }
        if (!fileMap.cdn) fileMap.cdn = fileMap.cdnLegacy;
        delete fileMap.cdnLegacy;
        if (
          !fileMap.libDescriptor ||
          (fileMap.libDescriptorLegacy &&
            compareModificationTime(fileMap.libDescriptor, fileMap.libDescriptorLegacy) < 0)
        ) {
          fileMap.libDescriptorPreferLegacy = true; // use libDescriptorLegacy for backward compatibility (projects using postpackage stuff)
        }
        if (Object.values(fileMap).every((it) => !it)) {
          console.warn(
            `  ${chalk.yellow("WARN")} ${chalk.yellow(name)} done successfully, but yielded no files (.tgz, .zip, ...)`
          );
        } else if (warningCount > 0 || stderr) {
          console.log(
            `  ${chalk.yellow(name)} done with ${
              warningCount > 0 ? warningCount + " warning(s)" : "error/warning output"
            }`
          );
          if (!warningCount) totalWarningCount++; // consider error output as a warning too
        } else {
          console.log(`  ${chalk.green(name)} done`);
        }
        return { ...it, fileMap };
      };
      let prevPromise = r[r.length - 1];
      r.push(prevPromise && !parallel ? prevPromise.then(run) : run());
      return r;
    }, []);

    const UuCloudLibraryConfig = require("./uu_cloud/uu-cloud-library-config");
    let pack = Pack.getSingletonSync("package.json");
    let pkg = pack.get();
    let uuCloudLibraryConfig = new UuCloudLibraryConfig(
      path.resolve("."),
      pkg.name,
      pkg.version,
      paths.buildDir,
      this.config
    );

    let doneModules = await Promise.all(processes);
    doneModules.sort((a, b) => (a.name < b.name ? -1 : a.name === b.name ? 0 : 1));
    if (totalWarningCount > 0) console.log(`Done with ${chalk.yellow(totalWarningCount + " warning(s)")}.`);
    console.log("");

    // create .zip with all .tgz files
    console.log("Creating library pack with built npm packages (.tgz files).");
    const zip = require("../tools/zip.js");
    let libraryPackPath = path.join(paths.buildDir, pkg.name + "-" + pkg.version + "-library-pack.zip");
    await zip(libraryPackPath, (archive) => {
      for (let { fileMap } of doneModules) {
        if (!fileMap.npm) continue;
        archive.file(fileMap.npm, { name: path.basename(fileMap.npm) });
      }
    });
    console.log(`  ${libraryPackPath}`);

    // combine library-descriptor .json files into 1
    let libDescriptorList = [];
    for (let { fileMap, type, flsUri, slsUri, pkg } of doneModules) {
      if (!fileMap.libDescriptor && !fileMap.libDescriptorLegacy) continue;
      let json;
      if (fileMap.libDescriptorPreferLegacy) {
        json = transformLegacyDescriptor(
          require(path.resolve(fileMap.libDescriptorLegacy)),
          type,
          flsUri,
          slsUri,
          pkg.license
        );
      } else {
        json = require(path.resolve(fileMap.libDescriptor));
      }
      libDescriptorList.push(json);
    }
    if (libDescriptorList.length > 0) {
      console.log("Creating library descriptor.");
      let bestMatchLib = libDescriptorList.find(
        (it) => it.libraryList && it.libraryList.some((lib) => lib.name === pkg.name)
      );
      let libDescriptor = {
        ...(bestMatchLib || libDescriptorList[0]),
        libraryList: libDescriptorList.reduce((r, it) => r.concat(it.libraryList), []),
        componentList: libDescriptorList.reduce((r, it) => r.concat(it.componentList || []), []),
      };
      let libDescriptorPath = path.join(paths.buildDir, pkg.name + "-" + pkg.version + "-library-descriptor.json");
      fs.writeFileSync(libDescriptorPath, JSON.stringify(libDescriptor, null, 2) + "\n", "utf-8");
      console.log("  " + libDescriptorPath);
    }

    console.log("Creating uuCloud descriptor.");
    let cloudDescriptorPath = uuCloudLibraryConfig.generateCloudDescriptor();
    uuCloudLibraryConfig.updateUuSubAppDescriptor();
    console.log("  " + cloudDescriptorPath);

    // combine browser files (dist/ folders) of uu5 libs and iso libs into single one
    let cdnPackModules = doneModules.filter((it) => it.fileMap.cdn);
    if (cdnPackModules.length > 0) {
      console.log("Creating CDN pack.");
      let distDir = paths.buildLibWebDir;
      fs.emptyDirSync(distDir);
      for (let { fileMap } of cdnPackModules) {
        if (!fileMap.cdn) continue;
        await unzip(fileMap.cdn, distDir, (fileName) => fileName.split("/").slice(2).join("/"));
      }
      let projectName = pkg.name;
      let projectVersion = uuCloudLibraryConfig.getQualifiedVersion();
      let { vendor, nameNoVendor } = pack;
      let cdnPackName = vendor + "-" + nameNoVendor.replace(/_/g, "-");
      let cdnPackFile = `${projectName}-${projectVersion}-cdn-pack.zip`;
      await zip(path.join(paths.buildDir, cdnPackFile), (archive) => {
        let inZipDir = path.join(cdnPackName, projectVersion);
        archive.directory(paths.buildLibWebDir, inZipDir);
      });
      console.log(`  ${paths.buildDir}${path.sep}${cdnPackFile}`);
    }
  }
};

async function unzip(zipFile, targetDir, pathMangler) {
  // return fs
  //   .createReadStream(zipFile)
  //   .pipe(require("unzipper").Extract({ path: targetDir }))
  //   .promise();

  const zipStream = fs.createReadStream(zipFile).pipe(require("unzipper").Parse({ forceStream: true }));
  for await (const entry of zipStream) {
    const fileName = entry.path;
    let targetFileName = pathMangler ? pathMangler(fileName) : fileName;
    if (targetFileName && entry.type === "File") {
      fs.ensureDirSync(path.dirname(path.join(targetDir, targetFileName)));
      entry.pipe(fs.createWriteStream(path.join(targetDir, targetFileName)));
    } else {
      entry.autodrain();
    }
  }
}
