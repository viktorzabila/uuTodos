const path = require("path");
const fs = require("fs");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const { getCdnName } = require("../common/dependency-processor.js");

const DEFAULT_GATEWAY_URI = "https://cdn.plus4u.net";
const SCHEMA_VERSION = "1.0.0";

class LibraryDescriptorGenerator {
  constructor(
    projectRoot,
    projectName,
    projectVersion,
    targetDir,
    buildConfig,
    dependencies,
    loaderSettings,
    projectType,
    workspaceLibraries
  ) {
    this.projectRoot = projectRoot;
    this.projectName = projectName;
    this.projectVersion = projectVersion;
    this.projectType = projectType;
    this.targetDir = targetDir;
    this.dependencies = dependencies || {};
    this.loaderSettings = loaderSettings || {};
    this.buildConfig = buildConfig;
    this.isPartOfMultiLib = !!workspaceLibraries;
    this.workspaceLibraries = workspaceLibraries || [];
  }

  static transformLegacyDescriptor(legacyDescriptor, type, flsUri, slsUri, license) {
    if (!legacyDescriptor) return legacyDescriptor;
    let list = Array.isArray(legacyDescriptor) ? legacyDescriptor : [legacyDescriptor];
    let version = list[0].versionList && list[0].versionList[0] && list[0].versionList[0].version;
    let generation = parseFloat((list[0].name.match(/g(\d\d)/) || {})[1]) || 0;
    let uuApp =
      (list[0].name.startsWith(list[0].vendor + "_") ? "" : list[0].vendor + "_") + list[0].name.replace(/g\d\d.*/, "");
    let libraryList = list.map((it) => ({
      code: it.code,
      name: it.name,
      type,
      license,
      desc: it.desc,
      docUri: it.doc,
      imageUri: it.image,
      flsUri,
      slsUri,
      sourceUri: it.source ? it.source.replace(/%s/, () => version) : it.source,
      dependencyMap: (it.versionList && it.versionList[0] && it.versionList[0].dependencyMap) || it.dependencyMap,
    }));
    let descriptor = {
      schemaVersion: SCHEMA_VERSION,
      version,
      generation,
      uuApp,
      libraryList,
    };
    return descriptor;
  }

  generateLibraryDescriptor() {
    let descriptorPath = path.resolve(
      this.targetDir,
      `${this.projectName}-${this.projectVersion}-library-descriptor.json`
    );
    descriptorPath = path.relative(".", descriptorPath);

    let parsedProduct = Package.parseProduct(this.projectName);
    let { sourceUri, imageUri, docUri, namespace, description, componentList, license } = this.buildConfig.getAll();
    let isForCdn = this.projectType !== "nodejs-lib";
    let version = this.projectVersion;
    let isBeta = version.match(/[-.][a-zA-Z]/);
    if (isForCdn && sourceUri) {
      sourceUri = sourceUri.replace(/%s/, () => version);
      if (isBeta && sourceUri.startsWith(DEFAULT_GATEWAY_URI) && !sourceUri.startsWith(DEFAULT_GATEWAY_URI + "/beta")) {
        sourceUri = DEFAULT_GATEWAY_URI + "/beta" + sourceUri.slice(DEFAULT_GATEWAY_URI.length);
      }
    }
    let libraryDescriptor = {
      schemaVersion: SCHEMA_VERSION,
      version,
      generation: parseFloat((this.projectName.match(/g(\d\d)/) || {})[1]) || 0,
      uuApp:
        (parsedProduct.name.startsWith(parsedProduct.vendor + "_") ? "" : parsedProduct.vendor + "_") +
        parsedProduct.name.replace(/g\d\d.*/, ""),
      libraryList: [
        {
          code: namespace,
          name: parsedProduct.name,
          type: this.projectType,
          license,
          desc: description,
          docUri,
          imageUri,
          flsUri: this.buildConfig.get("flsUri"),
          slsUri: this.buildConfig.get("slsUri"),
          ...(isForCdn
            ? {
                sourceUri,
                dependencyMap: Object.keys(this.loaderSettings.externals || {}).reduce((depMap, depName) => {
                  let depItem = this.loaderSettings.externals[depName];
                  if (depItem && depItem.uri !== undefined) {
                    depMap[depName] = depItem.uri;
                  }
                  return depMap;
                }, {}),
              }
            : null),
        },
      ],
      componentList: !componentList
        ? undefined
        : componentList.map((it) => {
            let { docCode, tagList, code, decorationComponentName, decorationComponentProps, ...result } = it;
            if (code) result.code = code;
            if (tagList || code) result.tagList = tagList || code.split(/\./);
            if (docCode && docUri) {
              let url = new URL(docUri);
              url.searchParams.set("code", docCode);
              if (url.pathname.match(/\/book\/?$/)) url.pathname = url.pathname.replace(/(\/book)\/?$/, "$1/page");
              result.docUri = url.toString();
            }
            if (!result.libraryCode) result.libraryCode = namespace;
            return result;
          }),
    };
    if (isForCdn) this._updateLibraryRegistryDescriptor(libraryDescriptor, descriptorPath, isBeta);

    if (!this.projectVersion.match(/[-.][a-zA-Z]/)) {
      let requiredFields = ["docUri", "flsUri", "imageUri"].concat(isForCdn ? ["sourceUri"] : []);
      let emptyFields = requiredFields.filter((it) => !libraryDescriptor.libraryList[0][it]);
      if (emptyFields.length > 0) {
        let keyPrefix = this.isPartOfMultiLib ? "" : path.basename(path.resolve(".")) + ".";
        throw new Error(
          `Missing uuapp.json keys: ${emptyFields
            .map((it) => keyPrefix + it)
            .join(", ")} (required for non-beta versions).`
        );
      }
    }

    fs.writeFileSync(descriptorPath, JSON.stringify(libraryDescriptor, null, 2));
    return { descriptor: libraryDescriptor, descriptorPath };
  }

  _getDependencyInfo(name) {
    let isThisWorkspace = false;
    let version;
    if (this.workspaceLibraries.indexOf(name) !== -1) {
      version = this.projectVersion;
      isThisWorkspace = true;
    } else {
      let depPackageJsonPath = path.join(this.projectRoot, "node_modules", name, "package.json");
      if (fs.existsSync(depPackageJsonPath)) {
        let depPackageJson = JSON.parse(fs.readFileSync(depPackageJsonPath, "utf-8"));
        version = depPackageJson.version;
      } else if (name === this.projectName || name.startsWith(this.projectName + "-")) {
        version = this.projectVersion;
        isThisWorkspace = true;
      }
    }
    return { name, version, isThisWorkspace };
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  _updateLibraryRegistryDescriptor(descriptor, descriptorPath, forceWorkspaceBeta = false) {
    // TODO Integrate method directly into generateLibraryDescriptor()
    // update versions and URLs of library registry items (copied from uu5g04)
    let knownDeps = {
      [this.projectName]: {
        name: this.projectName,
        version: this.projectVersion,
        external: true,
        isThisWorkspace: true,
      },
    };
    let loaderSettingsDeps = this.loaderSettings.externals || {};
    for (let depName in this.dependencies) {
      let { isThisWorkspace, version } = this._getDependencyInfo(depName);
      knownDeps[depName] = {
        name: depName,
        version,
        external: depName in loaderSettingsDeps,
        isThisWorkspace,
      };
    }

    descriptor.libraryList.forEach((lib) => {
      // update URLs in dependencyMap
      updateDependencyMap.call(this, lib.dependencyMap, lib);
    });

    function updateDependencyMap(dependencyMap, lib) {
      if (dependencyMap) {
        for (let depLibFullName in dependencyMap) {
          let depLibUrl = dependencyMap[depLibFullName];
          let depLibNameBase = depLibFullName.split("-")[0];
          let depLibParams = knownDeps[depLibFullName] || knownDeps[depLibNameBase];

          if (!depLibUrl) {
            if (depLibParams) {
              if (!depLibParams.external) {
                throw new Error(
                  `Library ${depLibFullName} is declared as dependency for ${lib.name} in ${descriptorPath}` +
                    `but it's not marked as external dependency (listed in package.json in "uuBuildSettings.externals"),` +
                    ` i.e. it was bundled into the distribution package if it was imported somewhere in source files. Mark` +
                    ` it as external in package.json or remove it from library registry descriptor.`
                );
              }
              let cdnLibName = getCdnName(depLibFullName, true);
              let isBeta = (depLibParams.version || "").match(/[-.][a-zA-Z]/);
              // we want to use major versions in registry so that there're fewest version conflicts
              // (but not for submodules such as -bricks, etc. of this library, if this library has some)
              let depLibUsedVersion = depLibParams.version || "0.0.0";
              if (!depLibParams.isThisWorkspace) depLibUsedVersion = depLibUsedVersion.replace(/\..*/, ".0.0");
              let fileName = depLibFullName.replace(/^uu_uu5/, "uu5") + ".min.js";
              if (depLibFullName === "uu_appg01" && depLibUsedVersion.match(/^[0123]\./))
                fileName = "uu_appg01-base.min.js"; // uu_appg01 < 4.x had non-standard naming of entry file
              depLibUrl = `${DEFAULT_GATEWAY_URI}/${
                isBeta ? "beta/" : ""
              }${cdnLibName}/${depLibUsedVersion}/${fileName}`;
              if (!depLibParams.version) {
                console.warn(
                  `Library ${depLibFullName} is declared as external dependency (listed in package.json in "uuBuildSettings.externals")` +
                    `, it has no URL specified there and it's not possible to find out its version. Following URL will be used for library` +
                    ` registry:\n  ${depLibUrl}\n If the URL is wrong, specify the URL in package.json in "uuBuildSettings.externals.` +
                    `${depLibFullName}.uri" or add the library as npm dependency (npm i -S ${depLibFullName}).`
                );
              }
              dependencyMap[depLibFullName] = depLibUrl;
            } else {
              throw new Error(
                `Library ${depLibFullName} is declared as external dependency (listed in package.json in "uuBuildSettings.externals")` +
                  ` but it has no URL specified there. Specify the URL in package.json in "uuBuildSettings.externals.${depLibFullName}.uri"` +
                  ` or add the library as npm dependency (npm i -S ${depLibFullName}) to compute the URL automatically (assuming the` +
                  ` library conforms to standard UU naming conventions).`
              );
            }
          }

          if (
            forceWorkspaceBeta &&
            depLibParams &&
            depLibParams.isThisWorkspace &&
            depLibUrl.startsWith(DEFAULT_GATEWAY_URI) &&
            !depLibUrl.startsWith(DEFAULT_GATEWAY_URI + "/beta")
          ) {
            depLibUrl = DEFAULT_GATEWAY_URI + "/beta" + depLibUrl.slice(DEFAULT_GATEWAY_URI.length);
            dependencyMap[depLibFullName] = depLibUrl;
          }
        }
      }
      return dependencyMap;
    }
  }
}

module.exports = LibraryDescriptorGenerator;
