const path = require("path");
const fs = require("fs");

const babel = require("@babel/core");
const { getMemberNames, getMemberName } = require("./es6-exports-reader-util");
const Es6ExportsReaderPluginUU5 = require("./es6-exports-reader-plugin-uu5");
const Es6ExportsReaderPluginBasicTypes = require("./es6-exports-reader-plugin-basic-types");

class Es6ExportsReader {
  constructor(babelConfig, omitTypeResolution = false) {
    this._babelConfig = babelConfig;
    this._plugins = omitTypeResolution ? [] : [new Es6ExportsReaderPluginUU5(), new Es6ExportsReaderPluginBasicTypes()];
    this._getTypeFromNode = this._getTypeFromNode.bind(this);
    this._omitTypeResolution = omitTypeResolution;
    this._cache = {};
  }

  getExportsFromFile(file, { includeMeta = false } = {}) {
    let fileResolved = path.resolve(file);
    let exportsWithMeta = this._cache[fileResolved];
    if (!exportsWithMeta) {
      let newDir = path.dirname(fileResolved);
      let jsContent = fs.readFileSync(fileResolved, "utf-8");
      exportsWithMeta = this.getExportsFromJs(jsContent, newDir, { includeMeta: true });
      this._cache[fileResolved] = exportsWithMeta;
    }
    return this._getExportsByOpts(exportsWithMeta, includeMeta);
  }

  getExportsFromJs(jsContent, dir, { includeMeta = false } = {}) {
    let ast = babel.parseSync(jsContent, this._babelConfig);
    let moduleImporter = {
      getExports: this._getNestedExports.bind(this, dir),
    };
    let exportsWithMeta = this._getExportsFromAst(ast, moduleImporter);
    return this._getExportsByOpts(exportsWithMeta, includeMeta);
  }

  _getExportsByOpts(exportsWithMeta, includeMeta) {
    let result;
    if (!exportsWithMeta || includeMeta) result = exportsWithMeta;
    else if (exportsWithMeta) {
      result = {};
      for (let k in exportsWithMeta.exports) result[k] = exportsWithMeta.exports[k].type;
    }
    return result;
  }

  _getNestedExports(dir, moduleImportName, { includeMeta = false } = {}) {
    if (!moduleImportName || !moduleImportName.startsWith(".")) {
      return includeMeta ? { exports: {}, complete: false, missingSources: [] } : {}; // process only relative files, not standalone modules
    }

    let isOk = file => fs.existsSync(file) && fs.lstatSync(file).isFile();
    let file;
    if (
      !isOk((file = path.resolve(dir, moduleImportName))) &&
      (moduleImportName.endsWith(".js") || !isOk((file = path.resolve(dir, moduleImportName + ".js")))) &&
      !isOk((file = path.resolve(dir, moduleImportName, "index.js")))
    ) {
      return includeMeta
        ? {
            exports: {},
            complete: false,
            missingSources: [{ source: path.resolve(dir, moduleImportName), sourceName: moduleImportName }],
          }
        : {};
    }

    let result = this.getExportsFromFile(file, { includeMeta });
    if (includeMeta) {
      result.missingSources = result.missingSources.map((it) => (it.from ? it : { ...it, from: file }));
    }
    return result;
  }

  _getExportsFromAst(babelAst, moduleImporter) {
    let exports = {};
    let variables = {};
    let missingSources = new Set();
    let context = { exports, variables };
    let exportsComplete = true;

    let rootStatements = (babelAst.program || {}).body || [];
    rootStatements.forEach((it) => {
      if (it.type === "ExportAllDeclaration") {
        if (it.source) {
          let nested = moduleImporter.getExports(it.source.value, { includeMeta: true });
          if (nested.exports) {
            for (let [name, ex] of Object.entries(nested.exports)) {
              if (name in exports || name === "default") continue;
              let sources = ex.sources || [];
              exports[name] = { type: ex.type, sources: [it.source.value, ...sources], sourceName: name };
            }
          }
          if (!nested.complete) exportsComplete = false;
          for (let k of nested.missingSources) missingSources.add(k);
        }
      } else if (it.type === "ExportDefaultDeclaration") {
        if (it.declaration) {
          let name = getMemberName(it.declaration.id); // name can be null, e.g. `export default 123` vs. `export default function C(){}; C.propTypes={}`
          let ex = this._getTypeFromNode(it.declaration, context) || { type: "any" };
          if (name != null) variables[name] = ex;
          if (!("default" in exports)) exports["default"] = { type: ex };
        }
      } else if (it.type === "ExportNamedDeclaration") {
        if (it.declaration) {
          for (let declaration of it.declaration.declarations || [it.declaration]) {
            let { name, type } = declaration.id || {};
            if (name && type === "Identifier") {
              variables[name] = this._getTypeFromNode(declaration, context) || { type: "any" };
              if (!(name in exports)) exports[name] = { type: variables[name] };
            }
          }
        } else {
          let origExports;
          for (let specifier of it.specifiers || []) {
            let { name, type } = specifier.exported || {};
            if (name && type === "Identifier" && !(name in exports)) {
              let moduleImportName = (it.source || {}).value;
              if (moduleImportName) {
                if (!origExports) {
                  origExports = moduleImporter.getExports(moduleImportName, { includeMeta: true }).exports;
                }
                let sourceName = origExports ? (specifier.local || {}).name || name : name;
                let ex = origExports ? origExports[sourceName] : undefined;
                // NOTE Intentionally not using origExports[].sources because the set of export names is known
                // from the current statement directly.
                exports[name] = { type: (ex && ex.type) || { type: "any" }, sources: [moduleImportName], sourceName };
              } else {
                let ex = this._getTypeFromNode(specifier.local || specifier.exported, context);
                exports[name] = { type: ex || { type: "any" } };
              }
            }
          }
        }
      } else if (!this._omitTypeResolution) {
        if (it.type === "ImportDeclaration") {
          // remember imports; figure out their type lazily if needed at all
          for (let specifier of it.specifiers || []) {
            let { type } = specifier;
            let { name } = specifier.local || {};
            let moduleImportName = (it.source || {}).value;
            let originalName = type === "ImportDefaultSpecifier" ? "default" : (specifier.imported || {}).name || name;
            let resultType;
            if (name in variables) delete variables[name]; // shouldn't happen
            Object.defineProperty(variables, name, {
              configurable: true,
              enumerable: true,
              get() {
                if (!resultType) {
                  let importedExports = moduleImporter.getExports(moduleImportName) || {};
                  if (type === "ImportNamespaceSpecifier") {
                    // import * as Xyz from "..."
                    resultType = { type: "namespace", objectFields: { ...importedExports } };
                    delete resultType.objectFields["default"];
                  } else if (type === "ImportDefaultSpecifier") {
                    resultType = importedExports["default"];
                  } else if (type === "ImportSpecifier") {
                    resultType = importedExports[originalName];
                  }
                }
                return resultType;
              },
              set(value) {
                delete variables[name];
                variables[name] = value;
              },
            });
          }
        } else if (it.type === "VariableDeclaration" || it.type === "FunctionDeclaration") {
          // remember types of variables / functions
          for (let declaration of it.declarations || [it]) {
            let { name, type } = declaration.id || {};
            // type can be also "ObjectPattern" and "ArrayPattern"
            if (name && type === "Identifier") {
              let varType = this._getTypeFromNode(declaration, context);
              if (varType) variables[name] = varType;
            }
          }
        } else if (it.type === "ExpressionStatement") {
          // handle simple dot/bracket expressions such as `Tools.abc = ...` by extending type of variable 'Tools' with field 'abc'
          let { expression } = it;
          if (expression && expression.type === "AssignmentExpression" && expression.operator === "=") {
            let { left, right } = expression;
            let names = getMemberNames(left);
            if (names && names.length > 0) {
              let varType = this._getTypeFromNode(right, context) || { type: "any" };
              let rootName = names.shift();
              let curVarDesc = variables[rootName];
              while (curVarDesc && names.length > 1) {
                let namePart = names.shift();
                if (curVarDesc.type === "namespace") curVarDesc = curVarDesc.objectFields[namePart];
                else if (curVarDesc.type === "object" || curVarDesc.type === "function") {
                  let prop = (curVarDesc.properties || []).find((prop) => prop.name === namePart);
                  if (prop) curVarDesc = prop.value;
                }
              }
              if (curVarDesc && names.length === 1) {
                let propertyName = names.shift();
                if (curVarDesc.type === "namespace") curVarDesc.objectFields[propertyName] = varType;
                else if (
                  (curVarDesc.type === "object" || curVarDesc.type === "function") &&
                  !(curVarDesc.properties || []).some((prop) => prop.name === propertyName)
                ) {
                  if (!curVarDesc.properties) curVarDesc.properties = [];
                  curVarDesc.properties.push({ name: propertyName, value: varType });
                }
              } else if (names.length === 0) {
                // global variable assignment (without "var" / "let" / "const" keyword) or variable re-assignment
                variables[rootName] = varType;
              }
            }
          }
        }
      }
    });

    exports = this._postProcessExports(exports);
    return { exports, complete: exportsComplete, missingSources: [...missingSources] };
  }

  _getTypeFromNode(node, context) {
    if (!context) throw new Error("Invalid call of getTypeFromNode(node, context) - context is missing.");
    if (this._omitTypeResolution) return { type: "any" };
    for (let plugin of this._plugins) {
      if (typeof plugin.getTypeFromNode === "function") {
        let result = plugin.getTypeFromNode(node, context, this._getTypeFromNode);
        if (result != null) return result;
      }
    }
  }

  _postProcessExports(exports) {
    for (let plugin of this._plugins) {
      if (typeof plugin.postProcessExports === "function") {
        exports = plugin.postProcessExports(exports) || exports;
      }
    }
    return exports;
  }
}

module.exports = Es6ExportsReader;
