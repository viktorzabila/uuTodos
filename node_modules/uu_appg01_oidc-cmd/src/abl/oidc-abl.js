"use strict";

const { Config } = require("uu_appg01_core-utils");
const { Uri, UriBuilder } = require("uu_appg01_core-uri");
const { Validator } = require("uu_appg01_core-validation");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { ValidationHelper, UseCaseError } = require("uu_appg01_core-appserver");
const { AppClient, ApplicationError } = require("uu_appg01_core-appclient");
const { AuthenticationService } = require("uu_appg01_core-authentication");
const ClientCredentialsHandler = require("./client-credentials-handler.js");
const { UuSubAppInstance, UuAppWorkspace } = require("uu_appg01_workspace");
const Errors = require("../api/errors/oidc-errors.js");

const ASID = Config.get("asid");
const DEFAULT_PROVIDER_NAME = "oidcg02";

class OidcAbl {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.oidc.appserver.OidcAbl");
    this.validator = Validator.load();
  }

  async initOidcClient(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate("oidcInitOidcClientDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.InitOidcClient.UC_CODE}unsupportedKeys`,
      Errors.InitOidcClient.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.clientId) {
      dtoIn.clientId = dtoIn.awid;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 3
    let awid = dtoIn.awid;
    if (awid === ASID) {
      try {
        await UuSubAppInstance.get(ASID);
      } catch (e) { //A3
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppNotInitialized({ uuAppErrorMap }, { asid: ASID }, e);
        }
        throw e;
      }
    } else {
      try {
        await UuAppWorkspace.get(awid);
      } catch (e) { // A4
        if (e instanceof UseCaseError) {
          throw new Errors.InitOidcClient.AppWorkspaceNotInitialized({ uuAppErrorMap }, { awid }, e);
        }
        throw e;
      }
    }

    let clientId = dtoIn.clientId;
    // HDS 3
    if (dtoIn.clientSecret) {
      try { // try to use provided credentials and throw error if they are invalid.
        let authenticationService = AuthenticationService.get(dtoIn.providerName);
        await authenticationService._oauthClient.grantClientCredentialsToken({ client_id: clientId, client_secret: dtoIn.clientSecret })
      } catch (e) { // A5
        throw new Errors.InitOidcClient.InvalidCredentials({ uuAppErrorMap }, { clientId, providerName: dtoIn.providerName }, e);
      }

      try {
        await ClientCredentialsHandler.configureOidcClient(awid, dtoIn.providerName, clientId, { clientSecret: dtoIn.clientSecret });
      } catch (e) {
        // A12
        throw new Errors.InitOidcClient.StoringOfOidcClientConfigurationFailed({ uuAppErrorMap }, { clientId }, e);
      }
    }

    // HDS 4
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.providerName, session);
    } catch (e) {
      // A6
      throw new Errors.InitOidcClient.IntegrationNotEnabled({ uuAppErrorMap }, { providerName: dtoIn.providerName }, e);
    }

    // HDS 5
    let getClientDtoOut = null;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", { clientId });
    } catch (e) {
      // A7
      if (e instanceof ApplicationError) {
        throw new Errors.InitOidcClient.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
      }
      throw e;
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A8
      throw new Errors.InitOidcClient.OidcClientDoesNotExist({ uuAppErrorMap }, { clientId });
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS 6
    let defaultRedirectUriBuilder = UriBuilder.parse(uri);
    defaultRedirectUriBuilder.setAwid(awid);
    defaultRedirectUriBuilder.setUseCase("oidc/callback");
    defaultRedirectUriBuilder.clearParameters();
    let defaultRedirectUri = defaultRedirectUriBuilder.toUri().toString();
    let redirectUriList = oidcClient.redirectUriList || [];
    if (!redirectUriList.includes(defaultRedirectUri)) {
      redirectUriList.push(defaultRedirectUri);
    }
    if (redirectUriList.length > 16) {
      // A9
      let message = `Redirect uri list of OidcClient ${clientId} is greater than 16. Default redirect uri ${defaultRedirectUri} was not set. Use oidc/setAllowedRedirects to set required redirects.`;
      let params = { clientId, redirectUri: defaultRedirectUri };
      ValidationHelper.addWarning(uuAppErrorMap, `${Errors.InitOidcClient.UC_CODE}tooManyRedirectUris`, message, params);
      this.logger.error(message);
    } else {
      let updateClientDtoIn = { clientId, redirectUriList };
      try {
        let updateClientDtoOut = await oidcServerClient.post("oidcClient/update", updateClientDtoIn);
        oidcClient = updateClientDtoOut.oidcClient;
      } catch (e) {
        // A10
        throw new Errors.InitOidcClient.UpdateOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
      }
    }

    // HDS 7
    let setPublicKeyDtoOut = null;
    if (!dtoIn.clientSecret) {
      let keyPair = await ClientCredentialsHandler.generateClientKeyPair();
      let setPublicKeyDtoIn = { clientId, publicKey: keyPair.publicKey };
      try {
        setPublicKeyDtoOut = await oidcServerClient.post("authOidcClient/setPublicKey", setPublicKeyDtoIn);
      } catch (e) {
        // A11
        throw new Errors.InitOidcClient.RegistrationOfPublicKeyFailed({ uuAppErrorMap }, { clientId }, e);
      }

      // HDS 8
      try {
        await ClientCredentialsHandler.configureOidcClient(awid, dtoIn.providerName, clientId, { keyPair });
      } catch (e) {
        // A12
        throw new Errors.InitOidcClient.StoringOfOidcClientConfigurationFailed({ uuAppErrorMap }, { clientId }, e);
      }
    }

    // HDS 9
    return {
      clientId: oidcClient.clientId,
      credentialsId: setPublicKeyDtoOut && setPublicKeyDtoOut.credentials.id,
      publicKey: setPublicKeyDtoOut && setPublicKeyDtoOut.publicKey,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async setAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate(
      "oidcSetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.SetAllowedRedirects.UC_CODE}unsupportedKeys`,
      Errors.SetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = { providerName: dtoIn.providerName };
      throw new Errors.SetAllowedRedirects.IntegrationNotEnabled({ uuAppErrorMap }, params, e);
    }

    // HDS 3
    let clientId;
    try {
      clientId = await ClientCredentialsHandler.getClientId(dtoIn.providerName, dtoIn.awid);
    } catch (e) {
      // A4
      throw new Errors.SetAllowedRedirects.LoadingOfOidcClientConfigurationFailed({ uuAppErrorMap }, e);
    }
    if (!clientId) {
      // A5
      let params = { providerName: dtoIn.providerName };
      throw new Errors.SetAllowedRedirects.NoOidcClientConfigured({ uuAppErrorMap }, params);
    }

    // HDS 4
    let getClientDtoOut = null;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", { clientId });
    } catch (e) {
      // A6
      throw new Errors.SetAllowedRedirects.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.SetAllowedRedirects.OidcClientDoesNotExist({ uuAppErrorMap }, { clientId });
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS 5
    let redirectUriList = dtoIn.redirectUriList || oidcClient.redirectUriList || [];
    let postLogoutUriList = dtoIn.postLogoutUriList || oidcClient.postLogoutUriList || [];
    let updateClientDtoIn = { clientId };
    if (redirectUriList.length > 0) {
      updateClientDtoIn.redirectUriList = redirectUriList;
    }
    if (postLogoutUriList.length > 0) {
      updateClientDtoIn.postLogoutUriList = postLogoutUriList;
    }
    try {
      let updateClientDtoOut = await oidcServerClient.post("oidcClient/update", updateClientDtoIn);
      oidcClient = updateClientDtoOut.oidcClient;
    } catch (e) {
      // A8
      throw new Errors.SetAllowedRedirects.UpdateOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }

    // HDS6
    return {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async getAllowedRedirects(uri, dtoIn, session) {
    // HDS 1.1
    let validationResult = this.validator.validate(
      "oidcGetAllowedRedirectsDtoInType", dtoIn);

    // HDS 1.2 + A1, 1.3 + A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      `${Errors.GetAllowedRedirects.UC_CODE}unsupportedKeys`,
      Errors.GetAllowedRedirects.InvalidDtoInError
    );

    // HDS 1.4
    if (!dtoIn.awid) {
      dtoIn.awid = ASID;
    }
    if (!dtoIn.providerName) {
      dtoIn.providerName = DEFAULT_PROVIDER_NAME;
    }

    // HDS 2
    let oidcServerClient;
    try {
      oidcServerClient = await this._getOidcServerClient(dtoIn.providerName, session);
    } catch (e) {
      // A3
      let params = { providerName: dtoIn.providerName };
      throw new Errors.GetAllowedRedirects.IntegrationNotEnabled({ uuAppErrorMap }, params, e);
    }

    // HDS 3
    let clientId;
    try {
      clientId = await ClientCredentialsHandler.getClientId(dtoIn.providerName, dtoIn.awid);
    } catch (e) {
      // A4
      throw new Errors.GetAllowedRedirects.LoadingOfOidcClientConfigurationFailed({ uuAppErrorMap }, e);
    }
    if (!clientId) {
      // A5
      let params = { providerName: dtoIn.providerName };
      throw new Errors.GetAllowedRedirects.NoOidcClientConfigured({ uuAppErrorMap }, params);
    }

    // HDS 4
    let getClientDtoOut = null;
    try {
      getClientDtoOut = await oidcServerClient.get("oidcClient/get", { clientId });
    } catch (e) {
      // A6
      throw new Errors.GetAllowedRedirects.RetrievingOfOidcClientFailed({ uuAppErrorMap }, { clientId }, e);
    }
    if (!getClientDtoOut || !getClientDtoOut.oidcClient) {
      // A7
      throw new Errors.GetAllowedRedirects.OidcClientDoesNotExist({ uuAppErrorMap }, { clientId });
    }
    let oidcClient = getClientDtoOut.oidcClient;

    // HDS5
    return {
      clientId: oidcClient.clientId,
      redirectUriList: oidcClient.redirectUriList,
      postLogoutUriList: oidcClient.postLogoutUriList,
      uuAppErrorMap: uuAppErrorMap
    };
  }

  async _getOidcServerClient(providerName, session) {
    let authenticationService = AuthenticationService.get(providerName);
    let baseUri = Uri.parse(await authenticationService.getServiceUri()).getBaseUri();
    let verifySsl = Config.getBoolean(`uu_app_oidc_providers_${providerName}_verify_ssl`, false);

    let clientExecutive = Config.get(`uu_app_oidc_providers_${providerName}_client_executive`, false) || "app_identity";
    try {
      session = await AuthenticationService.authenticate(clientExecutive);
      this.logger.debug(`Logged appIdentity to configure oidc client: ${session.getIdentity().getUuIdentity()}`);
    } catch (e) {
      this.logger.warn(`Unable to login appIdentity to configure oidc client. Using current session.`, e);
    }
    let callToken;
    try {
      callToken = await session.getCallToken(baseUri, { useTokenExchange: true });
    } catch (e) {
      this.logger.warn(`Unable to perform token exchange to configure oidc client. This may be because oidcClient was already initialized and configured credentials are no longer valid. 
        Token exchange wont be performed, using token from the current session - please make sure that the callToken contains audience set to ${baseUri}.`, e);
      callToken = await session.getCallToken(baseUri, { useTokenExchange: false });
    }

    let opts = {
      baseUri: baseUri,
      headers: {
        authorization: callToken
      },
      verifySsl: verifySsl == null ? true : verifySsl
    };
    return new AppClient(opts);
  }

}

module.exports = new OidcAbl();
