"use strict";

const Path = require("path");
const Util = require("util");
const Fs = require("fs");
const fsReadFile = Util.promisify(Fs.readFile);
const {Base64, Config} = require("uu_appg01_core-utils");
const {UriBuilder} = require("uu_appg01_core-uri");
const {LoggerFactory} = require("uu_appg01_core-logging");
const {InvalidCredentials, UntrustedCredentials, AuthenticationError} = require("uu_appg01_core-authentication");
const CoreAppServer = require("uu_appg01_core-appserver");
const {AuthenticationService} = require("uu_appg01_oidc");
const {ClientCredentialsProvider} = require("uu_appg01_oidc").Internal;
const OidcAbl = require("../../abl/oidc-abl.js");
const CsrfTokenHandler = require("../../abl/csrf-token-handler.js");

const CLIENT_ACR_SCOPE = "client_acr:low";
const CALLBACK_PATH = "oidc/callback";
const SET_COOKIE_HEADER = "set-cookie";
const COOKIE_HEADER = "cookie";
const SESSION_COOKIE = "uu.app.s";
const CSRF_COOKIE = "uu.app.csrf";
const SESSION_COOKIE_VALUE = /uu\.app\.s\s*=\s*([^;]+)/;
const TOKEN_SAFETY_LEEWAY = 5;

const FRAME_OPTIONS_HEADER = "X-Frame-Options";
const FRAME_OPTIONS_VALUE = "SAMEORIGIN";
const CONTENT_POLICY_HEADER = "Content-Security-Policy";
const CONTENT_POLICY_VALUE = "frame-ancestors 'self'";

/**
 * Controller implementing endpoints for OIDC interaction.
 */
class OidcController {

  constructor() {
    this._logger = LoggerFactory.get("uuapp.oidc.appserver.OidcController");
    // autobind
    this.initOidcClient = this.initOidcClient.bind(this);
    this.setAllowedRedirects = this.setAllowedRedirects.bind(this);
    this.getAllowedRedirects = this.getAllowedRedirects.bind(this);
    this.callback = this.callback.bind(this);
    this.refresh = this.refresh.bind(this);
    this.grantCallToken = this.grantCallToken.bind(this);
    this.extendSession = this.extendSession.bind(this);
    this.logout = this.logout.bind(this);
    this.introspect = this.introspect.bind(this);
    this.getClientId = this.getClientId.bind(this);
  }

  /**
   * Initializes OidcClient (generates private/public key pair for private key JWT authentication,
   * stores public key as OidcClient credentials and updates OidcClient with default redirect uri).
   */
  async initOidcClient(ucEnv) {
    return OidcAbl.initOidcClient(ucEnv.getUri(), ucEnv.getDtoIn(), ucEnv.getSession());
  }

  /**
   * Stores set of allowed redirect uris to OidcClient registered for given AWID/ASID.
   */
  async setAllowedRedirects(ucEnv) {
    return OidcAbl.setAllowedRedirects(ucEnv.getUri(), ucEnv.getDtoIn(), ucEnv.getSession());
  }

  /**
   * Loads set of allowed redirect uris from OidcClient registered for given AWID/ASID.
   */
  async getAllowedRedirects(ucEnv) {
    return OidcAbl.getAllowedRedirects(ucEnv.getUri(), ucEnv.getDtoIn(), ucEnv.getSession());
  }

  /**
   * Returns callback HTML. In case of authorization code flow
   * also obtains access_token and stores it to cookie.
   */
  async callback(ucEnv) {
    let authorizationCode = ucEnv.getDtoIn().code;
    let response = ucEnv.getResponse();
    response.setHeader(FRAME_OPTIONS_HEADER, FRAME_OPTIONS_VALUE);
    response.setHeader(CONTENT_POLICY_HEADER, CONTENT_POLICY_VALUE);
    if (authorizationCode) {
      let uri = ucEnv.getUri();
      let dtoIn = ucEnv.getDtoIn();
      try {
        let scopePart = uri.getBaseUri().toString();
        let scope = [CLIENT_ACR_SCOPE, scopePart];
        let redirectUriCheck = this._getRedirectUri(uri).split("?")[0];
        let credentials = {code: authorizationCode, redirect_uri: redirectUriCheck};
        let session = await AuthenticationService.authenticate(credentials, scope);
        let token = session._accessToken;
        let tokenExpiresAt = session._attributes.exp - TOKEN_SAFETY_LEEWAY;
        let sessionState = dtoIn.session_state;
        let sessionExpiresAt = Number(dtoIn.session_expires_in) + Math.round(Date.now() / 1000);
        this._createSessionCookie(ucEnv, token, tokenExpiresAt, sessionState, sessionExpiresAt);
        let clientCredentials = await ClientCredentialsProvider.getClientCredentials(session.getServiceName());
        this._createCsrfCookie(ucEnv, clientCredentials, session.getId(), tokenExpiresAt);
      } catch (e) {
        this._logger.error("Unable to get access token via authorization code.", e);
        let redirectParams = {error: this._getErrorCode(e), error_description: e.message};
        let state = ucEnv.getDtoIn().state;
        if (state) {
          redirectParams.state = state;
        }
        let redirectUri = this._getRedirectUri(uri);
        redirectUri = this._addUriParameters(redirectUri, redirectParams);
        response.setStatus(302);
        response.setHeader('Location', redirectUri);
        // Delete application session (we might be in callback after refresh)
        this._deleteSessionCookie(ucEnv);
        this._deleteCsrfCookie(ucEnv);
        return null;
      }
    } else if (ucEnv.getDtoIn().error) {
      // In case of error, delete existing session
      this._deleteSessionCookie(ucEnv);
      this._deleteCsrfCookie(ucEnv);
    }
    let callback = await fsReadFile(Path.join(__dirname, "callback.html"), "utf8");
    response.setContentType("text/html");
    response.setBody(callback);
    return null;
  }

  /**
   * Refreshes access_token stored in session cookie
   * (via invocation of code based flow authorization).
   */
  async refresh(ucEnv) {
    let response = ucEnv.getResponse();
    let uri = ucEnv.getUri();
    let dtoIn = ucEnv.getDtoIn();
    let session = ucEnv.getSession();
    try {
      let scopePart = uri.getBaseUri().toString();
      let scope = [CLIENT_ACR_SCOPE, scopePart];
      let redirectUri = this._getRedirectUri(uri);
      let serviceName = session.getServiceName();
      let oauthClient = session._oauthClient;
      let clientId = await ClientCredentialsProvider.getClientId(serviceName);
      let acrValues = dtoIn.acr_values || session.getAuthenticationLevelOfAssurance();
      let authzCodeUri = await oauthClient.getAuthorizationUri("code", redirectUri, clientId, acrValues, scope);
      authzCodeUri = this._addUriParameters(authzCodeUri, uri.getParameters());
      authzCodeUri = this._addUriParameters(authzCodeUri, {prompt: "none"});
      response.setStatus(302);
      response.setHeader('Location', authzCodeUri);
    } catch (e) {
      this._logger.error("Unable to prolong session.", e);
      let redirectUri = this._getRedirectUri(uri);
      redirectUri = this._addUriParameters(redirectUri, {error: this._getErrorCode(e)});
      redirectUri = this._addUriParameters(redirectUri, {error_description: e.message});
      response.setStatus(302);
      response.setHeader('Location', redirectUri);
      // Delete application session
      this._deleteSessionCookie(ucEnv);
      this._deleteCsrfCookie(ucEnv);
    }
    return null;
  }


  /**
   * Returns new token resulting of token exchange (to be used to obtain token
   * for calling of external services via backend channel to avoid problems
   * with blocking of third-party cookies).
   */
  async grantCallToken(ucEnv) {
    let uri = ucEnv.getUri();
    let dtoIn = ucEnv.getDtoIn();
    let session = ucEnv.getSession();
    try {
      let scope = [CLIENT_ACR_SCOPE, dtoIn.scope || uri.getBaseUri().toString()];
      let credentials = await ClientCredentialsProvider.getClientCredentials(session.getServiceName());
      let token = await session.getCallToken(null, {useTokenExchange: false, excludeAuthenticationType: true});
      return await session._oauthClient.exchangeToken(token, null, credentials, scope);
    } catch (e) {
      if (e instanceof InvalidCredentials) {
        throw new CoreAppServer.InvalidCredentials("Grant token failed due to session being not valid.", e);
      } else {
        throw new CoreAppServer.AuthenticationFailure("Unable to provide token.", e);
      }
    }
  }

  /**
   * Refreshes access_token stored in session cookie (via backend channel; to be used
   * instead of "refresh" to avoid problems with blocking of third-party cookies).
   */
  async extendSession(ucEnv) {
    let uri = ucEnv.getUri();
    let sessionCookie = this._getSessionCookie(ucEnv);
    if (!sessionCookie) {
      throw new CoreAppServer.InvalidCredentials("There is no session to be extended.")
    }
    let credentials;
    let token;
    let dtoOut;
    try {
      let session = ucEnv.getSession();
      let scopePart = uri.getBaseUri().toString();
      let scope = [CLIENT_ACR_SCOPE, scopePart];
      credentials = await ClientCredentialsProvider.getClientCredentials(session.getServiceName());
      token = await session._oauthClient.exchangeToken(sessionCookie.token, null, credentials, scope);
      dtoOut = await session._oauthClient.parseToken(token.id_token, null, false, credentials);
    } catch (e) {
      if (e instanceof InvalidCredentials) {
        throw new CoreAppServer.InvalidCredentials("Extension of session failed due to session being not valid.", e);
      } else {
        throw new CoreAppServer.AuthenticationFailure("Extension of session was not successful.", e);
      }
    }
    let tokenExpiresAt = dtoOut.exp - TOKEN_SAFETY_LEEWAY;
    let sessionState = sessionCookie.sessionState;
    let sessionExpiresAt = sessionCookie.sessionExpiresAt;
    this._createSessionCookie(ucEnv, token.access_token, tokenExpiresAt, sessionState, sessionExpiresAt);
    this._createCsrfCookie(ucEnv, credentials, dtoOut.jti, tokenExpiresAt);
    dtoOut.session_info = {
      client_id: credentials.client_id,
      session_state: sessionState,
      session_expires_in: sessionExpiresAt - Math.round(Date.now() / 1000)
    }
    return dtoOut;
  }

  /**
   * Ensures revocation of authentication token, deletion of session
   * cookie and ending of session if provided by OIDC server.
   */
  async logout(ucEnv) {
    let response = ucEnv.getResponse();
    let uri = ucEnv.getUri();
    let session = ucEnv.getSession();
    let oauthClient = session._oauthClient;
    this._deleteSessionCookie(ucEnv);
    this._deleteCsrfCookie(ucEnv);
    let endSessionUri = await oauthClient.getEndSessionUri();
    let redirectUri = null;
    if (endSessionUri) {
      redirectUri = this._addUriParameters(endSessionUri, uri.getParameters());
      if (uri.getParameters().post_logout_redirect_uri && !uri.getParameters().id_token_hint) {
        let idTokenHint;
        try {
          let scope = endSessionUri.split("?")[0];
          let opts = {callTokenType: "idToken", excludeAuthenticationType: true};
          idTokenHint = await session.getCallToken(scope, opts);
          // In case we created new idToken only for logout, we have to
          // remove it from cache (because it is revoked in oidc server)
          oauthClient.listTokens((tokenKey, grantedToken) => {
            if (grantedToken.id_token == idTokenHint) {
              oauthClient.deleteToken(tokenKey);
              return false;
            }
          });
        } catch (e) {
          this._logger.warn("Unable to provide id_token_hint, using standard token.", e);
          idTokenHint = session._idToken;
        }
        if (idTokenHint) {
          redirectUri = this._addUriParameters(redirectUri, {id_token_hint: idTokenHint});
        }
      }
    } else if (uri.getParameters().post_logout_redirect_uri || uri.getParameters().redirect_uri) {
      redirectUri = uri.getParameters().post_logout_redirect_uri || uri.getParameters().redirect_uri;
    }
    if (redirectUri) {
      response.setHeader('Location', redirectUri);
      response.setStatus(302);
    } else {
      let callback = await fsReadFile(Path.join(__dirname, "callback.html"), "utf8");
      response.setContentType("text/html");
      response.setBody(callback);
    }
    try {
      await session.close();
    } catch (e) {
      this._logger.warn("Revocation of token failed.", e);
    }
    return null;
  }

  /**
   * Returns claims related to current session (which is not available
   * on frontend in case authorization code flow was used).
   */
  async introspect(ucEnv) {
    let session = ucEnv.getSession();
    let serviceName = session.getServiceName();
    let dtoOut = {...session._attributes};
    let sessionCookie = this._getSessionCookie(ucEnv);
    if (sessionCookie) {
      dtoOut.session_info = {
        client_id: await ClientCredentialsProvider.getClientId(serviceName),
        session_state: sessionCookie.sessionState,
        session_expires_in: sessionCookie.sessionExpiresAt - Math.round(Date.now() / 1000)
      }
    }
    return dtoOut;
  }

  /**
   * Returns client_id of OidcClient based on server configuration.
   */
  async getClientId(ucEnv) {
    let serviceName = ucEnv.getDtoIn().serviceName || AuthenticationService.getServiceName();
    let clientId = await ClientCredentialsProvider.getClientId(serviceName);
    return {clientId: clientId};
  }

  /**
   * Returns redirect URI based on incoming uri (and it parameters).
   * @private
   */
  _getRedirectUri(uri) {
    let callbackUri = null;
    let state = uri.getParameters().state;
    if (state) {
      state = JSON.parse(Base64.urlSafeDecode(state));
      callbackUri = state.redirectUri;
    }
    if (!callbackUri) {
      let baseUri = uri.getBaseUri();
      callbackUri = UriBuilder.parse(baseUri);
      callbackUri.setUseCase(CALLBACK_PATH);
      callbackUri = callbackUri.toString();
    }
    return callbackUri;
  }

  /**
   * Appends given parameters to URI (UriBuilder cannot be used, because
   * URI we are appending attributes to might not be valid uuURI).
   * @private
   */
  _addUriParameters(uri, params) {
    uri = `${uri}${(uri.indexOf("?") > -1) ? "&" : "?"}`;
    for (let key in (params || {})) {
      uri += `${key}=${encodeURIComponent(params[key])}&`;
    }
    return uri.slice(0, -1);
  }

  /**
   * Returns error code based on error type.
   * @private
   */
  _getErrorCode(error) {
    let code = error.code;
    if (!code) {
      switch (true) {
        case (error instanceof InvalidCredentials):
          code = "uu-appg01/authentication/invalidCredentials";
          break;
        case (error instanceof UntrustedCredentials):
          code = "uu-appg01/authentication/untrustedCredentials";
          break;
        case (error instanceof AuthenticationError):
          code = "uu-appg01/authentication/unexpectedFailure";
          break;
        default:
          code = "uu-appg01/server/internalServerError";
      }
    }
    return code;
  }

  _getSessionCookie(ucEnv) {
    let request = ucEnv.getRequest();
    let cookies = request.getHeaders()[COOKIE_HEADER];
    let sessionCookie = cookies && cookies.match(SESSION_COOKIE_VALUE);
    if (!sessionCookie) {
      return null;
    }
    let [tokenExpiresAt, token, sessionExpiresAt, sessionState, asid] = sessionCookie[1].split(".");
    tokenExpiresAt = Number(tokenExpiresAt);
    if (tokenExpiresAt * 1000 < Date.now() || Config.get("asid") !== asid) {
      return null;
    }
    token = Base64.urlSafeDecode(token);
    sessionState = Base64.urlSafeDecode(sessionState);
    sessionExpiresAt = Number(sessionExpiresAt);
    return {token, tokenExpiresAt, sessionState, sessionExpiresAt};
  }

  _getCookiePath(ucEnv) {
    if (ucEnv.getBaseUriAlias()) {
      let baseUriAlias = new URL(ucEnv.getBaseUriAlias());
      return baseUriAlias.pathname;
    } else {
      let uri = ucEnv.getUri();
      return `/${uri.getProduct()}/${uri.getWorkspace()}`;
    }
  }

  _createSessionCookie(ucEnv, token, tokenExpiresAt, sessionState, sessionExpiresAt) {
    let uri = ucEnv.getUri();
    let response = ucEnv.getResponse();
    token = Base64.urlSafeEncode(token);
    sessionState = Base64.urlSafeEncode(sessionState);
    let value = `${tokenExpiresAt}.${token}.${sessionExpiresAt}.${sessionState}.${Config.get("asid")}`;
    let path = this._getCookiePath(ucEnv);
    let secure = (uri.getScheme() === 'https');
    let cookie = `${SESSION_COOKIE}=${value};path=${path};httponly;SameSite=Strict${secure ? ";secure" : ""}`;
    this._sendCookie(cookie, response);
  }

  _createCsrfCookie(ucEnv, credentials, sessionId, expiresAt) {
    let uri = ucEnv.getUri();
    let response = ucEnv.getResponse();
    let path = this._getCookiePath(ucEnv);
    let secure = (uri.getScheme() === 'https');
    let csrfToken = CsrfTokenHandler.createCsrfToken(uri, credentials, sessionId, expiresAt);
    let cookie = `${CSRF_COOKIE}=${csrfToken};path=${path};SameSite=Lax${secure ? ";secure" : ""}`;
    this._sendCookie(cookie, response);
  }

  _deleteSessionCookie(ucEnv) {
    let uri = ucEnv.getUri();
    let response = ucEnv.getResponse();
    let path = this._getCookiePath(ucEnv);
    let secure = (uri.getScheme() === 'https');
    let cookie = `${SESSION_COOKIE}=;path=${path};httponly;SameSite=Strict${secure ? ";secure" : ""};max-age=-1`;
    this._sendCookie(cookie, response);
  }

  _deleteCsrfCookie(ucEnv) {
    let uri = ucEnv.getUri();
    let response = ucEnv.getResponse();
    let path = this._getCookiePath(ucEnv);
    let secure = (uri.getScheme() === 'https');
    let cookie = `${CSRF_COOKIE}=;path=${path};SameSite=Lax${secure ? ";secure" : ""};max-age=-1`;
    this._sendCookie(cookie, response);
  }

  _sendCookie(cookie, response) {
    let setCookieHeader = response.getHeader(SET_COOKIE_HEADER) || [];
    setCookieHeader.push(cookie);
    response.setHeader(SET_COOKIE_HEADER, setCookieHeader);
  }

}

module.exports = new OidcController();
