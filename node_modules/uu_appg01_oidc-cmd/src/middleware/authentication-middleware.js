"use strict";

const {Config, BaseError, Base64, Digest} = require("uu_appg01_core-utils");
const {LoggerMDC, LoggerFactory} = require("uu_appg01_core-logging");
const {Perflog} = require("uu_appg01_core-perflog");
const Authn = require("uu_appg01_core-authentication");
const AppServer = require("uu_appg01_core-appserver");
const {AuthenticationService, Session} = require("uu_appg01_oidc");
const CsrfTokenHandler = require("../abl/csrf-token-handler.js");

const MIDDLEWARE_ORDER = -50;

const PARAM_UNPROTECTED_REGEXP = "uu_app_authentication_unprotected_uri_regexp";
const PARAM_LOCALHOST_UNPROTECTED_REGEXP = "uu_app_authentication_localhost_unprotected_uri_regexp";
const PARAM_ANONYMOUS_LOGIN = "uu_app_authentication_anonymous_login_enabled";
const PARAM_UNPROTECTED_REGEXP_OLD = "uu_oidc_middleware_unprotected_uri_regexp";
const CALLBACK_PATH = "oidc/callback";
const CLIENT_ID_PATH = "oidc/getClientId";

const DEFAULT_UNPROTECTED_REGEXP = ".^";
const DEFAULT_LOCALHOST_UNPROTECTED_REGEXP = "/sys/getHealth(\\?|$)";

const HTTP_AUTHORIZATION_BEARER = "Bearer";
const OAUTH_ACCESS_TOKEN_PARAM = "access_token";
const SESSION_COOKE_REGEX = /uu\.app\.s=([^;,]+)/;
const CSRF_COOKIE_REGEX = /uu\.app\.csrf=([^;,]+)/;
const CSRF_HEADER = "x-csrf-token";
const CSRF_PARAM = "csrf_token";
const SET_COOKIE_HEADER = "set-cookie";
const SESSION_COOKIE = "uu.app.s";
const CSRF_COOKIE = "uu.app.csrf";
const ANONYMOUS_CREDENTIALS = {"access_code1": "anonymous", "access_code2": "anonymous"};

const STATIC_ASSET_CLASSIFIER = "(/?(?:static|assets|public)(/|$))";

class AuthenticationMiddleware {

  constructor(opts = null) {
    this.name = "AppServer Session Middleware";
    this.order = MIDDLEWARE_ORDER;
    let unprotectedRegexp = Config.get(PARAM_UNPROTECTED_REGEXP) || Config.get(PARAM_UNPROTECTED_REGEXP_OLD);
    this._unprotectedRegexp = new RegExp(unprotectedRegexp || DEFAULT_UNPROTECTED_REGEXP);
    let localhostUnprotectedRegexp = Config.get(PARAM_LOCALHOST_UNPROTECTED_REGEXP);
    this._localhostUnprotectedRegexp = new RegExp(localhostUnprotectedRegexp || DEFAULT_LOCALHOST_UNPROTECTED_REGEXP);
    this._doAnonymousLogin = Config.hasKey(PARAM_ANONYMOUS_LOGIN) ? Config.getBoolean(PARAM_ANONYMOUS_LOGIN) : true;
    this._staticClassifier = new RegExp(`^${(opts && opts.publicClassifier) || STATIC_ASSET_CLASSIFIER}`);
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationMiddleware");
  }

  async pre(req, res, next) {
    let session;
    let uri = res.locals.uri;
    if (this._unprotectedRegexp.test(req.path) || req.path.endsWith(CALLBACK_PATH) || req.path.endsWith(CLIENT_ID_PATH)
    || (uri && uri.getHostname() === "localhost" && this._localhostUnprotectedRegexp.test(uri.toString()))) {
      // log.debug { "UNPROTECTED resource=#{req.url} requested. Skip both: session creation and authentication." }
      session = Session._createEmptySession();
      AppServer.UseCaseContext.setSession(session);
      res.locals.session = session;
      return next();
    } else {
      // log.debug { "PROTECTED resource=#{req.url} requested. Prepare Session, Authenticate and Call." }
      let credentials;
      let csrfToken;
      try {
        [credentials, csrfToken] = this._getToken(req, res);
      } catch (e) {
        return next(e);
      }
      if (!credentials && this._doAnonymousLogin) {
        credentials = ANONYMOUS_CREDENTIALS;
      }
      if (credentials) {
        try {
          await Perflog.measureSection("UU_OIDC_INIT_SESSION", async section => {
            try {
              session = await AuthenticationService.authenticate(credentials, null, { allowPasswordFile: false });
            } catch (e) {
              if (e instanceof Authn.InvalidCredentials) {
                if (typeof credentials === "string") {
                  let tokenInfo;
                  if ((credentials.match(/\./g) || []).length === 2) {
                    // For id_token log only its payload
                    tokenInfo = credentials.split(".")[1];
                  } else {
                    // For access_token log sufix and whole token hash to be able to find token in db
                    tokenInfo = `${credentials.substr(credentials.length - 5)}.${Digest.sha1(credentials)}`
                  }
                  this._logger.error(`Token rejected: ${tokenInfo}`, e);
                }
                let invalidCredentials = new AppServer.InvalidCredentials(e.message, e);
                invalidCredentials.requireAuthentication("Bearer", await AuthenticationService.getServiceUri());
                invalidCredentials.headers[SET_COOKIE_HEADER] = this._getDeleteSessionCookieHeader(res);
                throw invalidCredentials;
              } else {
                throw new AppServer.AuthenticationFailure("Authentication failed.", e);
              }
            }
            if (csrfToken && !(await CsrfTokenHandler.isCsrfTokenValid(csrfToken, res.locals.uri, session))) {
              throw new AppServer.InvalidCredentials("Invalid CSRF token.");
            }
          });
        } catch (e) {
          return next(e);
        }
      } else {
        session = Session._createEmptySession();
      }

      if (session.getAuthenticationId()) {
        LoggerMDC.set("sessionId", session.getAuthenticationId());
      }
      if (session.getIdentity()) {
        LoggerMDC.set("identityId", session.getIdentity().getUuIdentity());
      }
      if (session.getApplicationIdentity()) {
        LoggerMDC.set("clientId", session.getApplicationIdentity().getCode());
      }
      AppServer.UseCaseContext.setSession(session);
      res.locals.session = session;
      return next();
    }
  }

  async onError(error, req, res, next) {
    if (error instanceof Authn.UntrustedCredentials) {
      error = new AppServer.UntrustedCredentials(error.message, error);
      error.requireAuthentication("Bearer", await AuthenticationService.getServiceUri());
    }
    return next(error);
  }

  _getToken(req, res) {
    let authToken = null;
    let csrfToken = null;
    let authHeader = req.headers.authorization;
    if (authHeader && authHeader.indexOf(`${HTTP_AUTHORIZATION_BEARER} `) == 0) {
      //Logger.debug(`Parsing ${OAUTH_ACCESS_TOKEN_PARAM} from header ${HEADER_AUTHORIZATION}="${authHeader}".`);
      authToken = authHeader.substr(7);
    }
    if (!authToken) {
      //Logger.debug(`Header ${HEADER_AUTHORIZATION} not found, try to use parameter ${OAUTH_ACCESS_TOKEN_PARAM}.`);
      authToken = (req.body && req.body[OAUTH_ACCESS_TOKEN_PARAM]) || (req.query && req.query[OAUTH_ACCESS_TOKEN_PARAM]);
    }
    if (!authToken) {
      //Logger.debug(`Parameter ${OAUTH_ACCESS_TOKEN_PARAM} not found, trying session cookie.`);
      let cookies = req.headers.cookie;
      let match = null;
      if (cookies && (match = cookies.toString().match(SESSION_COOKE_REGEX))) {
        let sessionCookie = match[1];
        let [tokenExpiresAt, encToken, sessionExpiresIn, sessionState, asid] = sessionCookie.split('.');
        if (tokenExpiresAt * 1000 > Date.now() && Config.get("asid") === asid) {
          let requestCsrfToken = req.headers[CSRF_HEADER];
          if (!requestCsrfToken) {
            requestCsrfToken = (req.body && req.body[CSRF_PARAM]) || (req.query && req.query[CSRF_PARAM]);
          }
          if (requestCsrfToken) {
            let cookieCsrfToken = (CSRF_COOKIE_REGEX.exec(cookies.toString()) || [])[1];
            if (requestCsrfToken !== cookieCsrfToken) {
              throw new AppServer.InvalidCredentials("Invalid CSRF token.");
            }
            authToken = Base64.urlSafeDecode(encToken);
            csrfToken = requestCsrfToken;
          }
        }
      }
    }
    return [authToken, csrfToken];
  }

  _getCookiePath(res) {
    if (res.locals.baseUriAlias) {
      let baseUriAlias = new URL(res.locals.baseUriAlias);
      return baseUriAlias.pathname;
    } else {
      let uri = res.locals.uri;
      return `/${uri.getProduct()}/${uri.getWorkspace()}`;
    }
  }

  _getDeleteSessionCookieHeader(res) {
    let uri = res.locals.uri;
    let path = this._getCookiePath(res);
    let secure = (uri.getScheme() === 'https');
    let setCookies = [
      `${SESSION_COOKIE}=;path=${path};httponly;SameSite=Strict${secure ? ";secure" : ""};max-age=-1`,
      `${CSRF_COOKIE}=;path=${path};SameSite=Strict${secure ? ";secure" : ""};max-age=-1`
    ]
    return setCookies;
  }

}

module.exports = AuthenticationMiddleware;
