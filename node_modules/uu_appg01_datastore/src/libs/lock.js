const { BaseError } = require("uu_appg01_core-utils");
const crypto = require("crypto");

/**
 *  Class representing Lock for locking objects in database
 */
class Lock {
  /**
   * constructor of the Lock
   * @param lockCode {string}
   * @param duration {number}
   */
  constructor(lockCode, duration = 60) {
    this.key = this._generateKey();
    this.lockCode = lockCode;
    this.hash = this._createHashSha1(this.lockCode, this.key);

    let t = new Date();
    t.setSeconds(t.getSeconds() + duration);
    this.expiration = t;
    this.lockedObjects = {};
    this.valid = true;

    this._ExpiredLock = null;
  }

  /**
   * Extends expiration by duration.
   * @param duration {number}
   * @returns {Promise<void>}
   */
  async extendExpiration(duration = 60) {
    this._checkIfValid();

    let t = this.expiration;
    t.setSeconds(t.getSeconds() + duration);
    this.expiration = t;

    let promises = Array.from(Object.keys(this.lockedObjects)).map(async (key) => {
      await this.lockedObjects[key]._extendLock(this);
    });
    await Promise.all(promises);
  }

  /**
   * Set expiration to a duration since actual moment.
   * @param duration {number}
   * @returns {Promise<void>}
   */
  async setExpiration(duration = 60) {
    this._checkIfValid();

    let t = new Date();
    t.setSeconds(t.getSeconds() + duration);
    this.expiration = t;

    let promises = Array.from(Object.keys(this.lockedObjects)).map(async (key) => {
      await this.lockedObjects[key]._extendLock(this);
    });
    await Promise.all(promises);
  }

  /**
   * check if Lock is valid
   * @returns {boolean}
   */
  isValid() {
    return this.expiration > new Date();
  }

  /**
   * unlock all locked objects
   */
  async unlockAll() {
    this._checkIfValid();

    let promises = Array.from(Object.keys(this.lockedObjects)).map(async (key) => {
      await this.lockedObjects[key]._unlock(this);
    });
    await Promise.all(promises);

    this.lockedObjects = {};
  }

  /**
   * add object to this.lockedObjects
   * @param object {object}
   * @param dao {object} custom dao object
   */
  addObject(object, dao) {
    let key = `${dao._getUri()}:${object["awid"]}:${object.id.toString()}`;
    this.lockedObjects[key] = dao;
  }

  /**
   * remove object from this.lockedObjects
   * @param object {object}
   * @param dao {object} custom dao object
   */
  removeObject(object, dao) {
    let key = `${dao._getUri()}:${object["awid"]}:${object.id.toString()}`;
    delete this.lockedObjects[key];
  }

  /**
   * convert lock to hash result
   * @returns {{lockCode: (string|*), key: *, expiration: (Date|*), lockedObjects: *}}
   */
  toHash() {
    return {
      lockCode: this.lockCode,
      key: this.key,
      expiration: this.expiration,
      lockedObjects: this.lockedObjects,
    };
  }

  /**
   * generate random key for lock
   * @returns {*}
   */
  _generateKey() {
    crypto.randomBytes(24).toString("hex");
  }

  /**
   * create hash for lock
   * @param lockCode {string}
   * @param key {string}
   * @returns {*}
   */
  _createHashSha1(lockCode, key) {
    let s = `${lockCode}:${key}`;
    let sha = crypto.createHash("sha1");
    sha.update(s);
    let ret = sha.digest("base64");
    return ret;
  }

  _checkIfValid() {
    if (!this.isValid()) {
      if (this._ExpiredLock) {
        throw new this._ExpiredLock();
      } else {
        throw new BaseError("UuObject lock expired.");
      }
    }
  }
}

module.exports = Lock;
