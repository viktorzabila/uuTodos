const { ObjectId } = require("mongodb");
const Sizeof = require("object-sizeof");
const Lock = require("../src/libs/lock");

const DbConnection = require("./libs/db-connection");

// A step (in percent) after which the current number of instances is recalculated.
const STEP = 10;
const DEFAULT_MAX_NOI = 100_000_000;
const DEFAULT_MAX_SOI = 16_000_000;

class UuDataStoreDao {
  constructor(name, maxNoi, maxSoi, customUri, connectionOpts = {}) {
    this.collectionName = name;
    this.maxSoi = maxSoi || DEFAULT_MAX_SOI;
    this.maxNoi = maxNoi == null ? DEFAULT_MAX_NOI : maxNoi; // 0 ~ unlimited
    this.defaultPageSize = 1000;
    this.noiCounts = {};
    this.customUri = customUri;
    DbConnection.init(customUri, connectionOpts);

    this._createDefaultIndexes();
  }

  /**
   * find stored object by filter in database
   * @async
   * @param filter {object}
   * @param projection {object}
   * @returns {Promise.<TResult>} object
   */
  async findOne(filter, projection = {}, sort = {}) {
    filter = this._convertId(filter);
    return await this._findWrapper(filter, { projection }, 0, sort, 1).then((result) => {
      if (result.length < 1) {
        return null;
      } else {
        return result[0];
      }
    });
  }

  /**
   * find array of objects matching given query
   * @async
   * @param filter {object}
   * @param pageInfo {object}
   * @param sort {object}
   * @param projection {object}
   * @returns {Promise.<TResult>} array of objects or empty array
   */
  async find(filter, pageInfo = {}, sort = {}, projection = {}) {
    filter = this._convertId(filter);

    let pageIndex = pageInfo["pageIndex"] ? pageInfo["pageIndex"] : 0;
    let pageSize = pageInfo["pageSize"] ? pageInfo["pageSize"] : this.defaultPageSize;

    try {
      let totalCount = await this.count(filter);

      return await this._findWrapper(filter, { projection }, pageIndex * pageSize, sort, pageSize).then((result) => {
        if (result.code) {
          return result;
        } else {
          return {
            itemList: result,
            pageInfo: {
              pageIndex: pageIndex,
              pageSize: pageSize,
              total: totalCount,
            },
          };
        }
      });
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  /**
   * get item list of distinct values for specified filed
   * @async
   * @param fieldName {string} name of filed
   * @param filter {object}
   * @returns {Promise.<{itemList: T}>} object with array of distinct values
   */
  async distinct(fieldName, filter = null) {
    if (fieldName === "id") {
      fieldName = "_id";
    }
    let db = await DbConnection.get(this.customUri);
    let result = await db
      .collection(this.collectionName)
      .distinct(fieldName, filter)
      .catch((e) => {
        throw new this.Errors.UnexpectedError(e);
      });
    return { itemList: result };
  }

  /**
   * get count of objects in the collection
   * @param filter {object}
   * @returns {Promise.<TResult>} integer count of matching objects
   */
  async count(filter) {
    try {
      let db = await DbConnection.get(this.customUri);
      return await db
        .collection(this.collectionName)
        .countDocuments(filter)
        .then((result) => {
          return result;
        });
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  /**
   * create index on specific object atributes
   * @async
   * @param keys {object} of fields name/directories pairs
   * @param opts {object} options for this index
   * @returns {Promise.<void>}
   */
  async createIndex(keys, opts = {}) {
    let db = await DbConnection.get(this.customUri);
    await db
      .collection(this.collectionName)
      .createIndex(keys, opts)
      .catch((e) => {
        throw new this.Errors.UnexpectedError(e);
      });
  }

  /**
   * Creates default indexes.
   * Method is started during dao initialization to ensure every collection will contain these indexes.
   * @return {Promise<void>}
   * @private
   */
  async _createDefaultIndexes() {
    try {
      await this.createIndex({ "sys.lockHash": 1 }, { partialFilterExpression: { "sys.lockHash": { $exists: true } } });
    } catch (e) {
      // Do not throw error if db connection is closed. It is handled by other way.
      // TODO: should be implemented better with sync dao initialization
      if (
        !e.cause ||
        !(
          e.cause.message == "server instance pool was destroyed" ||
          e.cause.message == "topology was destroyed" ||
          e.cause.message.match(/illegal state transition/)
        )
      ) {
        throw e;
      }
    }
  }

  /**
   * return array of existing indexes
   * @async
   * @returns {Promise.<{itemList: T}>}
   * */
  async getIndexes() {
    let db = await DbConnection.get(this.customUri);
    let result = await db
      .collection(this.collectionName)
      .listIndexes()
      .toArray()
      .catch((e) => {
        throw new this.Errors.UnexpectedError(e);
      });
    return { itemList: result };
  }

  /**
   * drops the index by its name
   * @async
   * @param name {string} name og the index
   * @returns {Promise.<void>}
   */

  async dropIndex(name) {
    let db = await DbConnection.get(this.customUri);
    await db
      .collection(this.collectionName)
      .dropIndex(name)
      .catch((e) => {
        throw new this.Errors.UnexpectedError(e);
      });
  }

  /**
   * lock first matching object
   * @async
   * @param filter {object} to match target document
   * @param lock {Lock}
   * @returns {Promise.<TResult>} locked object
   */
  async lockOne(filter, lock) {
    let self = this;
    filter = this._convertId(filter);

    if (!lock.isValid()) {
      throw new this.Errors.ExpiredLock();
    }

    let resultObject = await this._findWrapper(filter).catch((e) => {
      throw new this.Errors.UnexpectedError(e);
    });

    if (resultObject.length > 0) {
      let lockFilter = {
        $and: [filter],
      };
      let lockPart = {
        $or: [
          {
            "sys.lockHash": {
              $exists: false,
            },
          },
          {
            "sys.lockHash": {
              $exists: true,
            },
            "sys.lockExpTs": {
              $lt: new Date(),
            },
          },
        ],
      };
      lockFilter["$and"].push(lockPart);

      let update = {
        $set: {
          "sys.lockHash": lock.hash,
          "sys.lockExpTs": lock.expiration,
        },
      };

      let db = await DbConnection.get(this.customUri);
      return await db
        .collection(this.collectionName)
        .findOneAndUpdate(lockFilter, update, { returnDocument: "after" })
        .then((result) => {
          if (result.value === null) {
            throw new this.Errors.ObjectLocked();
          } else {
            let lockedObject = self._convertToId(result.value);
            lock.addObject(lockedObject, self);
            return lockedObject;
          }
        })
        .catch((e) => {
          if (e.message.match(/^E1100[01]/)) {
            throw new this.Errors.DuplicateKey(e);
          } else if (e.code.match("/objectLocked")) {
            throw new this.Errors.ObjectLocked();
          } else {
            throw new this.Errors.UnexpectedError(e);
          }
        });
    } else {
      throw new this.Errors.ObjectNotFound();
    }
  }

  /**
   * unlock first matching document
   * @async
   * @param filter {object}
   * @param lock {Lock}
   * @returns {Promise.<TResult>} unlocked object
   */
  async unlockOne(filter, lock) {
    let self = this;
    if (!(lock instanceof Lock)) {
      throw new this.Errors.LockDoesNotExist();
    } else {
      if (!lock.isValid()) {
        throw new this.Errors.ExpiredLock();
      }

      filter = this._convertId(filter);
      Object.assign(filter, { "sys.lockHash": lock.hash }); // , "sys.lockExpTs": {"$gt": new Date() }
      try {
        let db = await DbConnection.get(this.customUri);
        let unlockEdit = {
          $unset: {
            "sys.lockHash": "",
            "sys.lockExpTs": "",
          },
        };
        return await db
          .collection(this.collectionName)
          .findOneAndUpdate(filter, unlockEdit, { returnDocument: "after" })
          .then((result) => {
            if (result.value === null) {
              return this._findWrapper(filter).then((result) => {
                return self._convertToId(result);
              });
            } else {
              let unlockedObject = self._convertToId(result.value);
              lock.removeObject(unlockedObject, self);
              return unlockedObject;
            }
          });
      } catch (e) {
        throw new this.Errors.UnexpectedError(e);
      }
    }
  }

  getExtraAttributes() {
    return this._extraAttrs || {};
  }

  /**
   * perform an aggregation on the collection entries
   * @async
   * @param pipeline {array} array of objects for pipelining
   * @param opts {object} object with options
   * @returns {Promise.<TResult>}
   */
  async aggregate(pipeline, opts = {}) {
    let db = await DbConnection.get(this.customUri);
    return await db
      .collection(this.collectionName)
      .aggregate(pipeline, opts)
      .toArray()
      .then((res) => {
        return res;
      })
      .catch((e) => {
        throw new this.Errors.UnexpectedError(e);
      });
  }

  /**
   * unlock all documents locked by target key
   * @async
   * @param lock {Lock}
   * @returns {Promise.<TResult>}
   * @private
   */
  async _unlock(lock) {
    let self = this;
    let filter = {
      "sys.lockHash": lock.hash,
    };
    try {
      let db = await DbConnection.get(this.customUri);
      let unlockEdit = {
        $unset: {
          "sys.lockHash": "",
          "sys.lockExpTs": "",
        },
      };
      return await db
        .collection(this.collectionName)
        .updateMany(filter, unlockEdit)
        .then((result) => {
          return self._convertToId(result.result);
        });
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  /**
   * extend documents locked by target key
   * @async
   * @param lock {Lock}
   * @returns {Promise.<void>}
   * @private
   */
  async _extendLock(lock) {
    let filter = {
      "sys.lockHash": lock.hash,
    };
    try {
      let db = await DbConnection.get(this.customUri);
      let extendEdit = {
        $set: {
          "sys.lockExpTs": lock.expiration,
        },
      };
      await db.collection(this.collectionName).updateMany(filter, extendEdit);
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  /**
   * check if size of object is not bigger than allowed
   * @param uuObject {object}
   */
  _checkSoi(uuObject) {
    let estimatedSize = Sizeof(uuObject);
    if (estimatedSize > this.maxSoi) {
      throw new this.Errors.SoiExceeded(
        null,
        `The size ${estimatedSize} is bigger than maximal allowed byte size ${this.maxSoi}`
      );
    }
  }

  /**
   * check current count of instances
   * @param change {integer}
   * @param awid {string}
   * @returns {Promise.<boolean>}
   */
  async _checkCurrentNoiBefore(change, awid) {
    if (!this.maxNoi) {
      return true;
    }

    if (this.noiCounts[awid] === undefined || this._isNoiExceeded(awid, change)) {
      await this._countNoi(awid);
    }

    if (this._isNoiExceeded(awid, change)) {
      return false;
    } else {
      return true;
    }
  }

  _isNoiExceeded(awid, change) {
    return this.noiCounts[awid] + change > this.maxNoi;
  }

  /**
   * recalculate current count of instances in database
   * @async
   * @param change {integer}
   * @param awid {string}
   */
  async _recalculateCurrentNoiAfter(change, awid) {
    if (!this.maxNoi) return;
    if (this.noiCounts[awid] === undefined) await this._countNoi(awid);

    // the weird ~~ is one of the ways to do integral division in this wonderfull language
    let actualStep = Math.max(~~((this.maxNoi - this.noiCounts[awid]) / STEP), 1);
    let before = this.noiCounts[awid];
    this.noiCounts[awid] += change;
    let stepsBefore = ~~(before / actualStep);
    let stepsAfter = ~~(this.noiCounts[awid] / actualStep);

    if (stepsBefore < stepsAfter || this.maxNoi - this.noiCounts[awid] < 10) {
      this._countNoi(awid);
    }
  }

  async _countNoi(awid) {
    let countData;
    try {
      countData = await this.count({ awid: awid });
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }

    this.noiCounts[awid] = countData;
  }

  /**
   * convert id of object from string to ObjectId
   * @param object {object} to be transformed
   * @returns {*}
   */
  _convertId(object) {
    // eslint-disable-next-line no-prototype-builtins
    if (object.hasOwnProperty("_id")) {
      let id = object["_id"];
      delete object["_id"];
      delete object["id"];

      if (ObjectId.isValid(id)) {
        id = new ObjectId(id);
        object["_id"] = id;
      } else {
        object["_id"] = id;
      }
      return object;
      // eslint-disable-next-line no-prototype-builtins
    } else if (object.hasOwnProperty("id")) {
      let id = object["id"];
      delete object["_id"];
      delete object["id"];

      if (ObjectId.isValid(id)) {
        id = new ObjectId(id);
        object["_id"] = id;
      } else {
        object["_id"] = id;
      }
      return object;
    } else {
      return object;
    }
  }

  _convertToId(obj) {
    let result = [];
    if (obj.constructor === Array) {
      obj.forEach(function (element) {
        // eslint-disable-next-line no-prototype-builtins
        if (element.hasOwnProperty("_id")) {
          let id = element["_id"];
          delete element["_id"];

          element["id"] = id;
          result.push(element);
        } else {
          result.push(element);
        }
      });
    } else {
      result = {};
      // eslint-disable-next-line no-prototype-builtins
      if (obj.hasOwnProperty("_id")) {
        let id = obj["_id"];
        delete obj["_id"];

        obj["id"] = id;
        result = obj;
      } else {
        result = obj;
      }
    }
    return result;
  }

  /**
   * wrapper for find operation
   * @async
   * @param filter {object}
   * @param options {object}
   * @param skip {integer}
   * @param sort {object}
   * @param limit integer
   * @returns {Promise.<TResult>}
   */
  async _findWrapper(filter, options, skip = 0, sort = {}, limit = 0) {
    let self = this;
    try {
      let db = await DbConnection.get(this.customUri);
      return await db
        .collection(self.collectionName)
        .find(filter, options)
        .skip(skip)
        .sort(sort)
        .limit(limit)
        .toArray()
        .then((result) => {
          return self._convertToId(result);
        });
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  async _dropCollection(name = this.collectionName) {
    let db = await DbConnection.get(this.customUri);
    try {
      await db.collection(name).drop();
    } catch (e) {
      throw new this.Errors.UnexpectedError(e);
    }
  }

  _createStamps() {
    let stamps = {};
    let now = new Date();
    stamps["cts"] = now;
    stamps["mts"] = now;
    stamps["rev"] = 0;
    return stamps;
  }

  /**
   * close database
   * @returns {Promise.<void>}
   * @private
   */
  async closeDB() {
    let dbClient = await DbConnection.getDbClient(this.customUri);
    return dbClient.close();
  }

  /**
   * return customUri
   * @returns {*}
   * @private
   */
  _getUri() {
    return this.customUri;
  }
}

module.exports = UuDataStoreDao;
