"use strict";

const { UuObjectDao } = require("uu_appg01_objectstore");
const { DbConnection } = require("uu_appg01_datastore");
const { ObjectId } = require("mongodb");

class SysAuditLogRecordMongo extends UuObjectDao {
  async createSchema() {
    await super.createIndex({ awid: 1, logTime: 1 }, { background: true });
  }

  async create(uuObject) {
    return await super.insertOne(uuObject);
  }

  async listByTime(awid, timeFrom, timeTo, pageInfo) {
    let filter = this._buildAwidLogTimeQuery(awid, timeFrom, timeTo);

    return await super.find(filter, pageInfo, { logTime: 1 }, { sys: 0 });
  }

  async deleteBeforeTime(awid, toTime) {
    let filter = {
      awid,
      $or: [
        {
          logTime: { $lt: toTime }
        },
        {
          logTime: { $lt: toTime.toISOString() }
        }
      ]
    };

    return await super.deleteMany(filter);
  }

  async getCount() {
    return await super.count({});
  }

  async listLogsToTransfer(latestTransferredLogId, pageInfo) {
    const filter = latestTransferredLogId ? { _id: { $gt: latestTransferredLogId } } : {};
    return await super.find(filter, pageInfo, { _id: 1 });
  }

  async countLogsToTransfer(latestTransferredLogId) {
    const filter = latestTransferredLogId ? { _id: { $gt: latestTransferredLogId } } : {};
    return await super.count(filter);
  }

  async findLatestLogIdToPrune(minCount) {
    let db = await DbConnection.get(this.customUri);
    let collection = await db.collection(this.collectionName);
    let sort = { _id: -1 };
    let cursor = await collection.find().sort(sort).limit(minCount).skip(minCount - 1);
    let lastRecord = null;
    if ((await cursor.hasNext()) && (lastRecord = await cursor.next())) {
      cursor.close();
      return lastRecord._id;
    } else {
      // We were over limit, but no barrier record was returned - no problem, there was
      // probably another pruning initiated from another node
      cursor.close();
      return null;
    }
  }

  async countOlder(id) {
    let filter = {
      _id: { $lt: id }
    }
    return await super.count(filter);
  }

  async prune(latestLogIdToPrune) {
    let db = await DbConnection.get(this.customUri);
    let collection = await db.collection(this.collectionName);
    await collection.deleteMany({ _id: { $lt: latestLogIdToPrune } }, { writeConcern: { w: 0 } });
  }

  _buildAwidLogTimeQuery(awid, timeFrom, timeTo) {
    let filter = { awid };

    if (timeFrom || timeTo) {
      filter["$and"] = [];
    }

    if (timeFrom) {
      filter["$and"].push({
        $or: [
          {
            // for backward compatibility -> logTime was stored as a String in uuAppAuditLog v1.0.x
            logTime: { $gte: timeFrom }
          },
          {
            logTime: { $gte: timeFrom.toISOString() }
          }
        ]
      });
    }

    if (timeTo) {
      filter["$and"].push({
        $or: [
          {
            logTime: { $lte: timeTo }
          },
          {
            logTime: { $lte: timeTo.toISOString() }
          }
        ]
      });
    }

    return filter;
  }
}

module.exports = SysAuditLogRecordMongo;
