"use strict";

const { UseCaseContext, ValidationHelper, ErrorConverter } = require("uu_appg01_core-appserver");
const { Validator } = require("uu_appg01_core-validation");
const { DaoFactory, Lock, ObjectLocked } = require("uu_appg01_objectstore");
const { Config } = require("uu_appg01_core-utils");
const { LoggerFactory } = require("uu_appg01_core-logging");
const LogStoreClient = require("../log-store-client");

const Errors = require("../api/errors/sys-auditlog-error.js");

const WARNINGS = {
  createAuditLogRecord: {
    unsupportedKeys: {
      code: `${Errors.CreateAuditLogRecord.UC_CODE}unsupportedKeys`
    }
  },
  deleteBeforeTime: {
    unsupportedKeys: {
      code: `${Errors.DeleteBeforeTime.UC_CODE}unsupportedKeys`
    }
  },
  logRecordList: {
    unsupportedKeys: {
      code: `${Errors.LogRecordList.UC_CODE}unsupportedKeys`
    }
  },
  transfer: {
    transferHasAlreadyStarted: {
      code: `${Errors.LogRecordTransfer.UC_CODE}transferHasAlreadyStarted`,
      message: "The transfer has already started."
    }
  }
};
const DEFAULT_PAGE_INFO = {
  pageIndex: 0,
  pageSize: 1000
};
const ENV_NODE_NAME = "UU_CLOUD_NODE_NAME";
const PRUNE_POLICY_TRANSFERRED_LOGS_ONLY = "transferredLogsOnly";
const TRANSFER_STATES = {
  running: "running",
  completed: "completed",
  completedWithError: "completedWithError"
}

class SysAuditLogAbl {

  constructor() {
    this.logger = LoggerFactory.get("uuapp.auditlog.SysAuditLogAbl");
    this.validator = Validator.load();
    this.asid = Config.get("asid");
    this.dao = DaoFactory.getDao("sysAuditLogRecord");
    this.configDao = DaoFactory.getDao("sysAuditLogConfig");
    this.recordsWritten = 0;
    this.maxRecordCount = Config.get("uu_app_auditlog_max_record_count");
    if (this.maxRecordCount == null) {
      this.maxRecordCount = Config.get("uu_app_auditlog_record_count_limit");
    }
    this.recordLimitCheckAfter = Config.get("uu_app_auditlog_record_limit_check_after");
    this.nodeName = process.env[ENV_NODE_NAME];
    this.prunePolicy = Config.get("uu_app_auditlog_prune_policy");
    this.pruneLockTtl = Config.get("uu_app_auditlog_prune_lock_ttl")
    if (!this.pruneLockTtl) {
      this.pruneLockTtl = 5
    }
    this.recordPruneEnabled = this.maxRecordCount != null && this.maxRecordCount > 0 &&
      this.recordLimitCheckAfter != null && this.recordLimitCheckAfter > 0;
    if (this.recordPruneEnabled) {
      this.minRecordCount = Config.get("uu_app_auditlog_min_record_count");
      if (this.minRecordCount == null || this.minRecordCount < 0 || this.minRecordCount > this.maxRecordCount) {
        this.minRecordCount = this.maxRecordCount;
      }
      this.logger.info(
        `AuditLog Records prune configured. minRecordCount ${this.minRecordCount}, maxRecordCount ${this.maxRecordCount}, recordLimitCheckAfter ${this.recordLimitCheckAfter}, pruneLockTtl ${this.pruneLockTtl}`);
    } else {
      this.logger.warn(
        "UU.APP.AUDITLOG/CONFIG_EXPECTED: The uuAuditLog storage retency is not configured (maxRecordCount, minRecordCount, recordLimitCheckAfter), beware of database overflow! See documentation for details.");
    }

    this.appLogStoreUri = Config.get("uu_app_auditlog_app_logstore_uri");
    this.appLogStoreTransferAfterCount = Config.get("uu_app_auditlog_app_logstore_transfer_after_count");
    if (!this.appLogStoreTransferAfterCount || this.appLogStoreTransferAfterCount < 0) {
      this.appLogStoreTransferAfterCount = 1000;
    }
    this.appLogStoreNotTransferedCount = 0;
    this.appLogStoreLastTransferDate = new Date();
    this.appLogStoreTransferAfterTime = Config.get("uu_app_auditlog_app_logstore_transfer_after_time");
    if (!this.appLogStoreTransferAfterTime) {
      this.appLogStoreTransferAfterTime = 60;
    } else if (this.appLogStoreTransferAfterTime < 5) {
      this.appLogStoreTransferAfterTime = 5
    }
  }

  async createAuditLogRecord(dtoIn) {
    // HDS 1 Performs a logical check of dtoIn
    // HDS 1.1
    let validationResult = this.validator.validate("createDtoInSchemaType", dtoIn);
    // HDS 1.2, A1, A2
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.createAuditLogRecord.unsupportedKeys.code,
      Errors.CreateAuditLogRecord.InvalidDtoIn
    );

    let uri = UseCaseContext.getUri();
    let awid = uri.getAwid();
    let customSession = UseCaseContext.getSession();
    let requestId = UseCaseContext.getRequestId();
    let date = new Date();

    // HDS 2 Creates sysAuditLogRecord uuObject containing dtoIn parameters and other necessary attributes according to its uuSchema
    let auditLogRecord = {
      awid: awid,
      spp: uri.getSpp() || "",
      useCase: uri.getUseCase(),
      requestId: requestId,
      sid: customSession.getAuthenticationId(),
      logTime: date,
      severity: dtoIn.severity,
      eventTypeCode: dtoIn.eventTypeCode,
      message: dtoIn.message,
      parameters: dtoIn.parameters
    };
    const identity = customSession.getIdentity();
    if (identity) {
      auditLogRecord.identity = identity.getUuIdentity();
      auditLogRecord.identityName = identity.getName();
      auditLogRecord.identityType = identity.getType();
    }

    let dtoOut = await this.dao.create(auditLogRecord);

    // HDS 3 Checks if log transfer to the uuAppLogStore is enabled
    if (this.appLogStoreUri) {
      // HDS 4 Increments locally stored counter for non-transfered logs
      this.appLogStoreNotTransferedCount++;
      try {
        if (this.appLogStoreNotTransferedCount >= this.appLogStoreTransferAfterCount) { // auditLog count condition filled
          // HDS 6 Transfers records to the uuAppLogStore - calls sys/logRecord/transfer command
          await this.transfer(uuAppErrorMap);
        } else if (this._checkTimeTransferCondition(this.appLogStoreLastTransferDate)) { // check time condition
          await this.transfer(uuAppErrorMap, true);
        }
      } catch (e) {
        this.logger.error(`Failed to call sys/logRecord/transfer command.`, e);
      }
    }

    // HDS 7 Checks that recordLimit and recordLimitCheckAfter are set in the configuration
    if (this.recordPruneEnabled) {
      // HDS 8 Increments recordsWritten variable
      this.recordsWritten += 1;
      // HDS 9 If recordsWritten >= recordLimitCheckAfter, then
      if (this.recordsWritten >= this.recordLimitCheckAfter) {
        // HDS 10 Resets recordsWritten to zero
        this.recordsWritten = 0;
        this.logger.debug("uuAppAuditLog prune started.");
        try {
          await this._pruneAuditLogRecords();
        } catch (e) {
          this.logger.error("Pruning of old uuAuditLog records failed.", e);
        }
      }
    }

    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *  Returns the information about the last log transfer. It returns date, state and number of records to be transferred.
   *
   * @return {object} filled dtoOut object
   */
  async getTransferStatus() {
    // HDS 1 System loads sysAuditLogConfig uuObject
    let asidAuditLogConfig = await this.configDao.getByAwid(this.asid) || null;
    if (!asidAuditLogConfig) {
      throw new Errors.LogRecordGetTransferStatus.SysAuditLogConfigDoesNotExist({}, { asid: this.asid }, {})
    }

    // HDS 2 System list all non transferred records
    const latestTransferredLogId = asidAuditLogConfig && asidAuditLogConfig.latestTransferredLogId;
    const notTransferredLogCount = await this.dao.countLogsToTransfer(latestTransferredLogId);

    // transform uuAppErrorMap to object if present. It is serialized to string to prevent mongodb issues with error map structure
    let uuAppErrorMap = asidAuditLogConfig.uuAppErrorMap || {};
    if (typeof asidAuditLogConfig.uuAppErrorMap === "string") {
      uuAppErrorMap = JSON.parse(uuAppErrorMap);
    }

    // HDS 3 System returns properly filled dtoOut
    return {
      latestTransferState: asidAuditLogConfig.latestTransferState || null,
      latestTransferDate: asidAuditLogConfig.latestTransferDate || null,
      notTransferredLogCount,
      uuAppErrorMap
    };
  }

  async deleteAuditLogRecordsBeforeTime(awid, dtoIn) {
    //HDS 1
    //HDS 1.1
    let validationResult = this.validator.validate("deleteBeforeTimeDtoInSchemaType", dtoIn);

    //HDS 1.2, A1
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.deleteBeforeTime.unsupportedKeys.code,
      Errors.DeleteBeforeTime.InvalidDtoIn
    );

    // HDS 2
    const toTime = new Date(dtoIn.toTime);

    let deleteCounter = await this.dao.count({
      // TODO, replace this with result of deleteMany operation (after uuAppObjectStore gets fixed)
      awid,
      $or: [
        {
          logTime: { $lt: toTime }
        },
        {
          logTime: { $lt: toTime.toISOString() }
        }
      ]
    });
    await this.dao.deleteBeforeTime(awid, toTime);

    let dtoOut = {};

    // HDS 3
    dtoOut.deletedCount = deleteCounter;
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    // HDS 4
    return dtoOut;
  }

  /**
   *  Returns log records from given time interval.
   *  The result set is paginated in order to avoid big memory footprints.
   *
   * @param {String} awid
   * @param {Object} dtoIn
   * @returns {Promise<*>}
   */
  async logRecordList(awid, dtoIn) {
    // HDS 1. - Performs a logical check of dtoIn.
    let validationResult = this.validator.validate("sysLogRecordListDtoInType", dtoIn);
    let uuAppErrorMap = ValidationHelper.processValidationResult(
      dtoIn,
      validationResult,
      WARNINGS.logRecordList.unsupportedKeys.code,
      Errors.LogRecordList.InvalidDtoIn
    ); // A1, A2

    // converting time to object
    if (dtoIn.timeFrom) {
      dtoIn.timeFrom = new Date(dtoIn.timeFrom);
    }
    if (dtoIn.timeTo) {
      dtoIn.timeTo = new Date(dtoIn.timeTo);
    }

    // HDS 1.4. - Keys that are missing from dtoIn and are provided with a respective default value.
    if (!dtoIn.timeTo) dtoIn.timeTo = new Date();

    let pageInfo = dtoIn.pageInfo || {};
    if (!pageInfo.pageIndex) {
      pageInfo.pageIndex = DEFAULT_PAGE_INFO.pageIndex;
    }
    if (!pageInfo.pageSize) {
      pageInfo.pageSize = DEFAULT_PAGE_INFO.pageSize;
    }

    // HDS 2. - Checks that dtoIn.timeFrom is before dtoIn.timeTo. (A3)
    if (dtoIn.timeFrom >= dtoIn.timeTo) {
      throw new Errors.LogRecordList.InvalidIntervalDefinition({ uuAppErrorMap }, { timeFrom: dtoIn.timeFrom, timeTo: dtoIn.timeTo });
    }

    // HDS 3. - Evaluates the search condition according to the dtoIn parameters

    // HDS 3.1 - If the dtoIn.timeFrom is given, its value is included in the search condition
    // - dtoIn.timeFrom <= sysAuditLogRecord.logTime.

    // HDS 3.2 - If the dtoIn.timeTo is given, its value is included in the search condition
    // - dtoIn.timeTo > sysAuditLogRecord.logTime.

    // HDS 4. - System loads elements matching the search condition, but only on given page. (sysAuditLogRecord DAO listByTime)
    let dtoOut = await this.dao.listByTime(awid, dtoIn.timeFrom, dtoIn.timeTo, pageInfo);

    // HDS 5. - Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  /**
   *  Transfers all non-transferred logs from the application to the uuAppLogStore.
   *
   * @param {Object} uuAppErrorMap
   * @param checkLatestTransferDate
   * @return {object} filled dtoOut object
   */
  async transfer(uuAppErrorMap = {}, checkLatestTransferDate = false) {
    let dtoOut = {};
    // HDS 1 Checks if log transfer to the uuAppLogStore is enabled by checking the appLogStore uri in deploy configuration
    if (!this.appLogStoreUri) {
      throw new Errors.LogRecordTransfer.AppLogStoreUriIsNotSet({ uuAppErrorMap }, { appLogStoreUri: this.appLogStoreUri });
    }

    // HDS 2 System loads sysAuditLogConfig uuObject using sysAuditLogConfig DAO getByAwid and reads sysAuditLogConfig.latestTransferredLogId
    let asidAuditLogConfig = await this.configDao.getByAwid(this.asid) || null;
    if (!asidAuditLogConfig) {
      throw new Errors.LogRecordTransfer.SysAuditLogConfigDoesNotExist({ uuAppErrorMap }, { asid: this.asid }, {})
    }

    if (checkLatestTransferDate && asidAuditLogConfig.latestTransferDate) {
      // method was invoked automatically based on time condition. Checks that time based transfer wasn't processed by another node
      if (!this._checkTimeTransferCondition(asidAuditLogConfig.latestTransferDate)) {
        this.appLogStoreLastTransferDate = asidAuditLogConfig.latestTransferDate
        return; // do not transfer. Transfer was processed on another node within configured time interval
      }
    }

    // HDS 3 System list all non transferred records using sysAuditLogRecord DAO listLogToTransfer with latestTransferredLogId parameter from previous step
    // and reads the number of items and returns this value in dtoOut.logsToTransferCount
    let latestTransferredLogId = asidAuditLogConfig && asidAuditLogConfig.latestTransferredLogId;
    dtoOut.logsToTransferCount = await this.dao.countLogsToTransfer(latestTransferredLogId, {}); // TODO replace with count

    // HDS 4 System transfers AuditLog records
    // HDS 4.1 Finds uuObject sysAuditLogConfig by asid (sysAuditLogConfig DAO get)
    // locks it (5 minutes) and sets sysAuditLogConfig.latestTransferState attribute to running
    let lock = new Lock("logStoreTransfer", 300);
    let transferAlreadyStarted = false;
    try {
      await this.configDao.lockByAwid(this.asid, lock);
      asidAuditLogConfig = await this.configDao.updateById(asidAuditLogConfig.id, { latestTransferState: TRANSFER_STATES.running }, lock)
    } catch (e) {
      if (e instanceof ObjectLocked) {
        ValidationHelper.addWarning(uuAppErrorMap, WARNINGS.transfer.transferHasAlreadyStarted.code, WARNINGS.transfer.transferHasAlreadyStarted.message)
        this.logger.warn("The transfer has already started.");
        transferAlreadyStarted = true;
      } else {
        throw new Errors.LogRecordTransfer.SysAuditLogConfigDaoUpdateFailed({ uuAppErrorMap }, { asid: this.asid, id: asidAuditLogConfig.id }, e)
      }
    }

    // HDS 4.2 Resets locally stored counters for non-transferred logs
    this.appLogStoreNotTransferedCount = 0;
    this.appLogStoreLastTransferDate = new Date();

    // HDS 4.3 Following steps are executed asynchronously
    if (!transferAlreadyStarted) {
      this._transferLogsToLogStore(this.appLogStoreUri, lock, asidAuditLogConfig, uuAppErrorMap);
    }
    // HDS 5 Returns properly filled dtoOut.
    dtoOut.uuAppErrorMap = uuAppErrorMap;
    return dtoOut;
  }

  _checkTimeTransferCondition(latestTransferDate) {
    return (Date.now() - Date.parse(latestTransferDate)) / 1000 / 60 >= this.appLogStoreTransferAfterTime;
  }

  async _transferLogsToLogStore(logStoreUri, lock, asidAuditLogConfig = {}, uuAppErrorMap = {}) {
    this.logger.info(`Transferring AuditLog Records to uuAppLogStore ${this.appLogStoreUri}.`);

    let latestTransferredLogId = asidAuditLogConfig.latestTransferredLogId;
    try {
      let pageInfo = {
        pageSize: 1000,
        pageIndex: 0
      };

      let iteration = 0;
      while (true) {
        // HDS 4.4 Finds non-transferred logs according to sysAuditLogConfig.latestTransferredLogId
        const logsToTransfer = await this.dao.listLogsToTransfer(latestTransferredLogId, pageInfo);
        if (iteration++ % 50 === 0) {
          this.logger.info("Remaining logs to transfer: " + logsToTransfer.pageInfo.total);
        }

        if (logsToTransfer.itemList.length === 0) {
          this.logger.debug(`Nothing to transfer.`);
          break;
        }

        // HDS 4.5 Sends all non-transferred logs to the uuAppLogStore
        const res = await LogStoreClient.importLogRecords(logStoreUri, logsToTransfer.itemList);
        this.logger.debug(`LogRecords transferred successfully. Count ${res.logRecordCount}`);

        // HDS 4.6 System checks lock duration and if it is lower than 1 minute, system extends the lock to 5 minutes
        await this._extendLock(lock);

        // HDS 4.7 Sets sysAuditLogConfig.latestTransferDate
        let latestTransferDate = this.appLogStoreLastTransferDate = new Date();

        // HDS 4.8 Sets sysAuditLogConfig.latestTransferredLogId and updates the uuObject
        latestTransferredLogId = logsToTransfer.itemList.slice(-1)[0].id;
        try {
          await this.configDao.updateById(asidAuditLogConfig.id, { latestTransferredLogId, latestTransferDate }, lock);
        } catch (e) {
          throw new Errors.LogRecordTransfer.SysAuditLogConfigDaoUpdateFailed({ uuAppErrorMap }, { asid: this.asid, id: asidAuditLogConfig.id }, e)
        }

        // HDS 4.9 Checks if there are more logs to transfer
        if (logsToTransfer.itemList.length < pageInfo.pageSize) {
          break;
        }
      }

      // HDS 4.10 Sets sysAuditLogRecord.latestTransferState to completed
      try {
        await this.configDao.updateById(asidAuditLogConfig.id, { latestTransferState: TRANSFER_STATES.completed, uuAppErrorMap: "{}" }, lock);
      } catch (e) {
        throw new Errors.LogRecordTransfer.SysAuditLogConfigDaoUpdateFailed({ uuAppErrorMap }, { asid: this.asid, id: asidAuditLogConfig.id }, e)
      }
      this.logger.info("Transferring AuditLog Records finished without error.");
    } catch (e) {
      const error = new Errors.LogRecordTransfer.TransferRecordsToAppLogStoreFailed({ uuAppErrorMap }, { asid: this.asid, appLogStoreUri: this.appLogStoreUri }, e);
      this.logger.error("Failed to transfer auditLog records to uuAppLogStore.", error);

      const { dtoOut } = ErrorConverter.buildErrorDtoOut(error, true);
      await this.configDao.updateById(asidAuditLogConfig.id, { latestTransferState: TRANSFER_STATES.completedWithError, uuAppErrorMap: JSON.stringify(dtoOut.uuAppErrorMap) }, lock);
    } finally {
      // unlocks the sysAuditLogRecord uuObject
      await this.configDao.unlockById(asidAuditLogConfig.id, lock);
    }
  }

// extend lock if its duration is less than 1 minute
  async _extendLock(lock) {
    const t = new Date();
    t.setSeconds(t.getSeconds() + 60);

    if (lock.expiration < t) {
      await lock.extendExpiration(300);
    }
  }

  async _pruneAuditLogRecords() {
    // HDS 9.2 Checks if record count (using getCount DAO method) is less than maxRecordCount
    let recordCount = await this.dao.getCount();
    if (recordCount < this.maxRecordCount) {
      return false
    }

    // HDS 9.3 Checks if sysAuditLogConfig is not locked
    let pruneLockObtained = await this.configDao.obtainPruneLock(this.asid, this.nodeName, this.pruneLockTtl);
    if (!pruneLockObtained) {
      let sysAuditLogConfig = await this.configDao.getByAwid(this.asid);
      let pruneLock = sysAuditLogConfig && sysAuditLogConfig.pruneLock;
      if (pruneLock) {
        this.logger.warn(
          `Pruning of old uuAuditLog records not triggered because it is locked. It was probably started by another node. pruneLockedBy ${pruneLock.lockedBy}, pruneLockedSince ${pruneLock.lockedSince}, pruneLockTtl ${this.pruneLockTtl}`);
      }
      return false;
    }

    // HDS 9.4 System found latestLogIdToPrune
    let latestLogIdToPrune = await this.dao.findLatestLogIdToPrune(this.minRecordCount);
    if (!latestLogIdToPrune) {
      this.logger.debug(`No uuAuditLog records were found to prune. minRecordCount ${this.minRecordCount}`);
      return false;
    }
    let pruneRecordCount = recordCount - this.minRecordCount;

    // HDS 9.5 System checks prune policy that set in the configuration
    // HDS 9.5.1 If prune policy is equal transferredLogsOnly, then
    if (this.prunePolicy === PRUNE_POLICY_TRANSFERRED_LOGS_ONLY) {
      // HDS 9.5.1.1 System checks if the log has ever been transferred based on sysAuditLogConfig.latestTransferredLogId value
      let sysAuditLogConfig = await this.configDao.getByAwid(this.asid);
      if (!sysAuditLogConfig || !sysAuditLogConfig.latestTransferredLogId) {
        this.logger.error(`Prune policy set to transferredLogsOnly, but the log transfer never started. uuAuditLog records prune wont be triggered. asid ${this.asid}`)
        return false;
      }
      // HDS 9.5.1.2 System checks that all uuAuditLog records based on prune configuration are ready to prune
      let latestTransferredLogId = sysAuditLogConfig.latestTransferredLogId;
      if (latestLogIdToPrune.toString() > latestTransferredLogId.toString()) {
        pruneRecordCount = await this.dao.countOlder(latestTransferredLogId);
        latestLogIdToPrune = latestTransferredLogId;
        this.logger.error(
          `Not all uuAuditLog records found based on prune configuration are ready to prune, because they weren't transferred to the uuAppLogStore yet. Removing only uuAuditLogRecords older than latest transferred record. `
          + `latestTransferredRecordId ${latestTransferredLogId}, pruneRecordCount ${pruneRecordCount}`)
      }
      if (pruneRecordCount < 1) {
        return false;
      }
    }

    // HDS 9.6 System deletes only uuAppAuditLogRecords older than the latest transferred record based on latestLogIdToPrune
    await this.dao.prune(latestLogIdToPrune);
    this.logger.info(
      `Pruning of old uuAuditLog records triggered. totalRecordCount ${recordCount}, pruneRecordCount ${pruneRecordCount}, latestLogIdToPrune ${latestLogIdToPrune},
       minRecordCount ${this.minRecordCount}, maxRecordCount ${this.maxRecordCount}`)
    return true;
  }

}

module.exports = new SysAuditLogAbl();
