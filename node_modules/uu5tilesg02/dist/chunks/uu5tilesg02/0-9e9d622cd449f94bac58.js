/*!
 * UAF COMMERCIAL LICENSE
 * ----------------------
 * 1. PREAMBLE and Definitions
 *   1.1 These UAF Commercial License Terms (“UAF CLT”) govern licensing of the Unicorn Application Framework (UAF).
 *     The Customer and Unicorn concluded an agreement for the provision of Solution that is using UAF or its parts
 *     (the “Agreement”).
 *   1.2 The provisions of these UAF CLT shall govern the relationship between the Customer and Unicorn regarding
 *     the UAF License granted under the Agreement. For the avoidance of doubt, in case of any conflict between these
 *     UAF CLT and the Agreement, the provisions of the Agreement always prevail.
 *   1.3 The “UAF Components”, and each of them individually as “UAF Component”, shall mean the components of the Unicorn
 *     Application Framework, which are listed and described in the Attachment I to these UAF CLT.
 *   1.4 “UAF” shall mean the Unicorn Application Framework the scope of which is described in Attachment I, including all
 *     associated documentation and preparatory design materials, in particular blueprints, models, user manuals,
 *     training materials, comprehensive instructions and guidelines for drafting, production, operation and maintenance of
 *     software solutions, reference architecture, ready-made components and tools, use cases and tutorials.
 *   1.5 The “Knowledge Base” shall mean the online materials, internet fora and other resources made available by Unicorn
 *     online with regard to the UAF, intended for the broad customer and developer community.
 *   1.6 The “License” shall mean the binding terms and conditions for use of the UAF by the Customer. The License is
 *     described in Clause 2 and may be further specified or modified by the Agreement.
 *   1.7 The “Solution” shall mean any product or service developed under the Agreement using the UAF or any of
 *     UAF Components or its other parts, further specified in the Agreement.
 * 2. LICENSE GRANT
 *   2.1 The Customer shall be hereby granted a non-exclusive and non-transferable worldwide license to use the UAF for
 *     the purpose of the Solution described in the Agreement. For this purpose, the Customer shall be entitled to modify
 *     the UAF and create derivative works based on the UAF.
 *   2.2 The Customer is entitled to grant third parties a sub-license allowing them to use the UAF or any derivative works
 *     based on the UAF under commercial terms of its choice, provided that:
 *     2.2.1 use of the UAF and any derivative works based on the UAF by third parties is limited to testing, handover and
 *       operation of the Solution or its use as a service,
 *     2.2.2 third parties are not entitled to use the UAF or any derivative works based on the UAF independently of
 *       the Solution,
 *     2.2.3 third parties are not provided access to source code of the UAF unless such right is granted by the Agreement
 *       or if they conclude a commercial license agreement with Unicorn.
 *   2.3 The Solution or its parts based on the UAF shall bear a prominent copyright notice “Based on Unicorn Application
 *     Framework Copyright (c) Unicorn” integrated
 *     2.3.1 in the graphical user interface of the Solution or its relevant part or
 *     2.3.2 in accompanying file if the Solution or its relevant part do not have graphical user interface or
 *     2.3.3 in Solution´s documentation.
 *   2.4 The License shall be valid for the whole duration of copyright to the UAF, unless other duration of the License is
 *     specified in the Agreement.
 *   2.5 The Customer is entitled to access the Knowledge Base only if expressly agreed in the Agreement.
 *   2.6 The Unicorn retains all rights to the UAF not covered by the provisions of this Clause 2. Unless explicitly
 *     permitted by applicable law, the Customer may not use the UAF in any other way than provided by the provisions of
 *     this Clause 2 and may not allow such use on its behalf by any of its employees or agents.
 *   2.7 The price for the License is included in the price stipulated in the Agreement.
 * 3. MODIFICATIONS
 *   3.1 The Customer explicitly acknowledges that the UAF is under continuous development and any UAF Component or other
 *     part of the UAF may be modified, replaced or removed by the Unicorn from the UAF in any of its future versions.
 *   3.2 This License covers also any new version of UAF if some parts of the UAF are modified or replaced.
 *   3.3 If any part of the UAF is removed by Unicorn in any of its future versions, the License for such version of
 *     the UAF is reduced appropriately and covers only the remaining parts of UAF. Sub-licenses previously granted to
 *     third parties in accordance with Clause 2.2 remain unaffected.
 * 4. THIRD PARTY LICENSE TERMS
 *   4.1 UAF is using third party software tools (the “Third Party Software”) that is an integral part of the UAF. Some of
 *     these tools are free software or open-source SW.
 *   4.2 The list of Third Party Software used in the UAF including its license terms and authors is provided as part of
 *     Attachment I to these UAF CLT.
 *   4.3 For the use of the above mentioned Third Party Software, the Customer acknowledges its license terms referred to
 *     in Attachment I to these UAF CLT.
 * 5. NO TRADEMARK OR PATENT LICENSE
 *   5.1 These UAF CLT cover only copyright use of the UAF. If not expressly agreed otherwise, the Customer shall not be
 *     granted any trademark and/or patent license here under and nothing in these UAF CLT shall be interpreted in a way it
 *     does so.
 * 6. LIMITED WARRANTY
 *   6.1 IF NOT STIPULATED OTHER WISE OR REQUIRED BY APPLICABLE LAW, THE UAF IS PROVIDED ON “AS IS” BASIS,
 *     WITH NO WARRANTY OF, INCLUDING WITHOUT LIMITATION, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
 *     RISK AS TO THE QUALITY AND PERFORMANCE OF THE UAF IS CARRIED SOLELY BY THE CUSTOMER, UNLESS OTHERWISE AGREED BETWEEN
 *     THE UNICORN AND THE CUSTOMER IN THE AGREEMENT.
 * 7. LIMITATION OF LIABILITY
 *   7.1 TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE UNICORN WILL NOT BE HELD LIABLE FOR ANY DAMAGES CAUSED BY
 *     THE DISTRIBUTION OR USE OF THE UAF. THIS ALSO INCLUDES ANY CONSEQUENTIAL AND/OR INCIDENTAL DAMAGES, MONETARY OR NOT,
 *     THAT ARE CONNECTED WITH THE DISTRIBUTION OR USE OF THE UAF, UNLESS OTHERWISE AGREED BETWEEN THE UNICORN AND
 *     THE CUSTOMER IN THE AGREEMENT.
 * 8. THIRD PARTY CLAIMS
 *   8.1 The Unicorn will defend or settle, at its option and expense, any action brought against the Customer in a member
 *     state of the European Union which concerns an allegation that the UAF provided infringes a patent or copyright or
 *     misappropriates a trade secret in such jurisdiction. The Unicorn shall pay costs and damages finally awarded against
 *     the Customer that are attributable to such action. The Customer declares to understand and agrees that following
 *     conditions must be fulfilled in order to make Unicorn´s obligations under this Clause 8 effective and enforceable:
 *     The Customer must (a) notify Unicorn promptly in writing of the action or any reasonable threat of it,
 *     (b) provide the Unicorn with all reasonable information and assistance it will request to settle or defend the action, and
 *     (c) grant the Unicorn sole authority and control of the defense or settlement of the action.
 *   8.2 If a claim is made under Clause 8.1 the Unicorn may, at its sole option and expense:
 *     (a) replace or modify the UAF so that it becomes non-infringing,
 *     (b) procure for the Customer the right to continue using the UAF unmodified.
 *   8.3 The Unicorn shall not be held liable to the Customer if the action is based on:
 *     (a) the combination of UAF with any product not provided by Unicorn,
 *     (b) the modification of the UAF other than by Unicorn,
 *     (c) the use of other than a current unaltered release of the UAF,
 *     (d) a product that the Customer makes, uses, or sells,
 *     (e) infringement by the Customer that is deemed willful. In the case under (e) the Customer shall reimburse
 *     the Unicorn for its reasonable attorney fees and other costs related to the action.
 *   8.4 THIS CLAUSE IS SUBJECT TO CLAUSE 7 AND STATES UNICORN´S ENTIRE LIABILITY, CUSTOMER´S SOLE AND EXCLUSIVE REMEDY,
 *     FOR DEFENSE, SETTLEMENT AND DAMAGES, WITH RESPECT TO ANY ALLEGED PATENT OR COPYRIGHT INFRINGEMENT OR TRADE SECRET
 *     MISAPPROPRIATION BY ANY ITEM PROVIDED UNDER THESE TERMS, UNLESS OTHERWISE AGREEMENT BETWEEN UNICORN AND THE CUSTOMER
 *     IN THE AGREEMENT.
 * 9. GENERAL PROVISIONS
 *   9.1 By entering into the Agreement, the Customer signifies its assent to and acceptance of these UAF CLT.
 *   9.2 The License is effective from the moment of execution of the Agreement, if the Agreement does not specify later
 *     date. Where the provisions of the Agreement regarding the License and provisions of these UAF CLT differ, provisions
 *     of the Agreement shall prevail.
 *   9.3 If any provision of the Agreement regarding the License or these UAF CLT is held by a court of competent
 *     jurisdiction to be void, invalid, unenforceable or illegal, such provision shall be severed from the Agreement or
 *     these UAF CLT and the remaining provisions will remain in full force and effect.
 *   9.4 The provisions of Clauses 7 and 8 shall survive any expiration or termination of the Agreement.
 *   9.5 All rights and obligations between the Unicorn and the Customer arising on the basis of these UAF CLT or
 *     in connection with them are governed by the laws of the Czech Republic with the exclusion of both the rules on
 *     the conflict of laws and the United Nations Convention on Contracts for the International Sale of Goods (CISG).
 *   9.6 The resolution of all disputes arising from or connected here to shall be under sole jurisdiction of the courts of
 *     the Czech Republic.
 */
(window["__webpack_jsonp_uu5tilesg02_1_18_2_uu5tilesg02"] = window["__webpack_jsonp_uu5tilesg02_1_18_2_uu5tilesg02"] || []).push([[0],{

/***/ 119:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DndList", function() { return DndListWrapper; });
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var _internal_dnd_tile_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(120);
/* harmony import */ var _internal_dnd_list_row_wrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(121);
/* harmony import */ var _internal_dnd_drop_indicator_horizontal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(122);
/* harmony import */ var _config_config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);
/* harmony import */ var _use_combined_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(46);
/* harmony import */ var _columns_context__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);
/* harmony import */ var _internal_with_nearest_scroll_element__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(63);
/* harmony import */ var _internal_dnd_scroll_enhancer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(123);
/* harmony import */ var _internal_lazy_libraries__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(85);
/* harmony import */ var _internal_helpers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(27);
var _templateObject, _templateObject2;

var _excluded = ["onDrop", "connectDropTarget", "isDragOver", "canDrop"];

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }














var DropTarget = _internal_lazy_libraries__WEBPACK_IMPORTED_MODULE_11__["default"]["react-dnd"].DropTarget;
var columnPresetList = ["select", "drag"]; // NOTE Must be standard class component while we're using react-dnd@7.0.2 (to get component instance in dropTarget.hover()).

var DndListWrapper = Object(uu5g04__WEBPACK_IMPORTED_MODULE_0__["createVisualComponent"])({
  displayName: "Uu5Tiles.DndListWrapper",
  getInitialState: function getInitialState() {
    this._dndList = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Reference.create();
    return {};
  },
  getList: function getList() {
    return this._dndList.current;
  },
  render: function render() {
    return uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create(DndList, _extends({
      ref: this._dndList
    }, this.props));
  }
});
var DndList = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["createVisualComponent"])({
  displayName: "Uu5Tiles.DndList",
  render: function render(_ref, ref) {
    var onDrop = _ref.onDrop,
        connectDropTarget = _ref.connectDropTarget,
        isDragOver = _ref.isDragOver,
        canDrop = _ref.canDrop,
        listComponentProps = _objectWithoutProperties(_ref, _excluded);

    var _useColumns = Object(_columns_context__WEBPACK_IMPORTED_MODULE_8__["useColumns"])(),
        contextColumns = _useColumns.columns;

    var scrollElement = listComponentProps.scrollElement,
        columns = listComponentProps.columns,
        passAllCellProps = listComponentProps.passAllCellProps;
    var usedColumns = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useMemo"])(function () {
      return (columns || contextColumns).map(function (column) {
        return Object(_internal_helpers__WEBPACK_IMPORTED_MODULE_12__["getPresetColumn"])(column, {
          passAllCellProps: passAllCellProps
        });
      });
    }, [columns, contextColumns, passAllCellProps]);

    var _useList = Object(_list__WEBPACK_IMPORTED_MODULE_2__["useList"])(_objectSpread(_objectSpread({}, listComponentProps), {}, {
      columns: usedColumns,
      _passDndProps: true
    })),
        render = _useList.render,
        listProps = _useList.listProps,
        displayedData = _useList.displayedData,
        data = _useList.data,
        itemKey = _useList.itemKey,
        scrollbarWidth = _useList.scrollbarWidth;

    var listInnerRef = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useRef"])();
    var origInnerRef = listProps.innerRef;
    listProps.innerRef = Object(_use_combined_refs__WEBPACK_IMPORTED_MODULE_7__["useCombinedRefs"])(listInnerRef, origInnerRef);
    var listOuterRef = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useRef"])();
    var origOuterRef = listProps.outerRef;
    listProps.outerRef = Object(_use_combined_refs__WEBPACK_IMPORTED_MODULE_7__["useCombinedRefs"])(listOuterRef, origOuterRef); // prepare information used during drag&drop for computing drop position

    var dropIndicatorRef = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useRef"])();
    var itemCount = listProps.itemCount;
    var getRowHeight = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useMemo"])(function () {
      return typeof listProps.itemSize === "function" ? listProps.itemSize : function () {
        return listProps.itemSize;
      };
    }, [listProps.itemSize]);
    var droppingAfterIndexRef = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useRef"])(-1);
    Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useImperativeHandle"])(ref, function () {
      return {
        getDropIndicator: function getDropIndicator() {
          return dropIndicatorRef.current;
        },
        getItemCount: function getItemCount() {
          return itemCount;
        },
        getRowHeight: getRowHeight,
        getInnerElement: function getInnerElement() {
          return listInnerRef.current;
        },
        setDroppingAfterIndex: function setDroppingAfterIndex(index) {
          droppingAfterIndexRef.current = index;
        },
        getDroppedAfterItem: function getDroppedAfterItem() {
          return displayedData[droppingAfterIndexRef.current];
        },
        getData: function getData() {
          return data;
        },
        getItemKey: function getItemKey() {
          return itemKey;
        }
      };
    }, [getRowHeight, itemCount, displayedData, data, itemKey]); // min-height reserves space to allow drag&dropping onto empty list

    var minHeight = listProps.estimatedItemSize;
    if (!minHeight && typeof listComponentProps.itemHeight === "number") minHeight = listComponentProps.itemHeight;
    return uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create("div", {
      ref: connectDropTarget,
      className: _config_config_js__WEBPACK_IMPORTED_MODULE_6__["default"].Css.css(_templateObject || (_templateObject = _taggedTemplateLiteral(["position: relative; min-height: ", "px;"])), minHeight)
    }, render(listProps, _internal_dnd_tile_wrapper__WEBPACK_IMPORTED_MODULE_3__["default"], _internal_dnd_list_row_wrapper__WEBPACK_IMPORTED_MODULE_4__["default"]), uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create("div", {
      className: _config_config_js__WEBPACK_IMPORTED_MODULE_6__["default"].Css.css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["position: absolute; left: 0; top: 0; right: ", "px; bottom: 0; overflow: hidden; pointer-events: none;"])), scrollbarWidth)
    }, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create(_internal_dnd_drop_indicator_horizontal__WEBPACK_IMPORTED_MODULE_5__["default"], {
      ref: dropIndicatorRef,
      isDragOver: isDragOver
    })), uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create(_internal_dnd_scroll_enhancer__WEBPACK_IMPORTED_MODULE_10__["default"], {
      scrollElement: scrollElement || listOuterRef.current
    }));
  }
}, true);
DndList = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Component.memo(Object(_internal_with_nearest_scroll_element__WEBPACK_IMPORTED_MODULE_9__["default"])(Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["withResize"])(DndList, true), function (scrollComponent, scrollTop) {
  return scrollComponent.scrollTo(scrollTop);
}, "listClassName")); // NOTE Keep HOCs in sync with list.js.

DndList.propTypes = _objectSpread(_objectSpread({}, _list__WEBPACK_IMPORTED_MODULE_2__["List"].propTypes), {}, {
  columns: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.arrayOf(uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOfType([uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.shape(_objectSpread(_objectSpread({}, _internal_helpers__WEBPACK_IMPORTED_MODULE_12__["columnPropTypesKeys"]), {}, {
    type: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOf(columnPresetList)
  })), uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOf(columnPresetList)])),
  onDrop: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.func
});
DndList.defaultProps = _objectSpread(_objectSpread({}, _list__WEBPACK_IMPORTED_MODULE_2__["List"].defaultProps), {}, {
  onDrop: undefined
});
var dropTarget = {
  hover: function hover(props, monitor, component) {
    if (!component) return;
    var listComponent = component.getList();
    if (!listComponent) return;
    var listEl = listComponent.getInnerElement();
    var itemCount = listComponent.getItemCount();
    var getRowHeight = listComponent.getRowHeight;
    var dropIndicator = listComponent.getDropIndicator();

    if (dropIndicator && listEl) {
      var mouseXY = monitor.getClientOffset();
      var listElRect = listEl.getBoundingClientRect();
      var mouseInListTop = mouseXY.y - listElRect.top;
      var cumulativeTotal = 0;
      var rowIndex = -1;

      for (var i = 0; i < itemCount; i++) {
        cumulativeTotal += getRowHeight(i);

        if (mouseInListTop < cumulativeTotal) {
          rowIndex = i;
          break;
        }
      }

      var colIndex = -1;
      var bestDistance = 1e12;
      var before = false;
      var firstItemRect;
      var secondItemRect;
      var listElIdx;

      for (listElIdx = 0; listElIdx < listEl.children.length; listElIdx += 1) {
        var rect = listEl.children[listElIdx].getBoundingClientRect();
        if (rect.top - listElRect.top >= cumulativeTotal) break;
      }

      listElIdx -= 1;

      if (listElIdx >= 0) {
        for (var _i = 0; _i < 1 && listElIdx + _i < listEl.children.length; _i++) {
          var tileEl = listEl.children[listElIdx + _i];
          var tileElRect = tileEl.getBoundingClientRect();
          var distance = mouseXY.x < tileElRect.top ? tileElRect.top - mouseXY.y : mouseXY.y > tileElRect.bottom ? mouseXY.y - tileElRect.bottom : 0;

          if (distance < bestDistance) {
            colIndex = _i;
            bestDistance = distance;
            before = mouseXY.y < (tileElRect.top + tileElRect.bottom) / 2;

            if (before) {
              firstItemRect = _i ? listEl.children[listElIdx + _i - 1].getBoundingClientRect() : null;
              secondItemRect = tileElRect;
            } else {
              firstItemRect = tileElRect;
              secondItemRect = null;
            }
          }
        }
      }

      dropIndicator.setPosition(firstItemRect, secondItemRect);
      listComponent.setDroppingAfterIndex(rowIndex >= 0 && colIndex >= 0 ? rowIndex + colIndex + (before ? -1 : 0) : -1);
    }
  },
  drop: function drop(props, monitor, component) {
    if (!monitor.didDrop()) {
      var item = monitor.getItem();

      if (typeof props.onDrop === "function") {
        var listComponent = component.getList();

        if (listComponent) {
          var data = listComponent.getData();
          var items = [item.data];
          var itemBefore = listComponent.getDroppedAfterItem();
          var itemKey = listComponent.getItemKey();
          var itemIdsToRemove = new Set(items.map(function (it) {
            return itemKey(it);
          }));
          var newData = data.filter(function (it) {
            return !itemIdsToRemove.has(itemKey(it));
          });
          var insertAt = itemBefore ? newData.findIndex(function (it) {
            return itemKey(itemBefore) === itemKey(it);
          }) + 1 : 0;
          newData.splice.apply(newData, [insertAt, 0].concat(items));
          props.onDrop({
            items: items,
            itemBefore: itemBefore,
            data: newData
          });
        }
      }
    }
  }
};

var dropPropsExpander = function dropPropsExpander(connect, monitor) {
  // which extra props to inject into component which can be dropped to (ListDropArea)
  return {
    connectDropTarget: connect.dropTarget(),
    isDragOver: monitor.isOver(),
    canDrop: monitor.isOver() && monitor.canDrop() // using "monitor.isOver() && ..." because it has much better performance this way

  };
};

DndListWrapper = DropTarget(["Uu5Tiles.Tile"], dropTarget, dropPropsExpander)(DndListWrapper);
DndListWrapper = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.DnD.withContext(DndListWrapper);

/* harmony default export */ __webpack_exports__["default"] = (DndListWrapper);

/***/ }),

/***/ 120:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DndTileWrapper", function() { return DndTileWrapper; });
/* harmony import */ var _tile_wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
/* harmony import */ var _lazy_libraries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);


var DragSource = _lazy_libraries__WEBPACK_IMPORTED_MODULE_1__["default"]["react-dnd"].DragSource;
var dragSource = {
  canDrag: function canDrag(props) {
    return props.data && props.itemKey(props.data) != null;
  },
  beginDrag: function beginDrag(props, monitor, component) {
    // return the data describing the dragged item
    return {
      id: props.itemKey(props.data),
      data: props.data
    };
  },
  endDrag: function endDrag() {// dragOpExtraState = {
    //   dropAllowedOn: {},
    //   dragSourceComponent: null
    // };
  },
  isDragging: function isDragging(props, monitor) {
    // our Tile-s are in react-window, i.e. they might be unmounted during drag & sufficient scroll
    // => if user scrolls back (during drag operation) match the newly mounted component by ID
    return props.data && props.itemKey(props.data) === monitor.getItem().id;
  }
};

var dragPropsExpander = function dragPropsExpander(connect, monitor) {
  // which extra props to inject into component which can be dragged (Tile)
  return {
    connectDragSource: connect.dragSource(),
    connectDragPreview: connect.dragPreview(),
    isDragging: monitor.isDragging()
  };
};

var DndTileWrapper = DragSource("Uu5Tiles.Tile", dragSource, dragPropsExpander)(_tile_wrapper__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DndTileWrapper);

/***/ }),

/***/ 121:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DndListRowWrapper", function() { return DndListRowWrapper; });
/* harmony import */ var _list_row__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var _lazy_libraries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);


var DragSource = _lazy_libraries__WEBPACK_IMPORTED_MODULE_1__["default"]["react-dnd"].DragSource;
var dragSource = {
  canDrag: function canDrag(props) {
    return props.data && props.itemKey(props.data) != null;
  },
  beginDrag: function beginDrag(props, monitor, component) {
    // return the data describing the dragged item
    return {
      id: props.itemKey(props.data),
      data: props.data
    };
  },
  endDrag: function endDrag() {// dragOpExtraState = {
    //   dropAllowedOn: {},
    //   dragSourceComponent: null
    // };
  },
  isDragging: function isDragging(props, monitor) {
    // our Tile-s are in react-window, i.e. they might be unmounted during drag & sufficient scroll
    // => if user scrolls back (during drag operation) match the newly mounted component by ID
    return props.data && props.itemKey(props.data) === monitor.getItem().id;
  }
};

var dragPropsExpander = function dragPropsExpander(connect, monitor) {
  // which extra props to inject into component which can be dragged (Tile)
  return {
    connectDragSource: connect.dragSource(),
    connectDragPreview: connect.dragPreview(),
    isDragging: monitor.isDragging()
  };
};

var DndListRowWrapper = DragSource("Uu5Tiles.Tile", dragSource, dragPropsExpander)(_list_row__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DndListRowWrapper);

/***/ }),

/***/ 122:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DndDropIndicatorHorizontal", function() { return DndDropIndicatorHorizontal; });
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _config_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
var _templateObject, _templateObject2;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





function isRectSame(rect1, rect2) {
  if (!rect1 || !rect2) return rect1 === rect2;
  return rect1.left === rect2.left && rect1.top === rect2.top && rect1.right === rect2.right && rect1.bottom === rect2.bottom;
}

var DndDropIndicatorHorizontal = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Reference.forward(function DndDropIndicatorHorizontal(_ref, ref) {
  var isDragOver = _ref.isDragOver;

  var _useState = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useState"])({}),
      _useState2 = _slicedToArray(_useState, 2),
      _useState2$ = _useState2[0],
      firstItemRect = _useState2$.firstItemRect,
      secondItemRect = _useState2$.secondItemRect,
      _setPosition = _useState2[1];

  var elRef = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useRef"])();
  Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useImperativeHandle"])(ref, function () {
    return {
      setPosition: function setPosition(firstItemRect, secondItemRect) {
        _setPosition(function (position) {
          return isRectSame(position.firstItemRect, firstItemRect) && isRectSame(position.secondItemRect, secondItemRect) ? position : {
            firstItemRect: firstItemRect,
            secondItemRect: secondItemRect
          };
        });
      }
    };
  }); // compute indicator position based on tile item rectangles

  var element = elRef.current;

  var _useState3 = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useState"])(),
      _useState4 = _slicedToArray(_useState3, 2),
      forceUpdate = _useState4[1];

  var cssPos = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useMemo"])(function () {
    var result = {};

    if (element && element.offsetParent) {
      // necessary due to jest tests
      var relativeElRect = element.offsetParent.getBoundingClientRect();

      if (!firstItemRect && secondItemRect) {
        // before 1st tile item in a row => position to the left edge of the item
        result.top = secondItemRect.top - relativeElRect.top;
      } else if (firstItemRect && !secondItemRect) {
        // after last tile item in a row => position to the right edge of the item
        result.top = firstItemRect.bottom - relativeElRect.top;
      } else {
        // TODO
        // into empty grid
        result.left = 0;
        result.top = 0;
      }
    }

    return result; // eslint-disable-next-line uu5/hooks-exhaustive-deps
  }, [firstItemRect, secondItemRect, element]);
  var shouldRenderPositioned = isDragOver;
  Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useLayoutEffect"])(function () {
    if (shouldRenderPositioned) forceUpdate({}); // force update to recompute cssPos as now we have elRef.current
    // eslint-disable-next-line uu5/hooks-exhaustive-deps
  }, []);
  var canUseCssTransitionRef = Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useRef"])(false);
  Object(uu5g04_hooks__WEBPACK_IMPORTED_MODULE_1__["useLayoutEffect"])(function () {
    canUseCssTransitionRef.current = shouldRenderPositioned;
  }, [shouldRenderPositioned]);
  var result;
  var className = _config_config_js__WEBPACK_IMPORTED_MODULE_2__["default"].Css.css(_templateObject || (_templateObject = _taggedTemplateLiteral(["position: absolute; left: 0; top: 0; pointer-events: none;"])));

  if (shouldRenderPositioned) {
    className += " " + _config_config_js__WEBPACK_IMPORTED_MODULE_2__["default"].Css.css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n        ", "\n        border: 3px solid #3991E1;\n        border-radius: 3px;\n        width: 100%;\n      "])), canUseCssTransitionRef.current ? "transition: transform 0.15s, height 0.15s;" : "");
    result = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create("div", {
      ref: elRef,
      className: className,
      style: {
        transform: "translateY(-50%) translateY(".concat(cssPos.top, "px)")
      }
    });
  } else {
    result = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create("div", {
      ref: elRef,
      className: className
    });
  }

  return result;
});
/* harmony default export */ __webpack_exports__["default"] = (DndDropIndicatorHorizontal);

/***/ }),

/***/ 123:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DndScrollEnhancer", function() { return DndScrollEnhancer; });
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var uu5g04__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uu5g04__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uu5g04_bricks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
/* harmony import */ var uu5g04_bricks__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uu5g04_bricks__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _config_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//@@viewOn:imports


 //@@viewOff:imports

var DndScrollEnhancerBase = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.BaseMixin, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.ElementaryMixin],
  //@@viewOff:mixins
  //@@viewOn:statics
  statics: {
    tagName: _config_config_js__WEBPACK_IMPORTED_MODULE_2__["default"].TAG + "DndScrollEnhancer",
    classNames: {
      main: _config_config_js__WEBPACK_IMPORTED_MODULE_2__["default"].CSS + "dnd-scroll-enhancer"
    }
  },
  //@@viewOff:statics
  //@@viewOn:propTypes
  propTypes: {
    scrollElement: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.oneOfType([uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.string, uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.object]),
    horizontalOffset: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.number,
    verticalOffset: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.number,
    dragDropManager: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes.any
  },
  //@@viewOff:propTypes
  //@@viewOn:getDefaultProps
  getDefaultProps: function getDefaultProps() {
    return {
      scrollElement: undefined,
      horizontalOffset: 150,
      verticalOffset: 150,
      dragDropManager: undefined
    };
  },
  //@@viewOff:getDefaultProps
  //@@viewOn:reactLifeCycle
  getInitialState: function getInitialState() {
    this._enhancerRegistration = null;
    this._domNode = null;
    return {};
  },
  componentDidMount: function componentDidMount() {
    this._updateEnhancer();
  },
  componentDidUpdate: function componentDidUpdate() {
    this._updateEnhancer();
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this._enhancerRegistration) this._enhancerRegistration.detach();
  },
  //@@viewOff:reactLifeCycle
  //@@viewOn:interface
  //@@viewOff:interface
  //@@viewOn:overriding
  //@@viewOff:overriding
  //@@viewOn:private
  _updateEnhancer: function _updateEnhancer() {
    var usedScrollElement;

    if (this.props.scrollElement) {
      usedScrollElement = this.props.scrollElement;
    } else if (this._domNode) {
      var node = this._domNode.parentNode;

      while (node && node.tagName) {
        var computedStyle = getComputedStyle(node);

        if (computedStyle.overflowY !== "visible" && computedStyle.overflowY !== "hidden") {
          usedScrollElement = node;
          break;
        }

        node = node.parentNode;
      }
    }

    var _this$props = this.props,
        horizontalOffset = _this$props.horizontalOffset,
        verticalOffset = _this$props.verticalOffset,
        dragDropManager = _this$props.dragDropManager;
    var params = {
      horizontalOffset: horizontalOffset,
      verticalOffset: verticalOffset
    };

    if (!this._enhancerRegistration) {
      if (usedScrollElement) this._enhancerRegistration = ScrollEnhancer.attachEnhancer(usedScrollElement, dragDropManager, params);
    } else if (usedScrollElement !== this._enhancerRegistration.getScrollElement()) {
      this._enhancerRegistration.detach();

      if (usedScrollElement) this._enhancerRegistration = ScrollEnhancer.attachEnhancer(usedScrollElement, dragDropManager, params);else this._enhancerRegistration = null;
    } else {
      this._enhancerRegistration.setParams(params);
    }
  },
  _setDomNodeRef: function _setDomNodeRef(ref) {
    this._domNode = ref;
  },
  //@@viewOff:private
  //@@viewOn:render
  render: function render() {
    return this.props.scrollElement ? null : uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Element.create("span", {
      className: uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.ClassNames.hidden,
      ref: this._setDomNodeRef
    });
  } //@@viewOff:render

}); // NOTE Heavily inspired by react-dnd-scrollzone but works for "window" scroll too
// (https://github.com/azuqua/react-dnd-scrollzone/issues/5).

var ScrollEnhancer = /*#__PURE__*/function () {
  function ScrollEnhancer(scrollElement, dragDropManager, params) {
    _classCallCheck(this, ScrollEnhancer);

    this.scrollElement = scrollElement;
    this.dragDropManager = dragDropManager;
    this.setParams(params);
    this._isDragging = dragDropManager ? dragDropManager.getMonitor().isDragging() : false;
    this._isTrackingDrag = false;
    this._destroyed = false;
    this._listeners = [];
    this._scrollDeltaX = 30;
    this._scrollDeltaY = 30;
    this._updateScrolling = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.Tools.throttle(this._updateScrolling.bind(this), 100, {
      trailing: false
    });
    this._startTrackingDrag = this._startTrackingDrag.bind(this);
    this._handleTouchStart = this._handleTouchStart.bind(this);
    this._handleTouchEnd = this._handleTouchEnd.bind(this);
    this._handleTouchCancel = this._handleTouchCancel.bind(this);
    this._handleTouchMove = this._handleTouchMove.bind(this);
    this._onDdmChange = this._onDdmChange.bind(this);

    this._addListener(scrollElement === window ? document.scrollingElement || document.body : scrollElement, "dragover", this._startTrackingDrag); // "touch" events needs to be on root


    this._addListener(document.scrollingElement || document.body, "touchstart", this._handleTouchStart);

    this._addListener(document.scrollingElement || document.body, "touchend", this._handleTouchEnd);

    this._addListener(document.scrollingElement || document.body, "touchcancel", this._handleTouchCancel);

    this._addListener(document.scrollingElement || document.body, "touchmove", this._handleTouchMove);

    if (dragDropManager) {
      this._clearDdmSubscription = dragDropManager.getMonitor().subscribeToStateChange(this._onDdmChange);
    }
  }

  _createClass(ScrollEnhancer, [{
    key: "setParams",
    value: function setParams(_ref) {
      var horizontalOffset = _ref.horizontalOffset,
          verticalOffset = _ref.verticalOffset;
      this.horizontalOffset = horizontalOffset;
      this.verticalOffset = verticalOffset;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._destroyed = true;

      this._listeners.forEach(function (fn) {
        return fn();
      });

      this._stopScrolling();

      this._clearDdmSubscription();

      this._touchCleanup();

      clearTimeout(this._dragCancelTimeout);
    }
  }, {
    key: "_addListener",
    value: function _addListener(obj, type, fn) {
      obj.addEventListener(type, fn);

      this._listeners.push(function () {
        return obj.removeEventListener(type, fn);
      });
    }
  }, {
    key: "_onDdmChange",
    value: function _onDdmChange() {
      var isDragging = this.dragDropManager.getMonitor().isDragging();

      if (isDragging && !this._isDragging) {
        this._isDragging = true;
      } else if (!isDragging && this._isDragging) {
        this._isDragging = false;

        this._stopScrolling();
      }
    }
  }, {
    key: "_handleTouchStart",
    value: function _handleTouchStart(e) {
      // NOTE If the element where touch started gets unmounted (which react-virtualized tends to do...),
      // browser stops sending any touch events. This was happening on Android devices on e12.html demo.
      //   =>
      // Guard the element and if during scrolling we detect that the element got unmounted, we'll
      // re-mount it to the BODY as hidden, which luckily makes touch events work again.
      if (!this._guardedTouchNode) {
        this._guardedTouchNode = e.target;
      }
    }
  }, {
    key: "_handleTouchEnd",
    value: function _handleTouchEnd(e) {
      this._touchCleanup();
    }
  }, {
    key: "_handleTouchCancel",
    value: function _handleTouchCancel(e) {
      this._touchCleanup();
    }
  }, {
    key: "_touchCleanup",
    value: function _touchCleanup() {
      if (this._guardedTouchNode) {
        if (this._guardedTouchNodeRemounted && this._guardedTouchNode.parentNode) {
          this._guardedTouchNode.parentNode.removeChild(this._guardedTouchNode);
        }

        this._guardedTouchNode = null;
        this._guardedTouchNodeRemounted = false;
      }
    }
  }, {
    key: "_handleTouchMove",
    value: function _handleTouchMove(e) {
      // only start tracking if touchstart has been triggerred on our scrollingElement (i.e. we have a guarded node)
      if (this._guardedTouchNode) this._startTrackingDrag(e);
    }
  }, {
    key: "_startTrackingDrag",
    value: function _startTrackingDrag(e) {
      if (!this._isTrackingDrag && (!this.dragDropManager || this._isDragging)) {
        this._isTrackingDrag = true;
        (document.scrollingElement || document.body).addEventListener("dragover", this._updateScrolling);
        (document.scrollingElement || document.body).addEventListener("touchmove", this._updateScrolling);
      }
    }
  }, {
    key: "_stopTrackingDrag",
    value: function _stopTrackingDrag() {
      this._isTrackingDrag = false;
      (document.scrollingElement || document.body).removeEventListener("dragover", this._updateScrolling);
      (document.scrollingElement || document.body).removeEventListener("touchmove", this._updateScrolling);
      clearTimeout(this._dragCancelTimeout);
    }
  }, {
    key: "_updateScrolling",
    value: function _updateScrolling(e) {
      var _this = this;

      if (!this.dragDropManager) {
        this._isDragging = true; // if user drags e.g. .zip file over BODY and drops it then we don't get
        // any event about that => if no dragover happens within
        // some time then assume the user is no longer dragging

        clearTimeout(this._dragCancelTimeout);
        Promise.resolve().then(function () {
          if (_this._destroyed) return;
          _this._dragCancelTimeout = setTimeout(function () {
            if (_this._isDragging) {
              _this._isDragging = false;

              _this._stopScrolling();
            }
          }, 500);
        });
      }

      var scrollElement = this.scrollElement;
      var scrollZoneRect = scrollElement === window ? {
        left: 0,
        top: 0,
        bottom: window.innerHeight,
        right: window.innerWidth,
        height: window.innerHeight,
        width: window.innerWidth
      } : scrollElement.getBoundingClientRect();
      var mousePos = e.type === "touchmove" ? {
        x: e.changedTouches[0].clientX,
        y: e.changedTouches[0].clientY
      } : {
        x: e.clientX,
        y: e.clientY
      };
      var animate = false;
      var insideScrollZone = false;

      if (scrollZoneRect.left <= mousePos.x && mousePos.x <= scrollZoneRect.right && scrollZoneRect.top <= mousePos.y && mousePos.y <= scrollZoneRect.bottom) {
        this._runningAdjust = this._computeScrollAdjust(scrollZoneRect, mousePos);
        animate = !!(this._runningAdjust.dx || this._runningAdjust.dy);
        insideScrollZone = true;
      }

      if (animate) {
        if (!this._runningRafId) this._startScrolling();
      } else if (!this.dragDropManager || !insideScrollZone) {
        this._runningAdjust = {};

        this._stopScrolling();
      }
    }
  }, {
    key: "_startScrolling",
    value: function _startScrolling() {
      var _this2 = this;

      var i = 0;

      var tick = function tick() {
        if (!_this2._guardedTouchNodeRemounted && _this2._guardedTouchNode && !document.contains(_this2._guardedTouchNode)) {
          _this2._guardedTouchNodeRemounted = true;

          _this2._guardedTouchNode.classList.add("uu5-common-hidden");

          document.body.appendChild(_this2._guardedTouchNode);
        }

        var _this2$_runningAdjust = _this2._runningAdjust,
            dx = _this2$_runningAdjust.dx,
            dy = _this2$_runningAdjust.dy;

        if (!dx && !dy) {
          _this2._stopScrolling();
        } else {
          i ^= 1; // on Android mobiles we cannot scroll on each paint because it somehow stops the page from dnd handling

          if (i) {
            var elem = _this2.scrollElement === window ? document.scrollingElement || document.body : _this2.scrollElement;
            var newScrollLeft = Math.max(0, Math.min(elem.scrollWidth - elem.clientWidth, elem.scrollLeft + dx));
            var newScrollTop = Math.max(0, Math.min(elem.scrollHeight - elem.clientHeight, elem.scrollTop + dy));
            if (newScrollLeft !== elem.scrollLeft) elem.scrollLeft = newScrollLeft;
            if (newScrollTop !== elem.scrollTop) elem.scrollTop = newScrollTop;
          }

          _this2._runningRafId = requestAnimationFrame(tick);
        }
      };

      tick();
    }
  }, {
    key: "_stopScrolling",
    value: function _stopScrolling() {
      this._stopTrackingDrag();

      if (this._runningRafId) cancelAnimationFrame(this._runningRafId);
      this._runningRafId = null;
    }
  }, {
    key: "_computeScrollAdjust",
    value: function _computeScrollAdjust(scrollZoneRect, mousePos) {
      var horizontalOffset = Math.max(1, Math.min(this.horizontalOffset, scrollZoneRect.width / 2 - 64)); // 128x128 <=> reserved for central square which doesn't react to scroll (to be able to drop)

      var leftEdgeNorm = 1 - (mousePos.x - scrollZoneRect.left) / horizontalOffset; // (-Inf, 1>, valid is <0, 1>

      var rightEdgeNorm = 1 - (scrollZoneRect.right - mousePos.x) / horizontalOffset; // (-Inf, 1>, valid is <0, 1>

      var verticalOffset = Math.max(1, Math.min(this.verticalOffset, scrollZoneRect.height / 2 - 64));
      var topEdgeNorm = 1 - (mousePos.y - scrollZoneRect.top) / verticalOffset; // (-Inf, 1>, valid is <0, 1>

      var bottomEdgeNorm = 1 - (scrollZoneRect.bottom - mousePos.y) / verticalOffset; // (-Inf, 1>, valid is <0, 1>

      var ease = function ease(number) {
        return number;
      }; // linear easing


      var dx = leftEdgeNorm >= 0 ? -ease(leftEdgeNorm) : rightEdgeNorm >= 0 ? ease(rightEdgeNorm) : 0;
      var dy = topEdgeNorm >= 0 ? -ease(topEdgeNorm) : bottomEdgeNorm >= 0 ? ease(bottomEdgeNorm) : 0;
      dx = Math.round(dx * this._scrollDeltaX);
      dy = Math.round(dy * this._scrollDeltaY);
      return {
        dx: dx,
        dy: dy
      };
    }
  }], [{
    key: "attachEnhancer",
    value:
    /**
     * Initializes / updates scroll enhancer for specified DOM element. This method is safe to be called multiple times for
     * the same element - each such call receives different "registration" that can be used for manipulating
     * the scroll enhancer. Each "registration" must call "registration.detach()" after it no longer wants the DOM element
     * to be enhanced.
     *
     * The parameters that scroll enhancer uses are always taken from the last "registration". After "registration.detach()",
     * if there were multiple "registrations", scroll enhancer will still be active and will use parameters from previous
     * "registration". Scroll enhancer will be detached from the DOM element after all "registrations" are detached.
     *
     * @param {*} scrollElement
     * @param {*} params Parameters for scroll enhancer - horizontalOffset, verticalOffset.
     * @return Scroll enhancer's "registration".
     */
    function attachEnhancer(scrollElement) {
      var dragDropManager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var instanceInfo = ScrollEnhancer.instances.get(scrollElement);

      if (!instanceInfo) {
        var _instance = new ScrollEnhancer(scrollElement, dragDropManager, params);

        instanceInfo = {
          instance: _instance,
          registrations: []
        };
        ScrollEnhancer.instances.set(scrollElement, instanceInfo);
      }

      var _instanceInfo = instanceInfo,
          instance = _instanceInfo.instance,
          registrations = _instanceInfo.registrations;
      var registration = {
        getScrollElement: function getScrollElement() {
          return scrollElement;
        },
        getParams: function getParams() {
          return params;
        },
        detach: function detach() {
          var idx = registrations.indexOf(registration);
          if (idx === -1) return;
          registrations.pop();

          if (registrations.length === 0) {
            // no active registrations => detach completely
            instance.destroy();
            ScrollEnhancer.instances.delete(scrollElement);
          } else if (idx === registrations.length) {
            // detached registration that was active => change params to previous
            instance.setParams(registrations[idx - 1].getParams());
          }
        },
        setParams: function setParams(newParams) {
          params = newParams;
          if (registrations[registrations.length - 1] === registration) instance.setParams(params);
        }
      };
      instanceInfo.registrations.push(registration);
      return registration;
    }
  }]);

  return ScrollEnhancer;
}();

_defineProperty(ScrollEnhancer, "instances", new Map());

var DndScrollEnhancer = uu5g04__WEBPACK_IMPORTED_MODULE_0___default.a.Common.DnD.withContext(DndScrollEnhancerBase);
/* harmony default export */ __webpack_exports__["default"] = (DndScrollEnhancer);

/***/ })

}]);